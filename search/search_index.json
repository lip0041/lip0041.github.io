{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to my site \u00b6 This is my new site.","title":"Getting Started"},{"location":"#welcome-to-my-site","text":"This is my new site.","title":"Welcome to my site"},{"location":"cpp/cpp-pat-a1065/","text":"\u9898\u89e3\u4ee3\u7801\u94fe\u63a5 \u00b6 A1065 A+B and C(64bit) \u9898\u76ee\u8bf4\u660e \u00b6 \u6b64\u9898\u662f\u8003\u5bdf\u6ea2\u51fa\u7684\u95ee\u9898\uff0c\u672c\u5e94\u8be5\u662f\u8f83\u4e3a\u5bb9\u6613\u7684\u9898\u3002\u4f46\u662f\u7531\u4e8e\u6211\u73b0\u5728\u662f\u5728\u5b66\u4e60c++\u4e2d\uff0c\u5e72\u5565\u90fd\u7528 cin / cout \u3002 \u53d1\u73b0\u63d0\u4ea4\u8fd9\u4e2a\u9898\u7684\u65f6\u5019\uff0c\u7b2c\u4e09\u4e2a\u6d4b\u8bd5\u70b9\u7528 cin \u8fc7\u4e0d\u53bb\uff0c\u7528 scanf \u5c31\u8fc7\u53bb\u4e86\u3002\u4e8e\u662f\u5c31\u60f3\u7740\u63a2\u7a76\u4e00\u756a cin \u4e0e scanf \u63a2\u7a76 \u00b6 \u901a\u8fc7 \u67e5\u9605\u8d44\u6599 \u5f97\u77e5\uff0c cin \u662f\u67094\u4e2a\u6761\u4ef6\u72b6\u6001\u91cf\u7684\uff1a goodbit:\u65e0\u9519\u8bef eofbit:\u5df2\u5230\u8fbe\u6587\u4ef6\u5c3e failbit:\u975e\u81f4\u547d\u7684\u8f93\u5165/\u8f93\u51fa\u9519\u8bef\uff0c\u53ef\u633d\u56de badbit:\u81f4\u547d\u7684\u8f93\u5165/\u8f93\u51fa\u9519\u8bef,\u65e0\u6cd5\u633d\u56de \u800c\u50cf\u8fd9\u79cd\u8f93\u5165\u683c\u5f0f\u4e0d\u7b26\u5408\u6d41\u8bbe\u7f6e\u7684\u683c\u5f0f\u5219\u51fa\u9519\uff0c\u5982 cin \u4e00\u4e2a int \u6570\u636e\uff0c\u4f46\u662f\u5176\u503c\u4e3a \\(2^{31}\\) =2147483648\uff0c\u4ea7\u751f\u4e0a\u6ea2\u3002 cin \u7684\u5904\u7406 \u6b64\u65f6 failbit \u5c06\u88ab\u8bbe\u7f6e\u4e3a1\uff0c\u8868\u793a\u51fa\u9519\uff0c\u4e14\u6b64\u65f6 cin \u8f93\u5165\u7684\u6570\u636e\u4ee5\u51681\u8868\u793a\u51fa\u9519\uff0c\u6b64\u5904\u5373\u4e3a \\(2^{31}-1\\) =2147483647\u3002 * scanf \u7684\u5904\u7406 \u6b64\u65f6\u8f93\u5165\u7684\u503c\u4e3a \\(-2^{31}\\) \uff0c\u5373-2147483648 `cin`\u8fd4\u56defalse\u5219\u51fa\u9519\uff0c\u53ef\u4ee5\u68c0\u6d4b\u51fa\u8fd9\u79cdfailbit\u51fa\u9519\uff0c\u5373\u7528`cin.fail()`\u3002\u82e5`failbit`\u88ab\u8bbe\u7f6e\u4e86\uff0c\u5219\u8fd4\u56de`true`\u3002\u6355\u83b7\u5230\u9519\u8bef\u540e\uff0c\u5219\u53ef\u4ee5\u901a\u8fc7`cin.clear()`\u6e05\u9664\u72b6\u6001\u6807\u5fd7\u4f4d\uff0c\u5373\u53ef\u4ee5\u633d\u56de\u3002\u6b64\u65f6\u53ef\u7ee7\u7eed\u8f93\u5165\u65b0\u7684\u503c\u5b58\u5165\u521a\u624d\u8981\u5b58\u5165\u7684\u53d8\u91cf\u4e2d\uff0c\u4e4b\u524d\u7684\u9519\u8bef\u8f93\u5165\u5219\u88ab\u4e22\u5f03\uff08\u8fd9\u4e00\u70b9\u6211\u5176\u5b9e\u6709\u5728\u67e5\u627e\u80fd\u5426\u4e0d\u4e22\u5f03\uff0c\u91cd\u65b0\u5229\u7528\uff0c\u4f46\u6ca1\u6709\u627e\u5230\u8fd9\u65b9\u9762\u4f46\u8d44\u6599\ud83d\ude43\uff09 **\u82e5\u4e0d\u6e05\u9664\u72b6\u6001\u6807\u5fd7\u4f4d\uff0c\u5219\u540e\u7eed\u4e0d\u80fd\u7ee7\u7eed\u8fdb\u884c\u8f93\u5165** \u8fd8\u6709\u4e00\u4e2a\u95ee\u9898\u662f\uff0c\u4f7f\u7528`int`\u662f\u53ef\u4ee5\u6d4b\u51fa\u8fd9\u4e2a\u5dee\u522b\u7684\uff0c\u4f46\u6b64\u9898\u662f\u7528`long long`\u578b\u7684\uff0c\u6216\u8bb8\u662f\u56e0\u4e3a\u76ee\u524d\u673a\u5668\uff08\u5305\u62ecoj\uff09\u57fa\u672c\u90fd\u662f64\u4f4d\u7684\uff0c\u6240\u4ee5\u5728\u8fd9\u91cc\u5bf9`long long`\u7684\u6ea2\u51fa\u5904\u7406`cin`\u548c`scanf`\u662f\u4e00\u6837\u7684\u3002 **\u6d4b\u8bd5\u5982\u56fe** ![\u8f93\u5165\u6570\u636e](Screen-Shot-2021-02-02-at-23.21.39.png) ![\u7ed3\u679c](Screen-Shot-2021-02-02-at-23.22.20.png) \u663e\u800c\u6613\u89c1\uff0c`cin`\u4e0e`scanf`\u7684\u5dee\u5f02\u4e4b\u5904 \u5bf9\u4e86\uff0c\u5bf9\u4e8e\u6548\u7387\u8fd9\u65b9\u9762\uff0c`cin`\u82e5\u4f7f\u7528\u4e86`cin.sync_with_stdio(false)`\u5173\u95ed\u540c\u6b65\uff0c\u5373\u53ef\u8ddf`scanf`\u6548\u7387\u5dee\u4e0d\u591a\u3002","title":"\u9898\u89e3\u4ee3\u7801\u94fe\u63a5"},{"location":"cpp/cpp-pat-a1065/#_1","text":"A1065 A+B and C(64bit)","title":"\u9898\u89e3\u4ee3\u7801\u94fe\u63a5"},{"location":"cpp/cpp-pat-a1065/#_2","text":"\u6b64\u9898\u662f\u8003\u5bdf\u6ea2\u51fa\u7684\u95ee\u9898\uff0c\u672c\u5e94\u8be5\u662f\u8f83\u4e3a\u5bb9\u6613\u7684\u9898\u3002\u4f46\u662f\u7531\u4e8e\u6211\u73b0\u5728\u662f\u5728\u5b66\u4e60c++\u4e2d\uff0c\u5e72\u5565\u90fd\u7528 cin / cout \u3002 \u53d1\u73b0\u63d0\u4ea4\u8fd9\u4e2a\u9898\u7684\u65f6\u5019\uff0c\u7b2c\u4e09\u4e2a\u6d4b\u8bd5\u70b9\u7528 cin \u8fc7\u4e0d\u53bb\uff0c\u7528 scanf \u5c31\u8fc7\u53bb\u4e86\u3002\u4e8e\u662f\u5c31\u60f3\u7740\u63a2\u7a76\u4e00\u756a","title":"\u9898\u76ee\u8bf4\u660e"},{"location":"cpp/cpp-pat-a1065/#cin-scanf","text":"\u901a\u8fc7 \u67e5\u9605\u8d44\u6599 \u5f97\u77e5\uff0c cin \u662f\u67094\u4e2a\u6761\u4ef6\u72b6\u6001\u91cf\u7684\uff1a goodbit:\u65e0\u9519\u8bef eofbit:\u5df2\u5230\u8fbe\u6587\u4ef6\u5c3e failbit:\u975e\u81f4\u547d\u7684\u8f93\u5165/\u8f93\u51fa\u9519\u8bef\uff0c\u53ef\u633d\u56de badbit:\u81f4\u547d\u7684\u8f93\u5165/\u8f93\u51fa\u9519\u8bef,\u65e0\u6cd5\u633d\u56de \u800c\u50cf\u8fd9\u79cd\u8f93\u5165\u683c\u5f0f\u4e0d\u7b26\u5408\u6d41\u8bbe\u7f6e\u7684\u683c\u5f0f\u5219\u51fa\u9519\uff0c\u5982 cin \u4e00\u4e2a int \u6570\u636e\uff0c\u4f46\u662f\u5176\u503c\u4e3a \\(2^{31}\\) =2147483648\uff0c\u4ea7\u751f\u4e0a\u6ea2\u3002 cin \u7684\u5904\u7406 \u6b64\u65f6 failbit \u5c06\u88ab\u8bbe\u7f6e\u4e3a1\uff0c\u8868\u793a\u51fa\u9519\uff0c\u4e14\u6b64\u65f6 cin \u8f93\u5165\u7684\u6570\u636e\u4ee5\u51681\u8868\u793a\u51fa\u9519\uff0c\u6b64\u5904\u5373\u4e3a \\(2^{31}-1\\) =2147483647\u3002 * scanf \u7684\u5904\u7406 \u6b64\u65f6\u8f93\u5165\u7684\u503c\u4e3a \\(-2^{31}\\) \uff0c\u5373-2147483648 `cin`\u8fd4\u56defalse\u5219\u51fa\u9519\uff0c\u53ef\u4ee5\u68c0\u6d4b\u51fa\u8fd9\u79cdfailbit\u51fa\u9519\uff0c\u5373\u7528`cin.fail()`\u3002\u82e5`failbit`\u88ab\u8bbe\u7f6e\u4e86\uff0c\u5219\u8fd4\u56de`true`\u3002\u6355\u83b7\u5230\u9519\u8bef\u540e\uff0c\u5219\u53ef\u4ee5\u901a\u8fc7`cin.clear()`\u6e05\u9664\u72b6\u6001\u6807\u5fd7\u4f4d\uff0c\u5373\u53ef\u4ee5\u633d\u56de\u3002\u6b64\u65f6\u53ef\u7ee7\u7eed\u8f93\u5165\u65b0\u7684\u503c\u5b58\u5165\u521a\u624d\u8981\u5b58\u5165\u7684\u53d8\u91cf\u4e2d\uff0c\u4e4b\u524d\u7684\u9519\u8bef\u8f93\u5165\u5219\u88ab\u4e22\u5f03\uff08\u8fd9\u4e00\u70b9\u6211\u5176\u5b9e\u6709\u5728\u67e5\u627e\u80fd\u5426\u4e0d\u4e22\u5f03\uff0c\u91cd\u65b0\u5229\u7528\uff0c\u4f46\u6ca1\u6709\u627e\u5230\u8fd9\u65b9\u9762\u4f46\u8d44\u6599\ud83d\ude43\uff09 **\u82e5\u4e0d\u6e05\u9664\u72b6\u6001\u6807\u5fd7\u4f4d\uff0c\u5219\u540e\u7eed\u4e0d\u80fd\u7ee7\u7eed\u8fdb\u884c\u8f93\u5165** \u8fd8\u6709\u4e00\u4e2a\u95ee\u9898\u662f\uff0c\u4f7f\u7528`int`\u662f\u53ef\u4ee5\u6d4b\u51fa\u8fd9\u4e2a\u5dee\u522b\u7684\uff0c\u4f46\u6b64\u9898\u662f\u7528`long long`\u578b\u7684\uff0c\u6216\u8bb8\u662f\u56e0\u4e3a\u76ee\u524d\u673a\u5668\uff08\u5305\u62ecoj\uff09\u57fa\u672c\u90fd\u662f64\u4f4d\u7684\uff0c\u6240\u4ee5\u5728\u8fd9\u91cc\u5bf9`long long`\u7684\u6ea2\u51fa\u5904\u7406`cin`\u548c`scanf`\u662f\u4e00\u6837\u7684\u3002 **\u6d4b\u8bd5\u5982\u56fe** ![\u8f93\u5165\u6570\u636e](Screen-Shot-2021-02-02-at-23.21.39.png) ![\u7ed3\u679c](Screen-Shot-2021-02-02-at-23.22.20.png) \u663e\u800c\u6613\u89c1\uff0c`cin`\u4e0e`scanf`\u7684\u5dee\u5f02\u4e4b\u5904 \u5bf9\u4e86\uff0c\u5bf9\u4e8e\u6548\u7387\u8fd9\u65b9\u9762\uff0c`cin`\u82e5\u4f7f\u7528\u4e86`cin.sync_with_stdio(false)`\u5173\u95ed\u540c\u6b65\uff0c\u5373\u53ef\u8ddf`scanf`\u6548\u7387\u5dee\u4e0d\u591a\u3002","title":"cin \u4e0e scanf \u63a2\u7a76"},{"location":"cpp/cpp/","text":"C++ Memo \u00b6 \u7a0b\u5e8f\u7684\u7f16\u8bd1\u548c\u8fd0\u884c \u00b6 \u5e38\u7528\u7684c++\u7f16\u8bd1\u5668\u662fGNU\u7f16\u8bd1\u5668\uff08\u8fd8\u6709\u5fae\u8f6f\u7684Visual Studio\u7f16\u8bd1\u5668\uff09 \u9ed8\u8ba4\u8fd0\u884cGNU\u547d\u4ee4\u662f g++ : $ g++ proc.cpp -o proc_name \u5176\u4e2d g++ \u8c03\u7528GNU\u7f16\u8bd1\u5668\uff0c proc.cpp \u662f\u6211\u4eec\u5199\u7684\u7a0b\u5e8f\u540d\uff0c -o proc_name \u662f\u7f16\u8bd1\u5668\u53c2\u6570\uff0c\u8868\u793a\u7f16\u8bd1\u751f\u6210\u7684\u53ef\u6267\u884c\u6587\u4ef6\u6587\u4ef6\u540d-- proc_name \u82e5\u4e0d\u52a0-o\u53c2\u6570\uff0c\u5219win\u4e0b\u9ed8\u8ba4\u751f\u6210 a.exe \u6587\u4ef6\uff0cunix\u4e0b\u751f\u6210 a.out \u6587\u4ef6 \u8fd0\u884c\u53ef\u6267\u884c\u6587\u4ef6 win\u4e0b\u901a\u8fc7 .\\a \u8fd0\u884c a.exe --\u540e\u7f00\u53ef\u4ee5\u7701\u7565 unix\u4e0b\u901a\u8fc7 ./a.out \u8fd0\u884c a.out \u83b7\u53d6\u7a0b\u5e8f\u8fd4\u56de\u503c \u8fd0\u884c\u540e\u901a\u8fc7 echo \u547d\u4ee4\u83b7\u53d6\u7a0b\u5e8f\u7684\u8fd4\u56de\u503c win\u4e0b\u952e\u5165 $ echo $ERRORLEVEL% unix\u4e0b\u952e\u5165 $ echo $? \u6ce8\uff1a \u547d\u4ee4\u4e2d\u7684\u7b2c\u4e00\u4e2a$\u662f\u7cfb\u7edf\u63d0\u793a\u7b26\uff0c\u4e0d\u7528\u8f93\u5165 \u58f0\u660e\u4e0e\u5b9a\u4e49\u7684\u5173\u7cfb \u00b6 \u6982\u5ff5\u4e0a\u770b \u58f0\u660e\u662f\u4f7f\u540d\u5b57\u88ab\u7a0b\u5e8f\u6240\u77e5\uff0c\u544a\u8bc9\u7a0b\u5e8f\u53c8\u4e00\u4e2a\u67d0\u79cd\u7c7b\u578b\u7684\u53d8\u91cf/\u51fd\u6570\uff0c\u89c4\u5b9a\u4e86\u53d8\u91cf\u7684\u7c7b\u578b\u548c\u540d\u5b57\uff0c\u5e76**\u4e0d\u5206\u914d\u5b58\u50a8\u7a7a\u95f4**\u3002 \u5b9a\u4e49\u662f\u8d1f\u8d23\u521b\u5efa\u4e8e\u540d\u5b57\u5173\u8054\u7684\u5b9e\u4f53\uff0c\u4e0d\u4ec5\u89c4\u5b9a\u53d8\u91cf\u7684\u7c7b\u578b\u548c\u540d\u5b57\uff0c\u8fd8\u4f1a\u7ed9\u8fd9\u4e2a\u53d8\u91cf**\u7533\u8bf7\u5b58\u50a8\u7a7a\u95f4\uff0c\u4e5f\u53ef\u80fd\u4f1a\u9ed8\u8ba4\u8d4b\u521d\u503c**\u3002 \u53d8\u91cf\u80fd\u4e14\u53ea\u80fd\u88ab\u5b9a\u4e49\u4e00\u6b21\uff0c\u4f46\u53ef\u4ee5\u88ab\u591a\u6b21\u58f0\u660e \u58f0\u660e\u4e00\u4e2a\u53d8\u91cf\u800c\u975e\u5b9a\u4e49\uff0c\u5219\u9700\u8981\u5728\u53d8\u91cf\u540d\u524d\u52a0\u5173\u952e\u5b57 extern \uff0c\u4e14\u4e0d\u8981\u663e\u793a\u521d\u59cb\u5316\uff0c\u4e00\u65e6\u521d\u59cb\u5316\u5c31\u62b5\u6d88\u4e86 extern \u7684\u4f5c\u7528\uff0c\u53d8\u6210\u4e86\u5b9a\u4e49 //\u58f0\u660e\u4e86\u6574\u578b\u53d8\u91cfi,\u4e0d\u662f\u5b9a\u4e49 extern int i; //\u58f0\u660e\u5e76\u4e14\u5b9a\u4e49\u4e86\u6574\u578b\u53d8\u91cfj,\u5206\u914d\u4e86\u5b58\u50a8\u7a7a\u95f4\uff0c\u5e76\u4e00\u822c\u9ed8\u8ba4\u8d4b\u521d\u503c int j; //\u663e\u793a\u521d\u59cb\u5316\u62b5\u6d88\u4e86extern\u7684\u4f5c\u7528\uff0c\u6b64\u4e3a\u5b9a\u4e49 extern double pi = 3.1416; \u5f15\u7528\u548c\u6307\u9488\u53caconst \u00b6 \u5f15\u7528(refers to) \uff0c\u5373\u522b\u540d\u3002\u7a0b\u5e8f\u5c06\u5f15\u7528\u548c\u5b83\u7684\u521d\u59cb\u503c\u7ed1\u5b9a\u5728\u4e00\u8d77\uff0c\u800c\u4e0d\u662f\u5c06\u521d\u59cb\u503c\u62f7\u8d1d\u7ed9\u5f15\u7528\u3002\u5f15\u7528\u4e0d\u662f\u5bf9\u8c61\uff0c\u5fc5\u987b\u521d\u59cb\u5316\u3002 \u6307\u9488(point to) \uff0c\u672c\u8eab\u662f\u4e00\u4e2a\u5bf9\u8c61\uff0c\u5141\u8bb8\u5bf9\u6307\u9488\u8d4b\u503c\u548c\u62f7\u8d1d\uff0c\u65e0\u9700\u5728\u5b9a\u4e49\u65f6\u8d4b\u521d\u503c c++\u7684\u7a7a\u6307\u9488\u5b57\u9762\u503c\u4e3a nullptr \uff0c\u5b83\u53ef\u4ee5\u8f6c\u6362\u6210\u4efb\u610f\u5176\u4ed6\u7684\u6307\u9488\u7c7b\u578b const \u9650\u5b9a\u7b26\uff0c\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cconst\u5bf9\u8c61\u4ec5\u5728\u6587\u4ef6\u5185\u6709\u6548\uff0c\u82e5\u60f3\u5728\u591a\u4e2a\u6587\u4ef6\u4e2d\u5171\u4eabconst\u5bf9\u8c61\uff0c\u5219\u9700\u8981\u5728\u5b9a\u4e49\u524d\u52a0 extern \u5173\u952e\u5b57 \u5bf9 const \u5bf9\u5f15\u7528\uff1a const type & \uff0c\u53c8\u79f0\"\u5e38\u91cf\u5f15\u7528\"\u3002 const int ci = 1024;const int &r1 = ci; // \u6b63\u786e\uff0c\u6b64\u65f6r1\u5373\u4e3aconst\u5e38\u91cfci\u7684\u5f15\u7528\uff0c\u4e0d\u53ef\u901a\u8fc7r1\u6539\u53d8ci\u7684\u503cint &r = ci; // \u51fa\u9519\uff0c\u4e0d\u80fd\u5c06\u666e\u901a\u7684\u5f15\u7528&\u7ed1\u5b9a\u5230const\u5e38\u91cf\u4e0a const\u578b\u6307\u9488 type *const \uff1a \u9876\u5c42const**\u8868\u793a\u6307\u9488/\u5bf9\u8c61\u672c\u8eab\u662f\u4e2a\u5e38\u91cf\uff0c**\u5e95\u5c42const**\u8868\u793a\u6307\u9488\u6240\u6307\u7684\u5bf9\u8c61\u662f\u4e2a\u5e38\u91cf--**\u7528\u4e8e\u58f0\u660e\u5f15\u7528\u7684const\u90fd\u662f\u5e95\u5c42const \u5e95\u5c42const\u7684\u9650\u5236\uff1a\u6267\u884c\u5bf9\u8c61\u7684\u62f7\u8d1d\u64cd\u4f5c\u65f6\uff0c\u62f7\u5165\u548c\u62f7\u51fa\u7684\u5bf9\u8c61\u5fc5\u987b\u5177\u6709\u76f8\u540c\u7684\u5e95\u5c42const\u8d44\u683c--\u6307\u5411\u7684\u662f\u4e2a\u5e38\u91cf\uff0c\u6216\u8005\u4e24\u4e2a\u5bf9\u8c61\u7684\u6570\u636e\u7c7b\u578b\u5fc5\u987b\u53ef\u4ee5\u8f6c\u6362(\u5982\uff0c\u975e\u5e38\u91cf\u53ef\u4ee5\u8f6c\u6362\u6210\u5e38\u91cf\uff0c\u53cd\u4e4b\u4e0d\u884c\uff09 \u4e00\u4e2a\u6307\u9488\u53ef\u4ee5\u540c\u65f6\u662f\u9876\u5c42const\u548c\u5e95\u5c42const\uff0c\u5982 const int *const p1 = p; // \u9760\u53f3\u7684const\u662f\u9876\u5c42const--\u81ea\u8eab\u662f\u5e38\u91cf\uff0c\u9760\u5de6\u7684\u662f\u5e95\u5c42constcont int &r = i; // r\u662f\u5e95\u5c42const c++11\u53ef\u4ee5\u901a\u8fc7\u5c06\u53d8\u91cf\u58f0\u660e\u4e3a constexpr \u7c7b\u578b\uff0c\u4f7f\u7f16\u8bd1\u5668\u81ea\u5df1\u9a8c\u8bc1\u53d8\u91cf\u662f\u5426\u4e3a\u4e00\u4e2a\u5e38\u91cf\u8868\u8fbe\u5f0f\uff08\u5b57\u9762\u503c\u4e5f\u662f\u5e38\u91cf\u8868\u8fbe\u5f0f\uff09\uff0c\u5f53\u7136\uff0c\u58f0\u660e\u65f6\u5fc5\u987b\u7528\u5e38\u91cf\u8868\u8fbe\u5f0f\u521d\u59cb\u5316\u3002\u9650\u5b9a\u7b26 constexpr \u4ec5\u5bf9\u6307\u9488/\u5bf9\u8c61\u6709\u6548\uff0c\u5bf9\u6307\u9488\u6307\u5411\u7684\u5bf9\u8c61\u65e0\u5173\uff0c\u5373\u662f**\u9876\u5c42const** \u7c7b\u578b\u522b\u540d(type alias) \u00b6 \u4f20\u7edf\u65b9\u6cd5\uff1a\u4f7f\u7528\u5173\u952e\u5b57 typedef typedef double wages; // wages\u662fdouble\u7684\u540c\u4e49\u8bcd(synonym) C++\u65b0\u6807\u51c6\uff1a\u4f7f\u7528\u5173\u952e\u5b57 using using SI = Sales_item; // SI\u662fSales_item\u7684\u540c\u4e49\u8bcd auto \uff1a\u7f16\u8bd1\u5668\u5206\u6790\u8868\u8fbe\u5f0f\u6240\u5c5e\u7684\u7c7b\u578b\uff0cauto\u5b9a\u4e49\u7684\u53d8\u91cf\u5fc5\u987b\u6709\u521d\u59cb\u503c\uff0c\u4e00\u822c\u5ffd\u7565\u9876\u5c42const decltype \uff1a\u9009\u62e9\u5e76\u8fd4\u56de\u64cd\u4f5c\u6570\u7684\u6570\u636e\u7c7b\u578b\uff0c\u53ea\u5206\u6790\u5f97\u5230\u7c7b\u578b\uff0c\u800c\u4e0d\u8ba1\u7b97\u8868\u8fbe\u5f0f\u7684\u503c decltype(f()) sum = x; // sum\u7c7b\u578b\u4e3a\u51fd\u6570f\u7684\u8fd4\u56de\u7c7b\u578b\uff0c\u5e76\u4e0d\u8c03\u7528f decltype((variable))\u7684\u7ed3\u679c\u6c38\u8fdc\u662f\u5f15\u7528\uff0c\u800cdecltype(variable)\u7ed3\u679c\u53ea\u6709\u5f53variable\u672c\u8eab\u662f\u5f15\u7528\u65f6\u624d\u662f\u5f15\u7528","title":"C++"},{"location":"cpp/cpp/#c-memo","text":"","title":"C++ Memo"},{"location":"cpp/cpp/#_1","text":"\u5e38\u7528\u7684c++\u7f16\u8bd1\u5668\u662fGNU\u7f16\u8bd1\u5668\uff08\u8fd8\u6709\u5fae\u8f6f\u7684Visual Studio\u7f16\u8bd1\u5668\uff09 \u9ed8\u8ba4\u8fd0\u884cGNU\u547d\u4ee4\u662f g++ : $ g++ proc.cpp -o proc_name \u5176\u4e2d g++ \u8c03\u7528GNU\u7f16\u8bd1\u5668\uff0c proc.cpp \u662f\u6211\u4eec\u5199\u7684\u7a0b\u5e8f\u540d\uff0c -o proc_name \u662f\u7f16\u8bd1\u5668\u53c2\u6570\uff0c\u8868\u793a\u7f16\u8bd1\u751f\u6210\u7684\u53ef\u6267\u884c\u6587\u4ef6\u6587\u4ef6\u540d-- proc_name \u82e5\u4e0d\u52a0-o\u53c2\u6570\uff0c\u5219win\u4e0b\u9ed8\u8ba4\u751f\u6210 a.exe \u6587\u4ef6\uff0cunix\u4e0b\u751f\u6210 a.out \u6587\u4ef6 \u8fd0\u884c\u53ef\u6267\u884c\u6587\u4ef6 win\u4e0b\u901a\u8fc7 .\\a \u8fd0\u884c a.exe --\u540e\u7f00\u53ef\u4ee5\u7701\u7565 unix\u4e0b\u901a\u8fc7 ./a.out \u8fd0\u884c a.out \u83b7\u53d6\u7a0b\u5e8f\u8fd4\u56de\u503c \u8fd0\u884c\u540e\u901a\u8fc7 echo \u547d\u4ee4\u83b7\u53d6\u7a0b\u5e8f\u7684\u8fd4\u56de\u503c win\u4e0b\u952e\u5165 $ echo $ERRORLEVEL% unix\u4e0b\u952e\u5165 $ echo $? \u6ce8\uff1a \u547d\u4ee4\u4e2d\u7684\u7b2c\u4e00\u4e2a$\u662f\u7cfb\u7edf\u63d0\u793a\u7b26\uff0c\u4e0d\u7528\u8f93\u5165","title":"\u7a0b\u5e8f\u7684\u7f16\u8bd1\u548c\u8fd0\u884c"},{"location":"cpp/cpp/#_2","text":"\u6982\u5ff5\u4e0a\u770b \u58f0\u660e\u662f\u4f7f\u540d\u5b57\u88ab\u7a0b\u5e8f\u6240\u77e5\uff0c\u544a\u8bc9\u7a0b\u5e8f\u53c8\u4e00\u4e2a\u67d0\u79cd\u7c7b\u578b\u7684\u53d8\u91cf/\u51fd\u6570\uff0c\u89c4\u5b9a\u4e86\u53d8\u91cf\u7684\u7c7b\u578b\u548c\u540d\u5b57\uff0c\u5e76**\u4e0d\u5206\u914d\u5b58\u50a8\u7a7a\u95f4**\u3002 \u5b9a\u4e49\u662f\u8d1f\u8d23\u521b\u5efa\u4e8e\u540d\u5b57\u5173\u8054\u7684\u5b9e\u4f53\uff0c\u4e0d\u4ec5\u89c4\u5b9a\u53d8\u91cf\u7684\u7c7b\u578b\u548c\u540d\u5b57\uff0c\u8fd8\u4f1a\u7ed9\u8fd9\u4e2a\u53d8\u91cf**\u7533\u8bf7\u5b58\u50a8\u7a7a\u95f4\uff0c\u4e5f\u53ef\u80fd\u4f1a\u9ed8\u8ba4\u8d4b\u521d\u503c**\u3002 \u53d8\u91cf\u80fd\u4e14\u53ea\u80fd\u88ab\u5b9a\u4e49\u4e00\u6b21\uff0c\u4f46\u53ef\u4ee5\u88ab\u591a\u6b21\u58f0\u660e \u58f0\u660e\u4e00\u4e2a\u53d8\u91cf\u800c\u975e\u5b9a\u4e49\uff0c\u5219\u9700\u8981\u5728\u53d8\u91cf\u540d\u524d\u52a0\u5173\u952e\u5b57 extern \uff0c\u4e14\u4e0d\u8981\u663e\u793a\u521d\u59cb\u5316\uff0c\u4e00\u65e6\u521d\u59cb\u5316\u5c31\u62b5\u6d88\u4e86 extern \u7684\u4f5c\u7528\uff0c\u53d8\u6210\u4e86\u5b9a\u4e49 //\u58f0\u660e\u4e86\u6574\u578b\u53d8\u91cfi,\u4e0d\u662f\u5b9a\u4e49 extern int i; //\u58f0\u660e\u5e76\u4e14\u5b9a\u4e49\u4e86\u6574\u578b\u53d8\u91cfj,\u5206\u914d\u4e86\u5b58\u50a8\u7a7a\u95f4\uff0c\u5e76\u4e00\u822c\u9ed8\u8ba4\u8d4b\u521d\u503c int j; //\u663e\u793a\u521d\u59cb\u5316\u62b5\u6d88\u4e86extern\u7684\u4f5c\u7528\uff0c\u6b64\u4e3a\u5b9a\u4e49 extern double pi = 3.1416;","title":"\u58f0\u660e\u4e0e\u5b9a\u4e49\u7684\u5173\u7cfb"},{"location":"cpp/cpp/#const","text":"\u5f15\u7528(refers to) \uff0c\u5373\u522b\u540d\u3002\u7a0b\u5e8f\u5c06\u5f15\u7528\u548c\u5b83\u7684\u521d\u59cb\u503c\u7ed1\u5b9a\u5728\u4e00\u8d77\uff0c\u800c\u4e0d\u662f\u5c06\u521d\u59cb\u503c\u62f7\u8d1d\u7ed9\u5f15\u7528\u3002\u5f15\u7528\u4e0d\u662f\u5bf9\u8c61\uff0c\u5fc5\u987b\u521d\u59cb\u5316\u3002 \u6307\u9488(point to) \uff0c\u672c\u8eab\u662f\u4e00\u4e2a\u5bf9\u8c61\uff0c\u5141\u8bb8\u5bf9\u6307\u9488\u8d4b\u503c\u548c\u62f7\u8d1d\uff0c\u65e0\u9700\u5728\u5b9a\u4e49\u65f6\u8d4b\u521d\u503c c++\u7684\u7a7a\u6307\u9488\u5b57\u9762\u503c\u4e3a nullptr \uff0c\u5b83\u53ef\u4ee5\u8f6c\u6362\u6210\u4efb\u610f\u5176\u4ed6\u7684\u6307\u9488\u7c7b\u578b const \u9650\u5b9a\u7b26\uff0c\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cconst\u5bf9\u8c61\u4ec5\u5728\u6587\u4ef6\u5185\u6709\u6548\uff0c\u82e5\u60f3\u5728\u591a\u4e2a\u6587\u4ef6\u4e2d\u5171\u4eabconst\u5bf9\u8c61\uff0c\u5219\u9700\u8981\u5728\u5b9a\u4e49\u524d\u52a0 extern \u5173\u952e\u5b57 \u5bf9 const \u5bf9\u5f15\u7528\uff1a const type & \uff0c\u53c8\u79f0\"\u5e38\u91cf\u5f15\u7528\"\u3002 const int ci = 1024;const int &r1 = ci; // \u6b63\u786e\uff0c\u6b64\u65f6r1\u5373\u4e3aconst\u5e38\u91cfci\u7684\u5f15\u7528\uff0c\u4e0d\u53ef\u901a\u8fc7r1\u6539\u53d8ci\u7684\u503cint &r = ci; // \u51fa\u9519\uff0c\u4e0d\u80fd\u5c06\u666e\u901a\u7684\u5f15\u7528&\u7ed1\u5b9a\u5230const\u5e38\u91cf\u4e0a const\u578b\u6307\u9488 type *const \uff1a \u9876\u5c42const**\u8868\u793a\u6307\u9488/\u5bf9\u8c61\u672c\u8eab\u662f\u4e2a\u5e38\u91cf\uff0c**\u5e95\u5c42const**\u8868\u793a\u6307\u9488\u6240\u6307\u7684\u5bf9\u8c61\u662f\u4e2a\u5e38\u91cf--**\u7528\u4e8e\u58f0\u660e\u5f15\u7528\u7684const\u90fd\u662f\u5e95\u5c42const \u5e95\u5c42const\u7684\u9650\u5236\uff1a\u6267\u884c\u5bf9\u8c61\u7684\u62f7\u8d1d\u64cd\u4f5c\u65f6\uff0c\u62f7\u5165\u548c\u62f7\u51fa\u7684\u5bf9\u8c61\u5fc5\u987b\u5177\u6709\u76f8\u540c\u7684\u5e95\u5c42const\u8d44\u683c--\u6307\u5411\u7684\u662f\u4e2a\u5e38\u91cf\uff0c\u6216\u8005\u4e24\u4e2a\u5bf9\u8c61\u7684\u6570\u636e\u7c7b\u578b\u5fc5\u987b\u53ef\u4ee5\u8f6c\u6362(\u5982\uff0c\u975e\u5e38\u91cf\u53ef\u4ee5\u8f6c\u6362\u6210\u5e38\u91cf\uff0c\u53cd\u4e4b\u4e0d\u884c\uff09 \u4e00\u4e2a\u6307\u9488\u53ef\u4ee5\u540c\u65f6\u662f\u9876\u5c42const\u548c\u5e95\u5c42const\uff0c\u5982 const int *const p1 = p; // \u9760\u53f3\u7684const\u662f\u9876\u5c42const--\u81ea\u8eab\u662f\u5e38\u91cf\uff0c\u9760\u5de6\u7684\u662f\u5e95\u5c42constcont int &r = i; // r\u662f\u5e95\u5c42const c++11\u53ef\u4ee5\u901a\u8fc7\u5c06\u53d8\u91cf\u58f0\u660e\u4e3a constexpr \u7c7b\u578b\uff0c\u4f7f\u7f16\u8bd1\u5668\u81ea\u5df1\u9a8c\u8bc1\u53d8\u91cf\u662f\u5426\u4e3a\u4e00\u4e2a\u5e38\u91cf\u8868\u8fbe\u5f0f\uff08\u5b57\u9762\u503c\u4e5f\u662f\u5e38\u91cf\u8868\u8fbe\u5f0f\uff09\uff0c\u5f53\u7136\uff0c\u58f0\u660e\u65f6\u5fc5\u987b\u7528\u5e38\u91cf\u8868\u8fbe\u5f0f\u521d\u59cb\u5316\u3002\u9650\u5b9a\u7b26 constexpr \u4ec5\u5bf9\u6307\u9488/\u5bf9\u8c61\u6709\u6548\uff0c\u5bf9\u6307\u9488\u6307\u5411\u7684\u5bf9\u8c61\u65e0\u5173\uff0c\u5373\u662f**\u9876\u5c42const**","title":"\u5f15\u7528\u548c\u6307\u9488\u53caconst"},{"location":"cpp/cpp/#type-alias","text":"\u4f20\u7edf\u65b9\u6cd5\uff1a\u4f7f\u7528\u5173\u952e\u5b57 typedef typedef double wages; // wages\u662fdouble\u7684\u540c\u4e49\u8bcd(synonym) C++\u65b0\u6807\u51c6\uff1a\u4f7f\u7528\u5173\u952e\u5b57 using using SI = Sales_item; // SI\u662fSales_item\u7684\u540c\u4e49\u8bcd auto \uff1a\u7f16\u8bd1\u5668\u5206\u6790\u8868\u8fbe\u5f0f\u6240\u5c5e\u7684\u7c7b\u578b\uff0cauto\u5b9a\u4e49\u7684\u53d8\u91cf\u5fc5\u987b\u6709\u521d\u59cb\u503c\uff0c\u4e00\u822c\u5ffd\u7565\u9876\u5c42const decltype \uff1a\u9009\u62e9\u5e76\u8fd4\u56de\u64cd\u4f5c\u6570\u7684\u6570\u636e\u7c7b\u578b\uff0c\u53ea\u5206\u6790\u5f97\u5230\u7c7b\u578b\uff0c\u800c\u4e0d\u8ba1\u7b97\u8868\u8fbe\u5f0f\u7684\u503c decltype(f()) sum = x; // sum\u7c7b\u578b\u4e3a\u51fd\u6570f\u7684\u8fd4\u56de\u7c7b\u578b\uff0c\u5e76\u4e0d\u8c03\u7528f decltype((variable))\u7684\u7ed3\u679c\u6c38\u8fdc\u662f\u5f15\u7528\uff0c\u800cdecltype(variable)\u7ed3\u679c\u53ea\u6709\u5f53variable\u672c\u8eab\u662f\u5f15\u7528\u65f6\u624d\u662f\u5f15\u7528","title":"\u7c7b\u578b\u522b\u540d(type alias)"},{"location":"pat/ab-and-c-64bit/","text":"A+B and C (64bit) \u00b6 \u9898\u76ee\u94fe\u63a5 1065 A+B and C (64bit) (20 \u5206) \u4e0d\u80fd\u7528cin\u7684\u539f\u56e0 \u00b6 \u94fe\u63a5\uff1a [C++]--PAT-A1065 & cin\u4e0escanf \u9898\u5e72\u5927\u610f \u00b6 \u7ed9\u51fa\u4e09\u4e2a64\u4f4d\u7684\u6574\u6570\uff0cA,B,C\uff0c\u5224\u65ad \\(A+B>C\\) \u662f\u5426\u6210\u7acb \u601d\u8def \u00b6 \u4f7f\u7528 long long \u5b58\u50a8\uff0c\u8fdb\u884c\u5224\u65ad\u8ba1\u7b97\u5373\u53ef\u3002 \u95ee\u9898 \u00b6 \u6b64\u9898\u7528 cin \u6700\u540e\u4e00\u4e2a\u6d4b\u8bd5\u6837\u4f8b\u8fc7\u4e0d\u4e86\uff0c\u53ea\u80fd\u7528 scanf \u5177\u4f53\u5206\u6790\u89c1 [C++]--PAT-A1065 & cin\u4e0escanf AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <iostream> #include <cstdio> using namespace std ; int main () { int T ; cin >> T ; for ( auto k = 0 ; k != T ; ++ k ) { long long a , b , c ; //cin >> a >> b >> c; scanf ( \"%lld%lld%lld\" , & a , & b , & c ); auto res = a + b ; bool flag ; if ( a > 0 && b > 0 && res < 0 ) flag = true ; else if ( a < 0 && b < 0 && res >= 0 ) flag = false ; else if ( res > c ) flag = true ; else flag = false ; if ( flag ) cout << \"Case #\" << k + 1 << \": true\" << endl ; else cout << \"Case #\" << k + 1 << \": false\" << endl ; } return 0 ; }","title":"A1065"},{"location":"pat/ab-and-c-64bit/#ab-and-c-64bit","text":"\u9898\u76ee\u94fe\u63a5 1065 A+B and C (64bit) (20 \u5206)","title":"A+B and C (64bit)"},{"location":"pat/ab-and-c-64bit/#cin","text":"\u94fe\u63a5\uff1a [C++]--PAT-A1065 & cin\u4e0escanf","title":"\u4e0d\u80fd\u7528cin\u7684\u539f\u56e0"},{"location":"pat/ab-and-c-64bit/#_1","text":"\u7ed9\u51fa\u4e09\u4e2a64\u4f4d\u7684\u6574\u6570\uff0cA,B,C\uff0c\u5224\u65ad \\(A+B>C\\) \u662f\u5426\u6210\u7acb","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/ab-and-c-64bit/#_2","text":"\u4f7f\u7528 long long \u5b58\u50a8\uff0c\u8fdb\u884c\u5224\u65ad\u8ba1\u7b97\u5373\u53ef\u3002","title":"\u601d\u8def"},{"location":"pat/ab-and-c-64bit/#_3","text":"\u6b64\u9898\u7528 cin \u6700\u540e\u4e00\u4e2a\u6d4b\u8bd5\u6837\u4f8b\u8fc7\u4e0d\u4e86\uff0c\u53ea\u80fd\u7528 scanf \u5177\u4f53\u5206\u6790\u89c1 [C++]--PAT-A1065 & cin\u4e0escanf","title":"\u95ee\u9898"},{"location":"pat/ab-and-c-64bit/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <iostream> #include <cstdio> using namespace std ; int main () { int T ; cin >> T ; for ( auto k = 0 ; k != T ; ++ k ) { long long a , b , c ; //cin >> a >> b >> c; scanf ( \"%lld%lld%lld\" , & a , & b , & c ); auto res = a + b ; bool flag ; if ( a > 0 && b > 0 && res < 0 ) flag = true ; else if ( a < 0 && b < 0 && res >= 0 ) flag = false ; else if ( res > c ) flag = true ; else flag = false ; if ( flag ) cout << \"Case #\" << k + 1 << \": true\" << endl ; else cout << \"Case #\" << k + 1 << \": false\" << endl ; } return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/ab-for-polynomials/","text":"A+B for Polynomials \u00b6 \u9898\u76ee\u94fe\u63a5 1002 A+B for Polynomials (25 \u5206) \u9898\u5e72\u5927\u610f \u00b6 \u8ba1\u7b97\u591a\u9879\u5f0f\u7684\u52a0\u6cd5\uff0c\u8981\u6c42\u8f93\u51fa\u9879\u6570\u4ee5\u53ca\u5404\u9879\u7684\u6307\u6570\u3001\u7cfb\u6570 \u601d\u8def \u00b6 \u4e0d\u96be\uff0c\u6211\u5229\u7528\u4e86\u5f52\u5e76\u7684\u601d\u60f3\u53bb\u505a\uff0c\u5916\u52a0\u5168\u90e8\u4f7f\u7528 c++ \u7684\u65b9\u5f0f\u7f16\u5199\uff0c\u9700\u8981\u6ce8\u610f\u7684\u51e0\u4e2a\u70b9 \u76f8\u52a0\u7cfb\u6570\u4e3a0\u7684\u9879\u4e0d\u80fd\u8f93\u51fa \u5f52\u5e76(\u5047)\uff0c\u82e5A\u548cB\u90fd\u904d\u5386\u5b8c\u4e86\u4e5f\u8981\u8f93\u51fa\u7ed3\u679c\uff0c\u8fd9\u4e2a\u6211\u6700\u521d\u5fd8\u8bb0\u4e86 cout\u7684\u683c\u5f0f\u5316\u8f93\u51fa\u7ed3\u679c\uff0c\u8981\u786e\u4fdd\u8f93\u51fa\u7684\u7cfb\u6570\u4fdd\u7559\u4e00\u4f4d\u5c0f\u6570 \u8f93\u51fan\u4f4d\u5c0f\u6570\u7684\u63a7\u5236\u4ee3\u7801\uff1a #include <iomanip>//\u9700\u8981\u7684\u5934\u6587\u4ef6 using namespace std; cout << setiosflags(ios::fixed) << setprecision(n); //\u540e\u9762cout\u8f93\u51fa\u7684\u6570\u5c31\u4fdd\u7559\u4e86n\u4f4d\u5c0f\u6570 AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include <iostream> #include <vector> #include <iomanip> using namespace std ; //\u6839\u636e\u8f93\u5165\u7684\u9879\u6570\uff0c\u63a5\u53d7\u8f93\u5165 void input ( vector < int > & index , vector < double > & value , const int k ) { int a ; double b ; for ( auto i = 0 ; i < k ; ++ i ) { cin >> a >> b ; index . push_back ( a ); value . push_back ( b ); } } int main () { int k1 , k2 ; vector < int > a_index , b_index ; vector < double > a_value , b_value ; cin >> k1 ; input ( a_index , a_value , k1 ); cin >> k2 ; input ( b_index , b_value , k2 ); vector < int > index ; vector < double > value ; //A\u548cB\u7684\u8fed\u4ee3\u5668\uff0c\u8bbe\u5728for\u5916\uff0c\u540e\u7eed\u8981\u7528\u5230 auto it1 = a_index . begin (), it2 = b_index . begin (); for (; it1 != a_index . end () && it2 != b_index . end ();) { //\u9009\u53d6\u6307\u6570\u5927\u7684\u5b58\u5165\u7ed3\u679c\u5411\u91cfindex\u548cvalue\u4e2d if ( * it1 > * it2 ) { index . push_back ( * it1 ); value . push_back ( a_value [ it1 - a_index . begin ()]); ++ it1 ; } else if ( * it1 < * it2 ) { index . push_back ( * it2 ); value . push_back ( b_value [ it2 - b_index . begin ()]); ++ it2 ; } else { // \u76f8\u7b49\u65f6\u8fd8\u8981\u5224\u65ad\u548c\u662f\u5426\u4e3a0\uff0c\u82e5\u4e3a0\u5219\u4e0d\u52a0\u5165\u7ed3\u679c\u5411\u91cf\u4e2d if ( a_value [ it1 - a_index . begin ()] + b_value [ it2 - b_index . begin ()]){ index . push_back ( * it1 ); value . push_back ( a_value [ it1 - a_index . begin ()] + b_value [ it2 - b_index . begin ()]); } ++ it1 ; ++ it2 ; } } // \u9000\u51fafor\u5faa\u73af\u76843\u79cd\u60c5\u51b5\uff0c\u90fd\u8981\u8003\u8651\u5230 // cout\u8f93\u51fan\u4f4d\u5c0f\u6570\u65b9\u6cd5\uff0c\u5148\u8bbe\u7f6efixed\u5728\u8bbe\u7f6e\u7cbe\u5ea6 if ( it1 != a_index . end ()) { cout << index . size () + a_index . end () - it1 ; for ( auto it = index . begin (); it != index . end (); ++ it ) cout << \" \" << * it << \" \" << setiosflags ( ios :: fixed ) << setprecision ( 1 ) << value [ it - index . begin ()]; for (; it1 != a_index . end (); ++ it1 ) cout << \" \" << * it1 << \" \" << setiosflags ( ios :: fixed ) << setprecision ( 1 ) << a_value [ it1 - a_index . begin ()]; } else if ( it2 != b_index . end ()) { cout << index . size () + b_index . end () - it2 ; for ( auto it = index . begin (); it != index . end (); ++ it ) cout << \" \" << * it << \" \" << setiosflags ( ios :: fixed ) << setprecision ( 1 ) << value [ it - index . begin ()]; for (; it2 != b_index . end (); ++ it2 ) cout << \" \" << * it2 << \" \" << setiosflags ( ios :: fixed ) << setprecision ( 1 ) << b_value [ it2 - b_index . begin ()]; } else { cout << index . size (); for ( auto it = index . begin (); it != index . end (); ++ it ) cout << \" \" << * it << \" \" << setiosflags ( ios :: fixed ) << setprecision ( 1 ) << value [ it - index . begin ()]; } return 0 ; }","title":"A1002"},{"location":"pat/ab-for-polynomials/#ab-for-polynomials","text":"\u9898\u76ee\u94fe\u63a5 1002 A+B for Polynomials (25 \u5206)","title":"A+B for Polynomials"},{"location":"pat/ab-for-polynomials/#_1","text":"\u8ba1\u7b97\u591a\u9879\u5f0f\u7684\u52a0\u6cd5\uff0c\u8981\u6c42\u8f93\u51fa\u9879\u6570\u4ee5\u53ca\u5404\u9879\u7684\u6307\u6570\u3001\u7cfb\u6570","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/ab-for-polynomials/#_2","text":"\u4e0d\u96be\uff0c\u6211\u5229\u7528\u4e86\u5f52\u5e76\u7684\u601d\u60f3\u53bb\u505a\uff0c\u5916\u52a0\u5168\u90e8\u4f7f\u7528 c++ \u7684\u65b9\u5f0f\u7f16\u5199\uff0c\u9700\u8981\u6ce8\u610f\u7684\u51e0\u4e2a\u70b9 \u76f8\u52a0\u7cfb\u6570\u4e3a0\u7684\u9879\u4e0d\u80fd\u8f93\u51fa \u5f52\u5e76(\u5047)\uff0c\u82e5A\u548cB\u90fd\u904d\u5386\u5b8c\u4e86\u4e5f\u8981\u8f93\u51fa\u7ed3\u679c\uff0c\u8fd9\u4e2a\u6211\u6700\u521d\u5fd8\u8bb0\u4e86 cout\u7684\u683c\u5f0f\u5316\u8f93\u51fa\u7ed3\u679c\uff0c\u8981\u786e\u4fdd\u8f93\u51fa\u7684\u7cfb\u6570\u4fdd\u7559\u4e00\u4f4d\u5c0f\u6570 \u8f93\u51fan\u4f4d\u5c0f\u6570\u7684\u63a7\u5236\u4ee3\u7801\uff1a #include <iomanip>//\u9700\u8981\u7684\u5934\u6587\u4ef6 using namespace std; cout << setiosflags(ios::fixed) << setprecision(n); //\u540e\u9762cout\u8f93\u51fa\u7684\u6570\u5c31\u4fdd\u7559\u4e86n\u4f4d\u5c0f\u6570","title":"\u601d\u8def"},{"location":"pat/ab-for-polynomials/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include <iostream> #include <vector> #include <iomanip> using namespace std ; //\u6839\u636e\u8f93\u5165\u7684\u9879\u6570\uff0c\u63a5\u53d7\u8f93\u5165 void input ( vector < int > & index , vector < double > & value , const int k ) { int a ; double b ; for ( auto i = 0 ; i < k ; ++ i ) { cin >> a >> b ; index . push_back ( a ); value . push_back ( b ); } } int main () { int k1 , k2 ; vector < int > a_index , b_index ; vector < double > a_value , b_value ; cin >> k1 ; input ( a_index , a_value , k1 ); cin >> k2 ; input ( b_index , b_value , k2 ); vector < int > index ; vector < double > value ; //A\u548cB\u7684\u8fed\u4ee3\u5668\uff0c\u8bbe\u5728for\u5916\uff0c\u540e\u7eed\u8981\u7528\u5230 auto it1 = a_index . begin (), it2 = b_index . begin (); for (; it1 != a_index . end () && it2 != b_index . end ();) { //\u9009\u53d6\u6307\u6570\u5927\u7684\u5b58\u5165\u7ed3\u679c\u5411\u91cfindex\u548cvalue\u4e2d if ( * it1 > * it2 ) { index . push_back ( * it1 ); value . push_back ( a_value [ it1 - a_index . begin ()]); ++ it1 ; } else if ( * it1 < * it2 ) { index . push_back ( * it2 ); value . push_back ( b_value [ it2 - b_index . begin ()]); ++ it2 ; } else { // \u76f8\u7b49\u65f6\u8fd8\u8981\u5224\u65ad\u548c\u662f\u5426\u4e3a0\uff0c\u82e5\u4e3a0\u5219\u4e0d\u52a0\u5165\u7ed3\u679c\u5411\u91cf\u4e2d if ( a_value [ it1 - a_index . begin ()] + b_value [ it2 - b_index . begin ()]){ index . push_back ( * it1 ); value . push_back ( a_value [ it1 - a_index . begin ()] + b_value [ it2 - b_index . begin ()]); } ++ it1 ; ++ it2 ; } } // \u9000\u51fafor\u5faa\u73af\u76843\u79cd\u60c5\u51b5\uff0c\u90fd\u8981\u8003\u8651\u5230 // cout\u8f93\u51fan\u4f4d\u5c0f\u6570\u65b9\u6cd5\uff0c\u5148\u8bbe\u7f6efixed\u5728\u8bbe\u7f6e\u7cbe\u5ea6 if ( it1 != a_index . end ()) { cout << index . size () + a_index . end () - it1 ; for ( auto it = index . begin (); it != index . end (); ++ it ) cout << \" \" << * it << \" \" << setiosflags ( ios :: fixed ) << setprecision ( 1 ) << value [ it - index . begin ()]; for (; it1 != a_index . end (); ++ it1 ) cout << \" \" << * it1 << \" \" << setiosflags ( ios :: fixed ) << setprecision ( 1 ) << a_value [ it1 - a_index . begin ()]; } else if ( it2 != b_index . end ()) { cout << index . size () + b_index . end () - it2 ; for ( auto it = index . begin (); it != index . end (); ++ it ) cout << \" \" << * it << \" \" << setiosflags ( ios :: fixed ) << setprecision ( 1 ) << value [ it - index . begin ()]; for (; it2 != b_index . end (); ++ it2 ) cout << \" \" << * it2 << \" \" << setiosflags ( ios :: fixed ) << setprecision ( 1 ) << b_value [ it2 - b_index . begin ()]; } else { cout << index . size (); for ( auto it = index . begin (); it != index . end (); ++ it ) cout << \" \" << * it << \" \" << setiosflags ( ios :: fixed ) << setprecision ( 1 ) << value [ it - index . begin ()]; } return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/ab-format/","text":"AB-Format \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1001 A+B Format (20 point(s)) \u9898\u5e72\u5927\u610f \u00b6 \u5c06 a+b \u7684\u503c\u6309\u7167\u7f8e\u5f0f\uff1f\u7684\u683c\u5f0f\u8f93\u51fa \u601d\u8def \u00b6 \u521a\u5f00\u59cb\u6253\u7b97\u7528\u6c42\u4f59\u8fd0\u7b97\u505a\u7684\uff0c\u8349\u7387\u4e86\uff0c\u6ca1\u6709\u8003\u8651\u5230\u4e3a0\u65f6\u5e94\u8be5\u8f93\u51fa\u8fde\u7eed\u76840\uff0c\u53ea\u62ff\u4e8615\u5206\u3002\u7136\u540e\u8003\u8651\u5230\u6309\u7167\u5b57\u7b26\u4e32\u5904\u7406\uff0c\u7528 to_string \u51fd\u6570\uff0c\u5373\u53ef\uff0c\u9664\u4e86\u6700\u524d\u9762\u7684\uff0c\u5176\u4ed6\u6309\u71673\u4e2a\u4e00\u8f93\u51fa\u5373\u53ef\u3002 AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <iostream> using namespace std ; int main () { int a , b ; cin >> a >> b ; int sum = a + b ; if ( sum < 0 ) { cout << \"-\" ; sum = - sum ; } string ans = to_string ( sum ); int m = ans . length () % 3 ; for ( auto i = 0 ; i < ans . length (); ++ i ) { cout << ans [ i ]; if (( i - m + 1 ) % 3 == 0 && i != ans . length () - 1 ) cout << ',' ; } return 0 ; }","title":"A1001"},{"location":"pat/ab-format/#ab-format","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1001 A+B Format (20 point(s))","title":"AB-Format"},{"location":"pat/ab-format/#_1","text":"\u5c06 a+b \u7684\u503c\u6309\u7167\u7f8e\u5f0f\uff1f\u7684\u683c\u5f0f\u8f93\u51fa","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/ab-format/#_2","text":"\u521a\u5f00\u59cb\u6253\u7b97\u7528\u6c42\u4f59\u8fd0\u7b97\u505a\u7684\uff0c\u8349\u7387\u4e86\uff0c\u6ca1\u6709\u8003\u8651\u5230\u4e3a0\u65f6\u5e94\u8be5\u8f93\u51fa\u8fde\u7eed\u76840\uff0c\u53ea\u62ff\u4e8615\u5206\u3002\u7136\u540e\u8003\u8651\u5230\u6309\u7167\u5b57\u7b26\u4e32\u5904\u7406\uff0c\u7528 to_string \u51fd\u6570\uff0c\u5373\u53ef\uff0c\u9664\u4e86\u6700\u524d\u9762\u7684\uff0c\u5176\u4ed6\u6309\u71673\u4e2a\u4e00\u8f93\u51fa\u5373\u53ef\u3002","title":"\u601d\u8def"},{"location":"pat/ab-format/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <iostream> using namespace std ; int main () { int a , b ; cin >> a >> b ; int sum = a + b ; if ( sum < 0 ) { cout << \"-\" ; sum = - sum ; } string ans = to_string ( sum ); int m = ans . length () % 3 ; for ( auto i = 0 ; i < ans . length (); ++ i ) { cout << ans [ i ]; if (( i - m + 1 ) % 3 == 0 && i != ans . length () - 1 ) cout << ',' ; } return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/acute-stroke/","text":"Acute Stroke \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1091 Acute Stroke (30 point(s) \u9898\u5e72\u5927\u610f \u00b6 \u7406\u89e3\u9898\u610f\u5f88\u91cd\u8981\uff0c\u8fd9\u4e2a\u9898\u521a\u5f00\u59cb\u6211\u6ca1\u6709\u8bfb\u61c2\uff0c\u611f\u89c9\u8868\u8ff0\u7684\u4e0d\u6e05\u695a\uff0c\u77e5\u9053\u5f53\u6211\u7406\u89e3\u4e86 L \u8868\u793a\u7684\u662f layer \u7684\u65f6\u5019\uff0c\u624d\u7ec8\u4e8e\u7406\u89e3\u9898\u76ee\u7ed9\u7684\u662f\u4e00\u4e2a\u5e95\u786e\u5b9a\u7684\u957f\u65b9\u4f53\u533a\u57df\uff0c\u800c\u4e0d\u662f\u6574\u4e2a\u4e09\u7ef4\u7a7a\u95f4\uff08\u5982\u679c\u662f\uff0c\u4e00\u76f4\u4e0d\u77e5\u9053\u600e\u4e48\u786e\u5b9a\u6bcf\u4e2a\u5207\u7247\u5728xoy\u5e73\u9762\u7684\u8054\u7cfb\uff09 \u601d\u8def \u00b6 \u7406\u89e3\u4e86\u9898\u610f\u4e4b\u540e\uff0c\u5c31\u77e5\u9053\u8fd9\u4e2a\u9898\u53ef\u4ee5\u91c7\u7528 BFS \u904d\u5386\u6bcf\u4e2a\u8fde\u901a\u57df\uff0c\u5e76\u5c06\u6bcf\u4e2a\u8fde\u901a\u57df\u4e2d1\u7684\u4e2a\u6570\u5927\u4e8e\u7b49\u4e8e T \u7684\u4e2a\u6570\u8bb0\u4e0b\u6765\uff0c\u6700\u540e\u8f93\u51fa\u5373\u53ef AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #include <iostream> #include <queue> using namespace std ; const int MaxM = 1287 , MaxN = 129 , MaxL = 61 ; int pixel [ MaxM ][ MaxN ][ MaxL ]; bool status [ MaxM ][ MaxN ][ MaxL ]{ false }; int M , N , L , T ; // \u6ce8\u610f\u662fL\u5c42\uff0c\u6bcf\u5c42\u662fM*N\uff0c\u95e8\u69db\u662fT class Point { public : int x , y , z ; Point ( int a , int b , int c ) : x ( a ), y ( b ), z ( c ) {} ~ Point () = default ; Point operator + ( Point add ) const { return Point { x + add . x , y + add . y , z + add . z }; } bool check () const { if ( x >= M '' x < 0 '' y >= N '' y < 0 '' z >= L '' z < 0 ) return false ; // \u8d8a\u754c\u8fd4\u56defalse if ( pixel [ x ][ y ][ z ] == 0 '' status [ x ][ y ][ z ]) return false ; // \u5f53\u524d\u975e\u80bf\u5757\u70b9\uff0c\u6216\u5df2\u7ecf\u88ab\u8bbf\u95ee\u8fc7\uff0c\u8fd4\u56defalse return true ; } }; const Point adj [ 6 ] = { // \u4e00\u4e2a\u70b9\u7684\u516d\u4e2a\u76f8\u90bb\u70b9\u7684\u79fb\u52a8\u65b9\u5411 //NOLINT Point { 0 , 0 , 1 }, Point { 0 , 0 , -1 }, Point { 1 , 0 , 0 }, Point { -1 , 0 , 0 }, Point { 0 , 1 , 0 }, Point { 0 , -1 , 0 } }; int BFS ( int x , int y , int z ) { int cur = 0 ; // \u6b64\u6b21bfs\u4e2d\u7684\u7b26\u5408\u7684\u70b9\u7684\u4e2a\u6570 queue < Point > q ; Point point { x , y , z }; q . push ( point ); status [ x ][ y ][ z ] = true ; while ( ! q . empty ()) { Point top = q . front (); ++ cur ; q . pop (); for ( auto i : adj ) { point = top + i ; if ( point . check ()) { // \u7ecf\u68c0\u6d4b\uff0c\u65b0\u4f4d\u7f6e\u7b26\u5408\u8981\u6c42 q . push ( point ); // \u5165\u961f status [ point . x ][ point . y ][ point . z ] = true ; // \u5e76\u8bbe\u7f6e\u5df2\u7ecf\u68c0\u6d4b\u8fc7 } } } if ( cur >= T ) return cur ; else return 0 ; } int main () { cin >> M >> N >> L >> T ; for ( int z = 0 ; z < L ; ++ z ) { for ( int x = 0 ; x < M ; ++ x ) { for ( int y = 0 ; y < N ; ++ y ) cin >> pixel [ x ][ y ][ z ]; } } int ans = 0 ; for ( int z = 0 ; z < L ; ++ z ) { for ( int x = 0 ; x < M ; ++ x ) { for ( int y = 0 ; y < N ; ++ y ) // \u5f53\u524d\u4f4d\u7f6e\u4e3a1\uff0c\u4e14\u6ca1\u88ab\u8bbf\u95ee\u8fc7\uff0c\u5219\u4ece\u5f53\u524d\u70b9\u5f00\u59cbBFS if ( pixel [ x ][ y ][ z ] == 1 && ! status [ x ][ y ][ z ]) ans += BFS ( x , y , z ); } } cout << ans ; return 0 ; }","title":"A1091"},{"location":"pat/acute-stroke/#acute-stroke","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1091 Acute Stroke (30 point(s)","title":"Acute Stroke"},{"location":"pat/acute-stroke/#_1","text":"\u7406\u89e3\u9898\u610f\u5f88\u91cd\u8981\uff0c\u8fd9\u4e2a\u9898\u521a\u5f00\u59cb\u6211\u6ca1\u6709\u8bfb\u61c2\uff0c\u611f\u89c9\u8868\u8ff0\u7684\u4e0d\u6e05\u695a\uff0c\u77e5\u9053\u5f53\u6211\u7406\u89e3\u4e86 L \u8868\u793a\u7684\u662f layer \u7684\u65f6\u5019\uff0c\u624d\u7ec8\u4e8e\u7406\u89e3\u9898\u76ee\u7ed9\u7684\u662f\u4e00\u4e2a\u5e95\u786e\u5b9a\u7684\u957f\u65b9\u4f53\u533a\u57df\uff0c\u800c\u4e0d\u662f\u6574\u4e2a\u4e09\u7ef4\u7a7a\u95f4\uff08\u5982\u679c\u662f\uff0c\u4e00\u76f4\u4e0d\u77e5\u9053\u600e\u4e48\u786e\u5b9a\u6bcf\u4e2a\u5207\u7247\u5728xoy\u5e73\u9762\u7684\u8054\u7cfb\uff09","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/acute-stroke/#_2","text":"\u7406\u89e3\u4e86\u9898\u610f\u4e4b\u540e\uff0c\u5c31\u77e5\u9053\u8fd9\u4e2a\u9898\u53ef\u4ee5\u91c7\u7528 BFS \u904d\u5386\u6bcf\u4e2a\u8fde\u901a\u57df\uff0c\u5e76\u5c06\u6bcf\u4e2a\u8fde\u901a\u57df\u4e2d1\u7684\u4e2a\u6570\u5927\u4e8e\u7b49\u4e8e T \u7684\u4e2a\u6570\u8bb0\u4e0b\u6765\uff0c\u6700\u540e\u8f93\u51fa\u5373\u53ef","title":"\u601d\u8def"},{"location":"pat/acute-stroke/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #include <iostream> #include <queue> using namespace std ; const int MaxM = 1287 , MaxN = 129 , MaxL = 61 ; int pixel [ MaxM ][ MaxN ][ MaxL ]; bool status [ MaxM ][ MaxN ][ MaxL ]{ false }; int M , N , L , T ; // \u6ce8\u610f\u662fL\u5c42\uff0c\u6bcf\u5c42\u662fM*N\uff0c\u95e8\u69db\u662fT class Point { public : int x , y , z ; Point ( int a , int b , int c ) : x ( a ), y ( b ), z ( c ) {} ~ Point () = default ; Point operator + ( Point add ) const { return Point { x + add . x , y + add . y , z + add . z }; } bool check () const { if ( x >= M '' x < 0 '' y >= N '' y < 0 '' z >= L '' z < 0 ) return false ; // \u8d8a\u754c\u8fd4\u56defalse if ( pixel [ x ][ y ][ z ] == 0 '' status [ x ][ y ][ z ]) return false ; // \u5f53\u524d\u975e\u80bf\u5757\u70b9\uff0c\u6216\u5df2\u7ecf\u88ab\u8bbf\u95ee\u8fc7\uff0c\u8fd4\u56defalse return true ; } }; const Point adj [ 6 ] = { // \u4e00\u4e2a\u70b9\u7684\u516d\u4e2a\u76f8\u90bb\u70b9\u7684\u79fb\u52a8\u65b9\u5411 //NOLINT Point { 0 , 0 , 1 }, Point { 0 , 0 , -1 }, Point { 1 , 0 , 0 }, Point { -1 , 0 , 0 }, Point { 0 , 1 , 0 }, Point { 0 , -1 , 0 } }; int BFS ( int x , int y , int z ) { int cur = 0 ; // \u6b64\u6b21bfs\u4e2d\u7684\u7b26\u5408\u7684\u70b9\u7684\u4e2a\u6570 queue < Point > q ; Point point { x , y , z }; q . push ( point ); status [ x ][ y ][ z ] = true ; while ( ! q . empty ()) { Point top = q . front (); ++ cur ; q . pop (); for ( auto i : adj ) { point = top + i ; if ( point . check ()) { // \u7ecf\u68c0\u6d4b\uff0c\u65b0\u4f4d\u7f6e\u7b26\u5408\u8981\u6c42 q . push ( point ); // \u5165\u961f status [ point . x ][ point . y ][ point . z ] = true ; // \u5e76\u8bbe\u7f6e\u5df2\u7ecf\u68c0\u6d4b\u8fc7 } } } if ( cur >= T ) return cur ; else return 0 ; } int main () { cin >> M >> N >> L >> T ; for ( int z = 0 ; z < L ; ++ z ) { for ( int x = 0 ; x < M ; ++ x ) { for ( int y = 0 ; y < N ; ++ y ) cin >> pixel [ x ][ y ][ z ]; } } int ans = 0 ; for ( int z = 0 ; z < L ; ++ z ) { for ( int x = 0 ; x < M ; ++ x ) { for ( int y = 0 ; y < N ; ++ y ) // \u5f53\u524d\u4f4d\u7f6e\u4e3a1\uff0c\u4e14\u6ca1\u88ab\u8bbf\u95ee\u8fc7\uff0c\u5219\u4ece\u5f53\u524d\u70b9\u5f00\u59cbBFS if ( pixel [ x ][ y ][ z ] == 1 && ! status [ x ][ y ][ z ]) ans += BFS ( x , y , z ); } } cout << ans ; return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/are-they-equal/","text":"Are They Equal \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1060 Are They Equal (25 point(s)) \u9898\u5e72\u5927\u610f \u00b6 \u7ed9\u5b9a\u7cbe\u5ea6\uff0c\u5224\u65ad\u4e24\u4e2a\u5b58\u50a8\u6d6e\u70b9\u6570\u7684\u5b57\u7b26\u4e32\u662f\u5426\u79d1\u5b66\u8868\u8fbe\u5f0f\u76f8\u7b49 \u601d\u8def \u00b6 \u53c2\u8003\u4e86\u300a\u7b97\u6cd5\u7b14\u8bb0\u300b,\u505a\u7684\u65f6\u5019\u7531\u4e8e\u836f\u7269\uff0c\u8111\u5b50\u6655\u6655\u7684\uff0c\u4e0d\u80fd\u52a8\u8111\u5206\u6790\u60c5\u51b5\uff0c\u5c31\u76f4\u63a5\u770b\u4e66\u4e86\u3002 \u6839\u636e\u4e66\u4e2d\u5206\u6790\uff0c\u8981\u5c06\u5b57\u7b26\u4e32\u4e2d\u4fdd\u5b58\u7684\u5206\u4e3a\u5927\u4e8e1\u548c\u5c0f\u4e8e1\u4e24\u79cd\uff0c\u603b\u4f53\u4e0a\u662f\u4e00\u4e2a\u4e00\u4e2a\u5224\u65ad\uff0c\u7136\u540e\u5220\u9664\u524d\u5bfc\u96f6\u548c\u5c0f\u6570\u70b9\uff0c\u7531\u4e8e erase \u7684\u590d\u6742\u5ea6\u4e3a O(n) \uff0c\u6240\u4ee5\u6211\u91c7\u53d6\u4e86\u4e0d\u5220\u9664\u7684\u505a\u6cd5\uff0c\u5b9e\u5219\u662f\u6bcf\u4e2a\u5b57\u7b26\u4e32\u6700\u591a\u5220\u9664\u4e00\u6b21\uff08\u5373\u5220\u9664\u5c0f\u6570\u70b9\uff09\uff0c\u8fd0\u884c\u901f\u5ea6\u66f4\u5feb\u3002 AC\u4ee3\u7801 \u00b6 #include <iostream> #include <string> using namespace std ; int n ; bool isZero ( string & s ) { bool zero = true ; for ( auto & c : s ) { if ( c != '0' ) { zero = false ; break ; } } return zero ; } void process ( string & s , int & e ) { int k = 0 ; // \u8bb0\u5f55\u7b2c\u4e00\u4e2a\u4e0d\u4e3a0\u7684\u6570\u5b57\u7684\u4e0b\u6807 while ( s . length () > k && s [ k ] == '0' ) // \u8df3\u8fc7\u524d\u5bfc\u96f6 ++ k ; // \u53bb\u9664\u5c0f\u6570\u70b9\uff08\u5982\u679c\u6709\uff09 if ( s [ k ] == '.' ) { // s\u4e3a\u5c0f\u4e8e1\u7684\u5c0f\u6570 s . erase ( s . begin () + k ); while ( s . length () > k && s [ k ] == '0' ) { // \u53bb\u6389\u5c0f\u6570\u70b9\u540e\u9762\u7684\u524d\u5bfc\u96f6 ++ k ; -- e ; // \u6bcf\u53bb\u6389\u4e00\u4e2a\u6307\u6570\u51cf\u4e00 } } else { // s\u5927\u4e8e1\uff0c\u5219\u6b64\u65f6k\u5df2\u7ecf\u786e\u5b9a\u4e86 while ( k + e < s . length () && s [ k + e ] != '.' ) // \u5bfb\u627e\u5c0f\u6570\u70b9 ++ e ; // e \u662f\u6307\u6570\uff0c\u4e5f\u8868\u793a\u5c0f\u6570\u70b9\u79bb\u7b2c\u4e00\u4e2a\u4e0d\u4e3a\u96f6\u7684\u6570\u7684\u8ddd\u79bb if ( k + e < s . length ()) // \u627e\u5230\u5c0f\u6570\u70b9\uff0c\u5220\u9664 s . erase ( s . begin () + k + e ); } if ( isZero ( s )) // \u5224\u65ad\u662f\u5426\u4e3a0 e = 0 ; while ( s . length () - k < n ) // \u5982\u679c\u6709\u5fc5\u8981\uff0c\u8865\u5145\u7cbe\u5ea6 s += '0' ; s = s . substr ( k , n ); // \u53d6n\u4e2a\u5b57\u7b26\u7ec4\u6210\u5904\u7406\u540e\u7684\u7ed3\u679c } int main () { string s1 , s2 ; cin >> n >> s1 >> s2 ; int e1 = 0 , e2 = 0 ; // \u5904\u7406\u8f93\u5165\u7684\u5b57\u7b26\u4e32\uff0c\u53bb\u6389\u5c0f\u6570\u70b9\uff08\u5982\u679c\u6709\uff09\uff0c\u5e76\u8ba1\u7b97\u6307\u6570e // \u5373\u6700\u591a\u4ec5\u6267\u884c\u4e00\u6b21erase process ( s1 , e1 ); process ( s2 , e2 ); if ( s1 == s2 && e1 == e2 ) cout << \"YES 0.\" << s1 << \"*10^\" << e1 << endl ; else cout << \"NO 0.\" << s1 << \"*10^\" << e1 << \" 0.\" << s2 << \"*10^\" << e2 << endl ; return 0 ; }","title":"Are They Equal"},{"location":"pat/are-they-equal/#are-they-equal","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1060 Are They Equal (25 point(s))","title":"Are They Equal"},{"location":"pat/are-they-equal/#_1","text":"\u7ed9\u5b9a\u7cbe\u5ea6\uff0c\u5224\u65ad\u4e24\u4e2a\u5b58\u50a8\u6d6e\u70b9\u6570\u7684\u5b57\u7b26\u4e32\u662f\u5426\u79d1\u5b66\u8868\u8fbe\u5f0f\u76f8\u7b49","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/are-they-equal/#_2","text":"\u53c2\u8003\u4e86\u300a\u7b97\u6cd5\u7b14\u8bb0\u300b,\u505a\u7684\u65f6\u5019\u7531\u4e8e\u836f\u7269\uff0c\u8111\u5b50\u6655\u6655\u7684\uff0c\u4e0d\u80fd\u52a8\u8111\u5206\u6790\u60c5\u51b5\uff0c\u5c31\u76f4\u63a5\u770b\u4e66\u4e86\u3002 \u6839\u636e\u4e66\u4e2d\u5206\u6790\uff0c\u8981\u5c06\u5b57\u7b26\u4e32\u4e2d\u4fdd\u5b58\u7684\u5206\u4e3a\u5927\u4e8e1\u548c\u5c0f\u4e8e1\u4e24\u79cd\uff0c\u603b\u4f53\u4e0a\u662f\u4e00\u4e2a\u4e00\u4e2a\u5224\u65ad\uff0c\u7136\u540e\u5220\u9664\u524d\u5bfc\u96f6\u548c\u5c0f\u6570\u70b9\uff0c\u7531\u4e8e erase \u7684\u590d\u6742\u5ea6\u4e3a O(n) \uff0c\u6240\u4ee5\u6211\u91c7\u53d6\u4e86\u4e0d\u5220\u9664\u7684\u505a\u6cd5\uff0c\u5b9e\u5219\u662f\u6bcf\u4e2a\u5b57\u7b26\u4e32\u6700\u591a\u5220\u9664\u4e00\u6b21\uff08\u5373\u5220\u9664\u5c0f\u6570\u70b9\uff09\uff0c\u8fd0\u884c\u901f\u5ea6\u66f4\u5feb\u3002","title":"\u601d\u8def"},{"location":"pat/are-they-equal/#ac","text":"#include <iostream> #include <string> using namespace std ; int n ; bool isZero ( string & s ) { bool zero = true ; for ( auto & c : s ) { if ( c != '0' ) { zero = false ; break ; } } return zero ; } void process ( string & s , int & e ) { int k = 0 ; // \u8bb0\u5f55\u7b2c\u4e00\u4e2a\u4e0d\u4e3a0\u7684\u6570\u5b57\u7684\u4e0b\u6807 while ( s . length () > k && s [ k ] == '0' ) // \u8df3\u8fc7\u524d\u5bfc\u96f6 ++ k ; // \u53bb\u9664\u5c0f\u6570\u70b9\uff08\u5982\u679c\u6709\uff09 if ( s [ k ] == '.' ) { // s\u4e3a\u5c0f\u4e8e1\u7684\u5c0f\u6570 s . erase ( s . begin () + k ); while ( s . length () > k && s [ k ] == '0' ) { // \u53bb\u6389\u5c0f\u6570\u70b9\u540e\u9762\u7684\u524d\u5bfc\u96f6 ++ k ; -- e ; // \u6bcf\u53bb\u6389\u4e00\u4e2a\u6307\u6570\u51cf\u4e00 } } else { // s\u5927\u4e8e1\uff0c\u5219\u6b64\u65f6k\u5df2\u7ecf\u786e\u5b9a\u4e86 while ( k + e < s . length () && s [ k + e ] != '.' ) // \u5bfb\u627e\u5c0f\u6570\u70b9 ++ e ; // e \u662f\u6307\u6570\uff0c\u4e5f\u8868\u793a\u5c0f\u6570\u70b9\u79bb\u7b2c\u4e00\u4e2a\u4e0d\u4e3a\u96f6\u7684\u6570\u7684\u8ddd\u79bb if ( k + e < s . length ()) // \u627e\u5230\u5c0f\u6570\u70b9\uff0c\u5220\u9664 s . erase ( s . begin () + k + e ); } if ( isZero ( s )) // \u5224\u65ad\u662f\u5426\u4e3a0 e = 0 ; while ( s . length () - k < n ) // \u5982\u679c\u6709\u5fc5\u8981\uff0c\u8865\u5145\u7cbe\u5ea6 s += '0' ; s = s . substr ( k , n ); // \u53d6n\u4e2a\u5b57\u7b26\u7ec4\u6210\u5904\u7406\u540e\u7684\u7ed3\u679c } int main () { string s1 , s2 ; cin >> n >> s1 >> s2 ; int e1 = 0 , e2 = 0 ; // \u5904\u7406\u8f93\u5165\u7684\u5b57\u7b26\u4e32\uff0c\u53bb\u6389\u5c0f\u6570\u70b9\uff08\u5982\u679c\u6709\uff09\uff0c\u5e76\u8ba1\u7b97\u6307\u6570e // \u5373\u6700\u591a\u4ec5\u6267\u884c\u4e00\u6b21erase process ( s1 , e1 ); process ( s2 , e2 ); if ( s1 == s2 && e1 == e2 ) cout << \"YES 0.\" << s1 << \"*10^\" << e1 << endl ; else cout << \"NO 0.\" << s1 << \"*10^\" << e1 << \" 0.\" << s2 << \"*10^\" << e2 << endl ; return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/boys-vs-girls/","text":"Boys vs Girls \u00b6 \u9898\u76ee\u94fe\u63a5 1036 Boys vs Girls (25 \u5206) \u9898\u5e72\u5927\u610f \u00b6 \u4ecd\u662f\u5728\u8f93\u5165\u4e2d\u5904\u7406\u6570\u636e\uff0c\u627e\u6700\u5927\uff0c\u6700\u5c0f\uff0c\u53ea\u4e0d\u8fc7\u8fd9\u91cc\u5c06\u6570\u636e\u5206\u6210\u4e86\u4e24\u7c7b\uff0c\u7537\u6027\u548c\u5973\u6027 \u601d\u8def \u00b6 \u5e38\u89c4\uff0c\u6ce8\u610f\u5224\u65ad\u662f\u5426\u5b58\u5728\u6700\u503c\u4fee\u6539\u8f93\u51fa\u683c\u5f0f AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <iostream> using namespace std ; struct Student { string name ; string id ; int score ; } male , female , temp ; int main () { male . score = 101 , female . score = -1 ; int n ; char gender ; cin >> n ; while ( n -- ) { cin >> temp . name >> gender >> temp . id >> temp . score ; if ( gender == 'M' && temp . score < male . score ) swap ( male , temp ); else if ( gender == 'F' && temp . score > female . score ) swap ( female , temp ); } if ( female . score == -1 ) cout << \"Absent\" << endl ; else cout << female . name << \" \" << female . id << endl ; if ( male . score == 101 ) cout << \"Absent\" << endl ; else cout << male . name << \" \" << male . id << endl ; if ( female . score == -1 '' male . score == 101 ) cout << \"NA\" << endl ; else cout << female . score - male . score ; return 0 ; }","title":"A1036"},{"location":"pat/boys-vs-girls/#boys-vs-girls","text":"\u9898\u76ee\u94fe\u63a5 1036 Boys vs Girls (25 \u5206)","title":"Boys vs Girls"},{"location":"pat/boys-vs-girls/#_1","text":"\u4ecd\u662f\u5728\u8f93\u5165\u4e2d\u5904\u7406\u6570\u636e\uff0c\u627e\u6700\u5927\uff0c\u6700\u5c0f\uff0c\u53ea\u4e0d\u8fc7\u8fd9\u91cc\u5c06\u6570\u636e\u5206\u6210\u4e86\u4e24\u7c7b\uff0c\u7537\u6027\u548c\u5973\u6027","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/boys-vs-girls/#_2","text":"\u5e38\u89c4\uff0c\u6ce8\u610f\u5224\u65ad\u662f\u5426\u5b58\u5728\u6700\u503c\u4fee\u6539\u8f93\u51fa\u683c\u5f0f","title":"\u601d\u8def"},{"location":"pat/boys-vs-girls/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <iostream> using namespace std ; struct Student { string name ; string id ; int score ; } male , female , temp ; int main () { male . score = 101 , female . score = -1 ; int n ; char gender ; cin >> n ; while ( n -- ) { cin >> temp . name >> gender >> temp . id >> temp . score ; if ( gender == 'M' && temp . score < male . score ) swap ( male , temp ); else if ( gender == 'F' && temp . score > female . score ) swap ( female , temp ); } if ( female . score == -1 ) cout << \"Absent\" << endl ; else cout << female . name << \" \" << female . id << endl ; if ( male . score == 101 ) cout << \"Absent\" << endl ; else cout << male . name << \" \" << male . id << endl ; if ( female . score == -1 '' male . score == 101 ) cout << \"NA\" << endl ; else cout << female . score - male . score ; return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/counting-leaves/","text":"Counting Leaves \u00b6 \u9898\u76ee\u94fe\u63a5 1004 Counting Leaves (30 \u5206) \u9898\u5e72\u5927\u610f \u00b6 \u8f93\u51fa\u6811\u7684\u53f6\u8282\u70b9\u4e2a\u6570\u3002 \u601d\u8def \u00b6 \u7528BFS\u4e5f\u5c31\u662f\u5c42\u5e8f\u904d\u5386 \u95ee\u9898 \u00b6 \u4e00\u4e9b\u8fed\u4ee3\u5668\u3001\u7d22\u5f15\u7684\u95ee\u9898\uff0c\u8fd8\u662f\u5199\u6ce8\u91ca\u8981\u597d\uff0c\u601d\u8def\u6e05\u6670\uff0c\u4e0d\u4f1a\u4e71 AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include <iostream> #include <vector> #include <queue> using namespace std ; int traverse ( vector < vector < int >> nodes , vector < int >& cnt ) { queue < int > Q ; Q . push ( 1 ); int layer = 1 ; vector < int > num ; num . push_back ( nodes [ 1 ]. size ()); while ( ! Q . empty ()) { int size = int ( num . size ()); auto p = Q . front (); for ( int i = 0 ; i < size ; ++ i ) { // num.size()\u4e3a\u5b69\u5b50\u4e2a\u6570 if ( nodes [ p ]. empty ()) ++ cnt [ layer ]; ++ p ; } num . clear (); for ( int i = 0 ; i < size ; ++ i ) { auto q = Q . front (); Q . pop (); if ( ! nodes [ q ]. empty ()) { for ( auto it = nodes [ q ]. begin (); it != nodes [ q ]. end (); ++ it ) { Q . push ( * it ); num . push_back ( nodes [ * it ]. size ()); } } } ++ layer ; } return -- layer ; } int main () { int N , M ; cin >> N >> M ; vector < vector < int >> nodes ( N + 1 ); for ( int i = 0 ; i != M ; ++ i ) { int parent , K , child ; cin >> parent >> K ; for ( int j = 0 ; j < K ; ++ j ) { cin >> child ; nodes [ parent ]. push_back ( child ); } } vector < int > cnt ( N + 1 , 0 ); auto layer = traverse ( nodes , cnt ); for ( auto i = 1 ; i <= layer ; ++ i ) { cout << cnt [ i ]; if ( i != layer ) cout << \" \" ; } return 0 ; }","title":"A1004"},{"location":"pat/counting-leaves/#counting-leaves","text":"\u9898\u76ee\u94fe\u63a5 1004 Counting Leaves (30 \u5206)","title":"Counting Leaves"},{"location":"pat/counting-leaves/#_1","text":"\u8f93\u51fa\u6811\u7684\u53f6\u8282\u70b9\u4e2a\u6570\u3002","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/counting-leaves/#_2","text":"\u7528BFS\u4e5f\u5c31\u662f\u5c42\u5e8f\u904d\u5386","title":"\u601d\u8def"},{"location":"pat/counting-leaves/#_3","text":"\u4e00\u4e9b\u8fed\u4ee3\u5668\u3001\u7d22\u5f15\u7684\u95ee\u9898\uff0c\u8fd8\u662f\u5199\u6ce8\u91ca\u8981\u597d\uff0c\u601d\u8def\u6e05\u6670\uff0c\u4e0d\u4f1a\u4e71","title":"\u95ee\u9898"},{"location":"pat/counting-leaves/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include <iostream> #include <vector> #include <queue> using namespace std ; int traverse ( vector < vector < int >> nodes , vector < int >& cnt ) { queue < int > Q ; Q . push ( 1 ); int layer = 1 ; vector < int > num ; num . push_back ( nodes [ 1 ]. size ()); while ( ! Q . empty ()) { int size = int ( num . size ()); auto p = Q . front (); for ( int i = 0 ; i < size ; ++ i ) { // num.size()\u4e3a\u5b69\u5b50\u4e2a\u6570 if ( nodes [ p ]. empty ()) ++ cnt [ layer ]; ++ p ; } num . clear (); for ( int i = 0 ; i < size ; ++ i ) { auto q = Q . front (); Q . pop (); if ( ! nodes [ q ]. empty ()) { for ( auto it = nodes [ q ]. begin (); it != nodes [ q ]. end (); ++ it ) { Q . push ( * it ); num . push_back ( nodes [ * it ]. size ()); } } } ++ layer ; } return -- layer ; } int main () { int N , M ; cin >> N >> M ; vector < vector < int >> nodes ( N + 1 ); for ( int i = 0 ; i != M ; ++ i ) { int parent , K , child ; cin >> parent >> K ; for ( int j = 0 ; j < K ; ++ j ) { cin >> child ; nodes [ parent ]. push_back ( child ); } } vector < int > cnt ( N + 1 , 0 ); auto layer = traverse ( nodes , cnt ); for ( auto i = 1 ; i <= layer ; ++ i ) { cout << cnt [ i ]; if ( i != layer ) cout << \" \" ; } return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/course-list-for-student/","text":"Course List for Student \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1039 Course List for Student (25 point(s)) \u9898\u5e72\u5927\u610f \u00b6 \u7ed9\u5b9a\u8bfe\u7a0b\u5bf9\u5e94\u7684\u9009\u8bfe\u5b66\u751f\uff0c\u7136\u540e\u7ed9\u4f60\u5b66\u751f\u540d\u5b57\u67e5\u8be2\u8be5\u5b66\u751f\u9009\u7684\u8bfe\u7a0b\u4fe1\u606f\u3002 \u601d\u8def \u00b6 \u4f7f\u7528 map \uff0c\u7531\u4e8e unordered_map \u6548\u7387\u66f4\u9ad8\uff0c\u4f7f\u7528\u4e4b\u5efa\u7acb\u5b66\u751f\u540d\u5b57\u4e0e\u5b58\u50a8\u7684\u4e0b\u6807\u7684\u5bf9\u5e94\u5173\u7cfb\u3002 \u5728 codeup \u4e2d\u63d0\u4ea4\u7684\u8bdd\u4f1a\u8d85\u65f6\uff0c\u89e3\u51b3\u529e\u6cd5\u662f\u5c06\u53bb\u6389 map \u3001\u53bb\u6389 cin \u6539\u4e3a scanf \u3001\u53bb\u6389 cout \u6539\u4e3a printf \u4ee5\u53ca\u5c06 string \u6539\u4e3a char \u6570\u7ec4\u3002 AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include <iostream> #include <unordered_map> #include <algorithm> #include <vector> using namespace std ; int main () { int N , K ; cin >> N >> K ; vector < vector < int >> stu ; unordered_map < string , int > map ; int k = 0 ; for ( int i = 0 ; i < K ; ++ i ) { int id , num ; cin >> id >> num ; for ( int j = 0 ; j < num ; ++ j ) { string name ; cin >> name ; if ( map . find ( name ) == map . end ()) { map [ name ] = k ++ ; stu . emplace_back (); } stu [ map [ name ]]. emplace_back ( id ); } } for ( int i = 0 ; i < N ; ++ i ) { string name ; cin >> name ; cout << name << \" \" << (( map . find ( name ) == map . end ()) ? 0 : stu [ map [ name ]]. size ()); if ( map . find ( name ) == map . end ()) { if ( i != N - 1 ) cout << endl ; continue ; } sort ( stu [ map [ name ]]. begin (), stu [ map [ name ]]. end ()); for ( auto & entry : stu [ map [ name ]]) cout << \" \" << entry ; if ( i != N - 1 ) cout << endl ; } return 0 ; }","title":"A1039"},{"location":"pat/course-list-for-student/#course-list-for-student","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1039 Course List for Student (25 point(s))","title":"Course List for Student"},{"location":"pat/course-list-for-student/#_1","text":"\u7ed9\u5b9a\u8bfe\u7a0b\u5bf9\u5e94\u7684\u9009\u8bfe\u5b66\u751f\uff0c\u7136\u540e\u7ed9\u4f60\u5b66\u751f\u540d\u5b57\u67e5\u8be2\u8be5\u5b66\u751f\u9009\u7684\u8bfe\u7a0b\u4fe1\u606f\u3002","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/course-list-for-student/#_2","text":"\u4f7f\u7528 map \uff0c\u7531\u4e8e unordered_map \u6548\u7387\u66f4\u9ad8\uff0c\u4f7f\u7528\u4e4b\u5efa\u7acb\u5b66\u751f\u540d\u5b57\u4e0e\u5b58\u50a8\u7684\u4e0b\u6807\u7684\u5bf9\u5e94\u5173\u7cfb\u3002 \u5728 codeup \u4e2d\u63d0\u4ea4\u7684\u8bdd\u4f1a\u8d85\u65f6\uff0c\u89e3\u51b3\u529e\u6cd5\u662f\u5c06\u53bb\u6389 map \u3001\u53bb\u6389 cin \u6539\u4e3a scanf \u3001\u53bb\u6389 cout \u6539\u4e3a printf \u4ee5\u53ca\u5c06 string \u6539\u4e3a char \u6570\u7ec4\u3002","title":"\u601d\u8def"},{"location":"pat/course-list-for-student/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include <iostream> #include <unordered_map> #include <algorithm> #include <vector> using namespace std ; int main () { int N , K ; cin >> N >> K ; vector < vector < int >> stu ; unordered_map < string , int > map ; int k = 0 ; for ( int i = 0 ; i < K ; ++ i ) { int id , num ; cin >> id >> num ; for ( int j = 0 ; j < num ; ++ j ) { string name ; cin >> name ; if ( map . find ( name ) == map . end ()) { map [ name ] = k ++ ; stu . emplace_back (); } stu [ map [ name ]]. emplace_back ( id ); } } for ( int i = 0 ; i < N ; ++ i ) { string name ; cin >> name ; cout << name << \" \" << (( map . find ( name ) == map . end ()) ? 0 : stu [ map [ name ]]. size ()); if ( map . find ( name ) == map . end ()) { if ( i != N - 1 ) cout << endl ; continue ; } sort ( stu [ map [ name ]]. begin (), stu [ map [ name ]]. end ()); for ( auto & entry : stu [ map [ name ]]) cout << \" \" << entry ; if ( i != N - 1 ) cout << endl ; } return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/dating/","text":"Dating \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1061 Dating (20 point(s)) \u9898\u5e72\u5927\u610f \u00b6 \u524d\u4e24\u4e2a\u5b57\u7b26\u4e32\u7b2c\u4e00\u4e2a\u76f8\u540c\u7684\u8868\u793a\u661f\u671f\uff0c\u7b2c\u4e8c\u4e2a\u76f8\u540c\u7684\u8868\u793a\u5c0f\u65f6\uff0c\u540e\u4e24\u4e2a\u5b57\u7b26\u4e32\u7b2c\u4e00\u4e2a\u76f8\u540c\u7684\u4f4d\u7f6e\u8868\u793a\u5206\u949f \u601d\u8def \u00b6 \u904d\u5386\uff0c\u627e\u7b26\u5408\u8981\u6c42\u7684\u5b57\u7b26\u5373\u53ef AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include <iostream> #include <vector> #include <string> using namespace std ; const vector < string > week { \"MON\" , \"TUE\" , \"WED\" , \"THU\" , \"FRI\" , \"SAT\" , \"SUN\" }; //\u7528\u4e8e\u8f6c\u6362\u661f\u671f int main () { string str1 , str2 , str3 , str4 ; cin >> str1 >> str2 >> str3 >> str4 ; int k ; for ( k = 0 ; k < str1 . length () && k < str2 . length (); ++ k ) { // \u627e\u661f\u671f if ( str1 [ k ] == str2 [ k ] && str1 [ k ] >= 'A' && str1 [ k ] <= 'G' ) { cout << week [ str1 [ k ] - 'A' ] << \" \" ; break ; } } for ( k ++ ; k < str1 . length () && k < str2 . length (); ++ k ) { // \u63a5\u7740\u627e\u5c0f\u65f6 if ( str1 [ k ] == str2 [ k ]) { if ( str1 [ k ] >= '0' && str1 [ k ] <= '9' ) { cout << 0 << str1 [ k ] - '0' << \":\" ; break ; } else if ( str1 [ k ] >= 'A' && str1 [ k ] <= 'N' ) { cout << str1 [ k ] - 'A' + 10 << \":\" ; break ; } } } for ( k = 0 ; k < str3 . length () && k < str4 . length (); ++ k ) { // \u627e\u5206\u949f if ( str3 [ k ] == str4 [ k ]){ if ( str3 [ k ] >= 'A' && str3 [ k ] <= 'Z' '' str3 [ k ] >= 'a' && str3 [ k ] <= 'z' ) { k > 9 ? cout << k : cout << 0 << k ; break ; } } } return 0 ; }","title":"A1061"},{"location":"pat/dating/#dating","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1061 Dating (20 point(s))","title":"Dating"},{"location":"pat/dating/#_1","text":"\u524d\u4e24\u4e2a\u5b57\u7b26\u4e32\u7b2c\u4e00\u4e2a\u76f8\u540c\u7684\u8868\u793a\u661f\u671f\uff0c\u7b2c\u4e8c\u4e2a\u76f8\u540c\u7684\u8868\u793a\u5c0f\u65f6\uff0c\u540e\u4e24\u4e2a\u5b57\u7b26\u4e32\u7b2c\u4e00\u4e2a\u76f8\u540c\u7684\u4f4d\u7f6e\u8868\u793a\u5206\u949f","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/dating/#_2","text":"\u904d\u5386\uff0c\u627e\u7b26\u5408\u8981\u6c42\u7684\u5b57\u7b26\u5373\u53ef","title":"\u601d\u8def"},{"location":"pat/dating/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include <iostream> #include <vector> #include <string> using namespace std ; const vector < string > week { \"MON\" , \"TUE\" , \"WED\" , \"THU\" , \"FRI\" , \"SAT\" , \"SUN\" }; //\u7528\u4e8e\u8f6c\u6362\u661f\u671f int main () { string str1 , str2 , str3 , str4 ; cin >> str1 >> str2 >> str3 >> str4 ; int k ; for ( k = 0 ; k < str1 . length () && k < str2 . length (); ++ k ) { // \u627e\u661f\u671f if ( str1 [ k ] == str2 [ k ] && str1 [ k ] >= 'A' && str1 [ k ] <= 'G' ) { cout << week [ str1 [ k ] - 'A' ] << \" \" ; break ; } } for ( k ++ ; k < str1 . length () && k < str2 . length (); ++ k ) { // \u63a5\u7740\u627e\u5c0f\u65f6 if ( str1 [ k ] == str2 [ k ]) { if ( str1 [ k ] >= '0' && str1 [ k ] <= '9' ) { cout << 0 << str1 [ k ] - '0' << \":\" ; break ; } else if ( str1 [ k ] >= 'A' && str1 [ k ] <= 'N' ) { cout << str1 [ k ] - 'A' + 10 << \":\" ; break ; } } } for ( k = 0 ; k < str3 . length () && k < str4 . length (); ++ k ) { // \u627e\u5206\u949f if ( str3 [ k ] == str4 [ k ]){ if ( str3 [ k ] >= 'A' && str3 [ k ] <= 'Z' '' str3 [ k ] >= 'a' && str3 [ k ] <= 'z' ) { k > 9 ? cout << k : cout << 0 << k ; break ; } } } return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/deduplication-on-a-linked-list/","text":"Deduplication on a Linked List \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1097 Deduplication on a Linked List (25 point(s)) \u9898\u5e72\u5927\u610f \u00b6 \u94fe\u8868\u7684\u53bb\u91cd\uff0c\u7edd\u5bf9\u503c\u76f8\u540c\u5373\u4e3a\u91cd\u590d \u601d\u8def \u00b6 \u8bbe\u4e24\u4e2a\u7ed3\u679c\u94fe\u8868\uff0c\u5206\u522b\u5b58\u50a8\uff0c\u6ce8\u610f\u91cd\u590d\u7684\u94fe\u8868\u4e0d\u4e00\u5b9a\u5b58\u5728\uff0c\u8981\u5148\u5224\u65ad\u662f\u5426\u4e3a\u7a7a\u624d\u80fd\u8f93\u51fa AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include <iostream> #include <vector> #include <iomanip> #include <algorithm> using namespace std ; const int MaxN = 1e6 + 10 ; const int MaxK = 1e4 + 10 ; struct node { int data {}; int next {}; } l [ MaxN ]; int status [ MaxK ]{ 0 }; int main () { int N , first ; vector < int > res1 , res2 ; cin >> first >> N ; int address ; for ( int i = 0 ; i < N ; ++ i ) { cin >> address >> l [ address ]. data >> l [ address ]. next ; } while ( first != -1 ) { if ( status [ abs ( l [ first ]. data )] == 0 ) { res1 . emplace_back ( first ); status [ abs ( l [ first ]. data )] = 1 ; // \u6807\u8bb0\u6b64\u6570\u7684\u7edd\u5bf9\u503c\u5df2\u7ecf\u51fa\u73b0 } else res2 . emplace_back ( first ); first = l [ first ]. next ; } for ( int i = 0 ; i != res1 . size () - 1 ; ++ i ) cout << setw ( 5 ) << setfill ( '0' ) << res1 [ i ] << \" \" << l [ res1 [ i ]]. data << \" \" << setw ( 5 ) << setfill ( '0' ) << res1 [ i + 1 ] << \" \\n \" ; cout << setw ( 5 ) << setfill ( '0' ) << res1 [ res1 . size () - 1 ] << \" \" << l [ res1 [ res1 . size () - 1 ]]. data << \" \" << -1 << \" \\n \" ; if ( ! res2 . empty ()){ for ( int i = 0 ; i != res2 . size () - 1 ; ++ i ) cout << setw ( 5 ) << setfill ( '0' ) << res2 [ i ] << \" \" << l [ res2 [ i ]]. data << \" \" << setw ( 5 ) << setfill ( '0' ) << res2 [ i + 1 ] << \" \\n \" ; cout << setw ( 5 ) << setfill ( '0' ) << res2 [ res2 . size () - 1 ] << \" \" << l [ res2 [ res2 . size () - 1 ]]. data << \" \" << -1 ; } return 0 ; }","title":"A1097"},{"location":"pat/deduplication-on-a-linked-list/#deduplication-on-a-linked-list","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1097 Deduplication on a Linked List (25 point(s))","title":"Deduplication on a Linked List"},{"location":"pat/deduplication-on-a-linked-list/#_1","text":"\u94fe\u8868\u7684\u53bb\u91cd\uff0c\u7edd\u5bf9\u503c\u76f8\u540c\u5373\u4e3a\u91cd\u590d","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/deduplication-on-a-linked-list/#_2","text":"\u8bbe\u4e24\u4e2a\u7ed3\u679c\u94fe\u8868\uff0c\u5206\u522b\u5b58\u50a8\uff0c\u6ce8\u610f\u91cd\u590d\u7684\u94fe\u8868\u4e0d\u4e00\u5b9a\u5b58\u5728\uff0c\u8981\u5148\u5224\u65ad\u662f\u5426\u4e3a\u7a7a\u624d\u80fd\u8f93\u51fa","title":"\u601d\u8def"},{"location":"pat/deduplication-on-a-linked-list/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include <iostream> #include <vector> #include <iomanip> #include <algorithm> using namespace std ; const int MaxN = 1e6 + 10 ; const int MaxK = 1e4 + 10 ; struct node { int data {}; int next {}; } l [ MaxN ]; int status [ MaxK ]{ 0 }; int main () { int N , first ; vector < int > res1 , res2 ; cin >> first >> N ; int address ; for ( int i = 0 ; i < N ; ++ i ) { cin >> address >> l [ address ]. data >> l [ address ]. next ; } while ( first != -1 ) { if ( status [ abs ( l [ first ]. data )] == 0 ) { res1 . emplace_back ( first ); status [ abs ( l [ first ]. data )] = 1 ; // \u6807\u8bb0\u6b64\u6570\u7684\u7edd\u5bf9\u503c\u5df2\u7ecf\u51fa\u73b0 } else res2 . emplace_back ( first ); first = l [ first ]. next ; } for ( int i = 0 ; i != res1 . size () - 1 ; ++ i ) cout << setw ( 5 ) << setfill ( '0' ) << res1 [ i ] << \" \" << l [ res1 [ i ]]. data << \" \" << setw ( 5 ) << setfill ( '0' ) << res1 [ i + 1 ] << \" \\n \" ; cout << setw ( 5 ) << setfill ( '0' ) << res1 [ res1 . size () - 1 ] << \" \" << l [ res1 [ res1 . size () - 1 ]]. data << \" \" << -1 << \" \\n \" ; if ( ! res2 . empty ()){ for ( int i = 0 ; i != res2 . size () - 1 ; ++ i ) cout << setw ( 5 ) << setfill ( '0' ) << res2 [ i ] << \" \" << l [ res2 [ i ]]. data << \" \" << setw ( 5 ) << setfill ( '0' ) << res2 [ i + 1 ] << \" \\n \" ; cout << setw ( 5 ) << setfill ( '0' ) << res2 [ res2 . size () - 1 ] << \" \" << l [ res2 [ res2 . size () - 1 ]]. data << \" \" << -1 ; } return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/digital-library/","text":"Digital Library \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1022 Digital Library (30 point(s)) \u9898\u5e72\u5927\u610f \u00b6 \u7ed9\u4e66\u7684\u4fe1\u606f\uff0c\u6309\u7167\u7ed9\u5b9a\u7684\u90e8\u5206\u4fe1\u606f\u67e5\u51fa\u6765\u4e66\u7684 id \uff0c\u8fd9\u91cc\u6709\u4e2a\u95ee\u9898\u5c31\u662f\uff0c\u4e00\u672c\u4e66\u53ef\u80fd\u4e0e\u591a\u4e2a\u4f5c\u8005\u3001\u51fa\u7248\u793e\u7b49\u5bf9\u5e94\u3002 \u601d\u8def \u00b6 \u4f7f\u7528 map<string, set<int>> \u8fd9\u79cd\u7c7b\u578b\uff0c\u4e5f\u5c31\u662f\u5c06\u4e00\u4e2a string \u5982\u4f5c\u8005\uff0c\u8ddf\u591a\u4e2a\u4e66\u7684 id \u5bf9\u5e94\u3002 \u8fd9\u91cc\u53c8\u5b66\u5230\u4e86\u901a\u8fc7 cout \u63a7\u5236\u8f93\u51fa\u7684\u4f4d\u6570\uff1a #include <iomanip> cout << setw(n) << setfill(c); // \u901a\u8fc7\u8bbe\u7f6en\u4e2a\u4f4d\uff0c\u4e0d\u8db3\u7684\u7528c\u586b\u5145 \u4ee5\u53ca cin.peek() \u5224\u65ad\u662f\u5426\u8bfb\u5230\u4e86\u884c\u672b\uff0c\u8fd9\u4e2a\u51fd\u6570\u8fd4\u56de\u5f53\u524d\u8f93\u51fa\u6d41\u4e2d\u6307\u9488\u6307\u5411\u7684\u5b57\u7b26\uff0c\u6307\u9488\u4e0d\u540e\u79fb\u52a8\uff0c\u800c cin.get() \u8bfb\u5165\u5f53\u524d\u7684\u5b57\u7b26\u5e76\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4e2a if (cin.peek() == '\\n') { // \u5224\u65ad\u662f\u884c\u672b cin.get(); // \u8bfb\u53d6\u51fa\u6362\u884c\u7b26 break; // \u8fdb\u4e00\u6b65\u64cd\u4f5c\uff0c\u6bd4\u5982\u9000\u51fa\u73b0\u5728\u7684\u5faa\u73af\uff08\u5982\u679c\u5728\u5faa\u73af\u5185\u7684\u8bdd\uff09 } AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include <iostream> #include <map> #include <iomanip> #include <set> using namespace std ; void print ( map < string , set < int >> & mapSet , string & query ) { if ( mapSet . find ( query ) == mapSet . end ()) cout << \"Not Found \\n \" ; else { for ( auto & set : mapSet [ query ]) cout << setw ( 7 ) << setfill ( '0' ) << set << \" \\n \" ; // \u63a7\u5236\u8f93\u51fa\u4f4d\u6570\uff0c\u4ee50\u586b\u5145 } } int main () { ios :: sync_with_stdio ( false ); map < string , set < int >> mapTitle , mapAuthor , mapKey , mapPublisher , mapYear ; int n , m , id ; string title , author , key , publisher , year ; cin >> n ; while ( n -- ) { cin >> id ; cin . get (); getline ( cin , title ); mapTitle [ title ]. insert ( id ); getline ( cin , author ); mapAuthor [ author ]. insert ( id ); while ( cin >> key ) { mapKey [ key ]. insert ( id ); if ( cin . peek () == '\\n' ) { // \u53c8\u5b66\u5230\u4e00\u62db\uff0ccin.peek()\u83b7\u53d6\u5f53\u524d\u4f4d\u7f6e\u7684\u5b57\u7b26\uff0c\u53ef\u4ee5\u68c0\u6d4b\u662f\u5426\u8bfb\u5230\u4e86\u884c\u672b cin . get (); break ; } } getline ( cin , publisher ); mapPublisher [ publisher ]. insert ( id ); getline ( cin , year ); mapYear [ year ]. insert ( id ); } cin >> m ; int type ; string query ; while ( m -- ) { cin >> type ; cin . get (); cin . get (); getline ( cin , query ); cout << type << \": \" << query << endl ; switch ( type ) { case 1 : print ( mapTitle , query ); break ; case 2 : print ( mapAuthor , query ); break ; case 3 : print ( mapKey , query ); break ; case 4 : print ( mapPublisher , query ); break ; case 5 : print ( mapYear , query ); break ; default : break ; } } return 0 ; }","title":"A1022"},{"location":"pat/digital-library/#digital-library","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1022 Digital Library (30 point(s))","title":"Digital Library"},{"location":"pat/digital-library/#_1","text":"\u7ed9\u4e66\u7684\u4fe1\u606f\uff0c\u6309\u7167\u7ed9\u5b9a\u7684\u90e8\u5206\u4fe1\u606f\u67e5\u51fa\u6765\u4e66\u7684 id \uff0c\u8fd9\u91cc\u6709\u4e2a\u95ee\u9898\u5c31\u662f\uff0c\u4e00\u672c\u4e66\u53ef\u80fd\u4e0e\u591a\u4e2a\u4f5c\u8005\u3001\u51fa\u7248\u793e\u7b49\u5bf9\u5e94\u3002","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/digital-library/#_2","text":"\u4f7f\u7528 map<string, set<int>> \u8fd9\u79cd\u7c7b\u578b\uff0c\u4e5f\u5c31\u662f\u5c06\u4e00\u4e2a string \u5982\u4f5c\u8005\uff0c\u8ddf\u591a\u4e2a\u4e66\u7684 id \u5bf9\u5e94\u3002 \u8fd9\u91cc\u53c8\u5b66\u5230\u4e86\u901a\u8fc7 cout \u63a7\u5236\u8f93\u51fa\u7684\u4f4d\u6570\uff1a #include <iomanip> cout << setw(n) << setfill(c); // \u901a\u8fc7\u8bbe\u7f6en\u4e2a\u4f4d\uff0c\u4e0d\u8db3\u7684\u7528c\u586b\u5145 \u4ee5\u53ca cin.peek() \u5224\u65ad\u662f\u5426\u8bfb\u5230\u4e86\u884c\u672b\uff0c\u8fd9\u4e2a\u51fd\u6570\u8fd4\u56de\u5f53\u524d\u8f93\u51fa\u6d41\u4e2d\u6307\u9488\u6307\u5411\u7684\u5b57\u7b26\uff0c\u6307\u9488\u4e0d\u540e\u79fb\u52a8\uff0c\u800c cin.get() \u8bfb\u5165\u5f53\u524d\u7684\u5b57\u7b26\u5e76\u6307\u9488\u5411\u540e\u79fb\u52a8\u4e00\u4e2a if (cin.peek() == '\\n') { // \u5224\u65ad\u662f\u884c\u672b cin.get(); // \u8bfb\u53d6\u51fa\u6362\u884c\u7b26 break; // \u8fdb\u4e00\u6b65\u64cd\u4f5c\uff0c\u6bd4\u5982\u9000\u51fa\u73b0\u5728\u7684\u5faa\u73af\uff08\u5982\u679c\u5728\u5faa\u73af\u5185\u7684\u8bdd\uff09 }","title":"\u601d\u8def"},{"location":"pat/digital-library/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include <iostream> #include <map> #include <iomanip> #include <set> using namespace std ; void print ( map < string , set < int >> & mapSet , string & query ) { if ( mapSet . find ( query ) == mapSet . end ()) cout << \"Not Found \\n \" ; else { for ( auto & set : mapSet [ query ]) cout << setw ( 7 ) << setfill ( '0' ) << set << \" \\n \" ; // \u63a7\u5236\u8f93\u51fa\u4f4d\u6570\uff0c\u4ee50\u586b\u5145 } } int main () { ios :: sync_with_stdio ( false ); map < string , set < int >> mapTitle , mapAuthor , mapKey , mapPublisher , mapYear ; int n , m , id ; string title , author , key , publisher , year ; cin >> n ; while ( n -- ) { cin >> id ; cin . get (); getline ( cin , title ); mapTitle [ title ]. insert ( id ); getline ( cin , author ); mapAuthor [ author ]. insert ( id ); while ( cin >> key ) { mapKey [ key ]. insert ( id ); if ( cin . peek () == '\\n' ) { // \u53c8\u5b66\u5230\u4e00\u62db\uff0ccin.peek()\u83b7\u53d6\u5f53\u524d\u4f4d\u7f6e\u7684\u5b57\u7b26\uff0c\u53ef\u4ee5\u68c0\u6d4b\u662f\u5426\u8bfb\u5230\u4e86\u884c\u672b cin . get (); break ; } } getline ( cin , publisher ); mapPublisher [ publisher ]. insert ( id ); getline ( cin , year ); mapYear [ year ]. insert ( id ); } cin >> m ; int type ; string query ; while ( m -- ) { cin >> type ; cin . get (); cin . get (); getline ( cin , query ); cout << type << \": \" << query << endl ; switch ( type ) { case 1 : print ( mapTitle , query ); break ; case 2 : print ( mapAuthor , query ); break ; case 3 : print ( mapKey , query ); break ; case 4 : print ( mapPublisher , query ); break ; case 5 : print ( mapYear , query ); break ; default : break ; } } return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/general-palindromic-number/","text":"General Palindromic Number \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1019 General Palindromic Number (20 point(s)) \u9898\u5e72\u5927\u610f \u00b6 D\u8fdb\u5236\u95ee\u9898+\u5224\u65ad\u56de\u6587\u6570 \u601d\u8def \u00b6 \u5f88\u5e38\u89c4\uff0c\u53ea\u662f\u4e24\u4e2a\u95ee\u9898\u7ed3\u5408\u5728\u4e00\u8d77\u800c\u5df2 AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <iostream> #include <vector> using namespace std ; int main () { int n , b ; cin >> n >> b ; vector < int > ans ; do { ans . push_back ( n % b ); n /= b ; } while ( n != 0 ); bool flag = true ; for ( auto i = 0 ; i != ans . size () / 2 ; ++ i ) { if ( ans [ i ] != ans [ ans . size () - i - 1 ]) { flag = false ; break ; } } flag ? ( cout << \"Yes \\n \" ) : ( cout << \"No \\n \" ); for ( auto i = ans . size () - 1 ; i != -1 ; -- i ) { cout << ans [ i ]; if ( i ) cout << \" \" ; } return 0 ; }","title":"A1019"},{"location":"pat/general-palindromic-number/#general-palindromic-number","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1019 General Palindromic Number (20 point(s))","title":"General Palindromic Number"},{"location":"pat/general-palindromic-number/#_1","text":"D\u8fdb\u5236\u95ee\u9898+\u5224\u65ad\u56de\u6587\u6570","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/general-palindromic-number/#_2","text":"\u5f88\u5e38\u89c4\uff0c\u53ea\u662f\u4e24\u4e2a\u95ee\u9898\u7ed3\u5408\u5728\u4e00\u8d77\u800c\u5df2","title":"\u601d\u8def"},{"location":"pat/general-palindromic-number/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <iostream> #include <vector> using namespace std ; int main () { int n , b ; cin >> n >> b ; vector < int > ans ; do { ans . push_back ( n % b ); n /= b ; } while ( n != 0 ); bool flag = true ; for ( auto i = 0 ; i != ans . size () / 2 ; ++ i ) { if ( ans [ i ] != ans [ ans . size () - i - 1 ]) { flag = false ; break ; } } flag ? ( cout << \"Yes \\n \" ) : ( cout << \"No \\n \" ); for ( auto i = ans . size () - 1 ; i != -1 ; -- i ) { cout << ans [ i ]; if ( i ) cout << \" \" ; } return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/group-photo/","text":"Group Photo \u00b6 \u9898\u76ee\u94fe\u63a5 1109 Group Photo (25 \u5206) \u9898\u5e72\u5927\u610f \u00b6 \u7ed9\u5b9a\u4eba\u6570\uff0c\u6392\u6570\uff0c\u7ed9\u8fd9\u4e9b\u4eba\u6309\u8eab\u9ad8\u6392\u961f\uff0c\u540e\u4e00\u6392\u4eba\u8eab\u9ad8\u4e0d\u4f4e\u4e8e\u524d\u4e00\u6392\uff0c\u6bcf\u4e00\u6392\u8eab\u9ad8\uff0c\u8eab\u9ad8\u76f8\u540c\u5219\u6309\u540d\u5b57\u6392\u5e8f\u6309\u7167\u4e2d\u95f4\u6700\u9ad8\uff0c\u7136\u540e\u53f3\u8fb9\uff0c\u518d\u5de6\u8fb9\u8fd9\u6837\u5b50\uff0c\u770b\u82f1\u6587\u63cf\u8ff0\uff0c\u5f88\u5bb9\u6613\u61c2\u3002 \u601d\u8def \u00b6 \u5148\u7ed9\u8fd9\u4e9b\u4eba\u6392\u5e8f\uff0c\u8eab\u9ad8\u4ece\u9ad8\u5230\u4f4e\uff0c\u540d\u5b57\u4ece\u5c0f\u5230\u5927\uff0c\u7136\u540e\u6309\u6bcf\u4e00\u6392\u5212\u5206\u7ec4\uff0c\u8fdb\u884c\u6392\u961f\u3002 \u95ee\u9898 \u00b6 \u6ce8\u610f\u6700\u540e\u4e00\u6392\u4eba\u6570\uff0c\u6309\u7167N - N / K * (N / K - 1)\u6709\u95ee\u9898\uff0c\u56e0\u4e3a\u5982\u215a\u4f1a\u5f53\u62100\uff0c\u6240\u4ee5\u8981\u7528\u6c42\u4f59\u8fd0\u7b97\u66f4\u4f73\u3002 AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include <iostream> #include <utility> #include <vector> #include <string> #include <algorithm> using namespace std ; struct Student { int height ; string name ; }; bool cmp ( Student s1 , Student s2 ) { if ( s1 . height == s2 . height ) return s1 . name < s2 . name ; return s1 . height > s2 . height ; } int main () { int K , N ; cin >> K >> N ; vector < Student > stu ( K ); // for (int i = 0; i < K; ++i) // { // int height; string name; // cin >> name >> height; // stu.push_back(Student{height, name}); // } for ( auto it = stu . begin (); it != stu . end (); ++ it ) cin >> it -> name >> it -> height ; sort ( stu . begin (), stu . end (), cmp ); vector < vector < string >> rows ( N ); for ( int i = 1 ; i < N ; ++ i ) rows [ i ]. resize ( K / N ); rows [ 0 ]. resize ( K / N + K % N ); // \u53d6\u4f59 note\uff01\uff01\uff01 int num = 0 ; for ( int i = 0 ; i < rows . size (); ++ i ) { int p = num , m = rows [ i ]. size (); num += m ; int start = m / 2 ; bool direction = true ; rows [ i ][ start ] = stu [ p ]. name ; for ( int j = 1 ; ( p + j ) < num ; ++ j ) { if ( direction ) { start -= j ; direction = false ; } else { start += j ; direction = true ; } rows [ i ][ start ] = stu [ p + j ]. name ; } } for ( int i = 0 ; i < rows . size (); ++ i ) { for ( int j = 0 ; j < rows [ i ]. size (); ++ j ) { cout << rows [ i ][ j ]; if ( j != rows [ i ]. size () - 1 ) cout << \" \" ; } if ( i != rows . size () - 1 ) cout << endl ; } return 0 ; }","title":"A1109"},{"location":"pat/group-photo/#group-photo","text":"\u9898\u76ee\u94fe\u63a5 1109 Group Photo (25 \u5206)","title":"Group Photo"},{"location":"pat/group-photo/#_1","text":"\u7ed9\u5b9a\u4eba\u6570\uff0c\u6392\u6570\uff0c\u7ed9\u8fd9\u4e9b\u4eba\u6309\u8eab\u9ad8\u6392\u961f\uff0c\u540e\u4e00\u6392\u4eba\u8eab\u9ad8\u4e0d\u4f4e\u4e8e\u524d\u4e00\u6392\uff0c\u6bcf\u4e00\u6392\u8eab\u9ad8\uff0c\u8eab\u9ad8\u76f8\u540c\u5219\u6309\u540d\u5b57\u6392\u5e8f\u6309\u7167\u4e2d\u95f4\u6700\u9ad8\uff0c\u7136\u540e\u53f3\u8fb9\uff0c\u518d\u5de6\u8fb9\u8fd9\u6837\u5b50\uff0c\u770b\u82f1\u6587\u63cf\u8ff0\uff0c\u5f88\u5bb9\u6613\u61c2\u3002","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/group-photo/#_2","text":"\u5148\u7ed9\u8fd9\u4e9b\u4eba\u6392\u5e8f\uff0c\u8eab\u9ad8\u4ece\u9ad8\u5230\u4f4e\uff0c\u540d\u5b57\u4ece\u5c0f\u5230\u5927\uff0c\u7136\u540e\u6309\u6bcf\u4e00\u6392\u5212\u5206\u7ec4\uff0c\u8fdb\u884c\u6392\u961f\u3002","title":"\u601d\u8def"},{"location":"pat/group-photo/#_3","text":"\u6ce8\u610f\u6700\u540e\u4e00\u6392\u4eba\u6570\uff0c\u6309\u7167N - N / K * (N / K - 1)\u6709\u95ee\u9898\uff0c\u56e0\u4e3a\u5982\u215a\u4f1a\u5f53\u62100\uff0c\u6240\u4ee5\u8981\u7528\u6c42\u4f59\u8fd0\u7b97\u66f4\u4f73\u3002","title":"\u95ee\u9898"},{"location":"pat/group-photo/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include <iostream> #include <utility> #include <vector> #include <string> #include <algorithm> using namespace std ; struct Student { int height ; string name ; }; bool cmp ( Student s1 , Student s2 ) { if ( s1 . height == s2 . height ) return s1 . name < s2 . name ; return s1 . height > s2 . height ; } int main () { int K , N ; cin >> K >> N ; vector < Student > stu ( K ); // for (int i = 0; i < K; ++i) // { // int height; string name; // cin >> name >> height; // stu.push_back(Student{height, name}); // } for ( auto it = stu . begin (); it != stu . end (); ++ it ) cin >> it -> name >> it -> height ; sort ( stu . begin (), stu . end (), cmp ); vector < vector < string >> rows ( N ); for ( int i = 1 ; i < N ; ++ i ) rows [ i ]. resize ( K / N ); rows [ 0 ]. resize ( K / N + K % N ); // \u53d6\u4f59 note\uff01\uff01\uff01 int num = 0 ; for ( int i = 0 ; i < rows . size (); ++ i ) { int p = num , m = rows [ i ]. size (); num += m ; int start = m / 2 ; bool direction = true ; rows [ i ][ start ] = stu [ p ]. name ; for ( int j = 1 ; ( p + j ) < num ; ++ j ) { if ( direction ) { start -= j ; direction = false ; } else { start += j ; direction = true ; } rows [ i ][ start ] = stu [ p + j ]. name ; } } for ( int i = 0 ; i < rows . size (); ++ i ) { for ( int j = 0 ; j < rows [ i ]. size (); ++ j ) { cout << rows [ i ][ j ]; if ( j != rows [ i ]. size () - 1 ) cout << \" \" ; } if ( i != rows . size () - 1 ) cout << endl ; } return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/hello-world-for-u/","text":"Hello World for U \u00b6 \u9898\u76ee\u94fe\u63a5 1031 Hello World for U (20 \u5206) \u9898\u5e72\u5927\u610f \u00b6 \u5c06\u7ed9\u5b9a\u7684\u5b57\u7b26\u4e32\uff0c\u6309\u7167U \u578b\u8f93\u51fa \u601d\u8def \u00b6 \u8ba1\u7b97\u51fa n1 \u3001 n2 \u3001 n3 \uff0c\u7136\u540e\u6309\u884c\u8f93\u51fa\u5373\u53ef\u3002\u7531 n1 = n3 \u4e14\u4e0d\u5927\u4e8e n2 \u5219\u6709 n1 = n3 = (n + 2) / 3 \u7684\u4e0b\u6574\u3002 AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <iostream> using namespace std ; int main () { string str ; cin >> str ; int len = int ( str . length ()); int n1 = ( len + 2 ) / 3 , n3 = n1 , n2 = len + 2 - n1 - n3 ; for ( int i = 0 ; i < n1 - 1 ; ++ i ) { // n1 - 1 rows cout << str [ i ]; for ( int j = 0 ; j < n2 - 2 ; ++ j ) cout << \" \" ; cout << str [ len - i - 1 ] << endl ; } for ( int i = 0 ; i < n2 ; ++ i ) cout << str [ n1 + i - 1 ]; return 0 ; }","title":"A1031"},{"location":"pat/hello-world-for-u/#hello-world-for-u","text":"\u9898\u76ee\u94fe\u63a5 1031 Hello World for U (20 \u5206)","title":"Hello World for U"},{"location":"pat/hello-world-for-u/#_1","text":"\u5c06\u7ed9\u5b9a\u7684\u5b57\u7b26\u4e32\uff0c\u6309\u7167U \u578b\u8f93\u51fa","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/hello-world-for-u/#_2","text":"\u8ba1\u7b97\u51fa n1 \u3001 n2 \u3001 n3 \uff0c\u7136\u540e\u6309\u884c\u8f93\u51fa\u5373\u53ef\u3002\u7531 n1 = n3 \u4e14\u4e0d\u5927\u4e8e n2 \u5219\u6709 n1 = n3 = (n + 2) / 3 \u7684\u4e0b\u6574\u3002","title":"\u601d\u8def"},{"location":"pat/hello-world-for-u/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <iostream> using namespace std ; int main () { string str ; cin >> str ; int len = int ( str . length ()); int n1 = ( len + 2 ) / 3 , n3 = n1 , n2 = len + 2 - n1 - n3 ; for ( int i = 0 ; i < n1 - 1 ; ++ i ) { // n1 - 1 rows cout << str [ i ]; for ( int j = 0 ; j < n2 - 2 ; ++ j ) cout << \" \" ; cout << str [ len - i - 1 ] << endl ; } for ( int i = 0 ; i < n2 ; ++ i ) cout << str [ n1 + i - 1 ]; return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/integer-factorization/","text":"Integer Factorization \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1103 Integer Factorization (30 point(s)) \u9898\u5e72\u5927\u610f \u00b6 \u5c06\u7ed9\u5b9a\u7684\u6570\u62c6\u6210\uff0c\u6307\u5b9a\u4e2a\u6570\u7684P\u6b21\u65b9\u7684\u548c\uff0c\u8f93\u51fa\u8fd9\u4e9b\u6570\u4e2d\u603b\u548c\u6700\u5927\u7684\u90a3\u4e00\u7ec4 \u601d\u8def \u00b6 \u5b66\u4e60\u4e86\u300a\u7b97\u6cd5\u7b14\u8bb0\u300b\uff0c\u63d0\u524d\u5c06\u7528\u5230\u7684\u8fd9\u5199\u6307\u5b9a\u7684\u6570\u521d\u59cb\u5316\uff0c\u540e\u9762\u76f4\u63a5\u5c31\u4e00\u4e2a\u4e00\u4e2a\u8bd5\u5c31\u597d\u4e86 \u4e3b\u8981\u662f DFS \u7684\u95ee\u9898\uff0c\u501f\u52a9\u5168\u5c40\u53d8\u91cf\u4f1a\u5f88\u65b9\u4fbf AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include <iostream> #include <cmath> #include <vector> using namespace std ; int N , K , P , maxFacSum = -1 ; // \u6700\u5927\u5e95\u6570\u548c vector < int > fac , ans , temp ; // fac\u5b58\u653e\u4e0d\u5927\u4e8eN\u7684i^p\u7684\u6570, ans\u4e3a\u7ed3\u679c\uff0ctemp\u4e3a\u4e2d\u95f4\u91cf void init () { int t = 0 ; double i = 0 ; while ( t <= N ) { fac . emplace_back ( t ); t = int ( pow ( ++ i , P )); } } /** * @param index \u5f53\u524d\u5c1d\u8bd5\u7684\u5143\u7d20\u4e0b\u6807 * @param cur_k \u5f53\u524d\u9009\u4e2d\u7684\u5143\u7d20\u4e2a\u6570 * @param sum \u5f53\u524d\u9009\u4e2d\u7684\u6570\u7684\u548c * @param fac_sum \u5f53\u524d\u9009\u4e2d\u7684\u5e95\u6570\u548c */ void DFS ( int index , int cur_k , int sum , int fac_sum ) { if ( sum == N && cur_k == K ) { // \u627e\u5230\u91cf\u4e00\u4e2a\u7b26\u5408\u7684\u5e8f\u5217 if ( fac_sum > maxFacSum ) { // \u9009\u62e9\u5e95\u6570\u548c\u66f4\u5927\u7684 ans = temp ; maxFacSum = fac_sum ; } return ; } if ( sum > N || cur_k > K ) return ; // \u8fd0\u884c\u4ee5\u4e0b\u4ee3\u7801\u524d\u63d0\uff1asum\u5f53\u524d\u548c\u672a\u8d85\u51faN\u4e14\u5f53\u524d\u9009\u62e9\u7684\u4e2a\u6570cur_k\u4e5f\u672a\u8d85\u51faK if ( index >= 1 ) { // fac[0] = 0, \u4e0d\u5728\u9009\u62e9\u8303\u56f4\u5185 temp . emplace_back ( index ); // \u9009\u62e9\u5f53\u524dindex DFS ( index , cur_k + 1 , sum + fac [ index ], fac_sum + index ); temp . pop_back (); // \u4e0d\u9009\u5f53\u524dindex DFS ( index - 1 , cur_k , sum , fac_sum ); } } int main () { cin >> N >> K >> P ; init (); DFS ( fac . size () - 1 , 0 , 0 , 0 ); if ( maxFacSum == -1 ) cout << \"Impossible \\n \" ; else { cout << N << \" = \" << ans [ 0 ] << \"^\" << P ; for ( auto it = ans . begin () + 1 ; it != ans . end (); ++ it ) cout << \" + \" << * it << \"^\" << P ; } return 0 ; }","title":"A1103"},{"location":"pat/integer-factorization/#integer-factorization","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1103 Integer Factorization (30 point(s))","title":"Integer Factorization"},{"location":"pat/integer-factorization/#_1","text":"\u5c06\u7ed9\u5b9a\u7684\u6570\u62c6\u6210\uff0c\u6307\u5b9a\u4e2a\u6570\u7684P\u6b21\u65b9\u7684\u548c\uff0c\u8f93\u51fa\u8fd9\u4e9b\u6570\u4e2d\u603b\u548c\u6700\u5927\u7684\u90a3\u4e00\u7ec4","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/integer-factorization/#_2","text":"\u5b66\u4e60\u4e86\u300a\u7b97\u6cd5\u7b14\u8bb0\u300b\uff0c\u63d0\u524d\u5c06\u7528\u5230\u7684\u8fd9\u5199\u6307\u5b9a\u7684\u6570\u521d\u59cb\u5316\uff0c\u540e\u9762\u76f4\u63a5\u5c31\u4e00\u4e2a\u4e00\u4e2a\u8bd5\u5c31\u597d\u4e86 \u4e3b\u8981\u662f DFS \u7684\u95ee\u9898\uff0c\u501f\u52a9\u5168\u5c40\u53d8\u91cf\u4f1a\u5f88\u65b9\u4fbf","title":"\u601d\u8def"},{"location":"pat/integer-factorization/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include <iostream> #include <cmath> #include <vector> using namespace std ; int N , K , P , maxFacSum = -1 ; // \u6700\u5927\u5e95\u6570\u548c vector < int > fac , ans , temp ; // fac\u5b58\u653e\u4e0d\u5927\u4e8eN\u7684i^p\u7684\u6570, ans\u4e3a\u7ed3\u679c\uff0ctemp\u4e3a\u4e2d\u95f4\u91cf void init () { int t = 0 ; double i = 0 ; while ( t <= N ) { fac . emplace_back ( t ); t = int ( pow ( ++ i , P )); } } /** * @param index \u5f53\u524d\u5c1d\u8bd5\u7684\u5143\u7d20\u4e0b\u6807 * @param cur_k \u5f53\u524d\u9009\u4e2d\u7684\u5143\u7d20\u4e2a\u6570 * @param sum \u5f53\u524d\u9009\u4e2d\u7684\u6570\u7684\u548c * @param fac_sum \u5f53\u524d\u9009\u4e2d\u7684\u5e95\u6570\u548c */ void DFS ( int index , int cur_k , int sum , int fac_sum ) { if ( sum == N && cur_k == K ) { // \u627e\u5230\u91cf\u4e00\u4e2a\u7b26\u5408\u7684\u5e8f\u5217 if ( fac_sum > maxFacSum ) { // \u9009\u62e9\u5e95\u6570\u548c\u66f4\u5927\u7684 ans = temp ; maxFacSum = fac_sum ; } return ; } if ( sum > N || cur_k > K ) return ; // \u8fd0\u884c\u4ee5\u4e0b\u4ee3\u7801\u524d\u63d0\uff1asum\u5f53\u524d\u548c\u672a\u8d85\u51faN\u4e14\u5f53\u524d\u9009\u62e9\u7684\u4e2a\u6570cur_k\u4e5f\u672a\u8d85\u51faK if ( index >= 1 ) { // fac[0] = 0, \u4e0d\u5728\u9009\u62e9\u8303\u56f4\u5185 temp . emplace_back ( index ); // \u9009\u62e9\u5f53\u524dindex DFS ( index , cur_k + 1 , sum + fac [ index ], fac_sum + index ); temp . pop_back (); // \u4e0d\u9009\u5f53\u524dindex DFS ( index - 1 , cur_k , sum , fac_sum ); } } int main () { cin >> N >> K >> P ; init (); DFS ( fac . size () - 1 , 0 , 0 , 0 ); if ( maxFacSum == -1 ) cout << \"Impossible \\n \" ; else { cout << N << \" = \" << ans [ 0 ] << \"^\" << P ; for ( auto it = ans . begin () + 1 ; it != ans . end (); ++ it ) cout << \" + \" << * it << \"^\" << P ; } return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/invert-a-binary-tree/","text":"Invert a Binary Tree \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1102 Invert a Binary Tree (25 point(s)) \u9898\u5e72\u5927\u610f \u00b6 \u7ed9\u51fa\u4e8c\u53c9\u6811\u8282\u70b9\u4e2a\u6570\uff0c\u4ee5\u53ca\u5404\u4e2a\u8282\u70b9\u7684\u5b69\u5b50\u4fe1\u606f\uff0c\u8981\u6c42\u8f93\u51fa\u53cd\u8f6c\u540e\u7684\u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u4e0e\u4e2d\u5e8f\u904d\u5386\u7ed3\u679c \u601d\u8def \u00b6 \u5173\u952e\u5728\u4e8e\u6784\u5efa\u4e8c\u53c9\u6811\uff0c\u6211\u8fd8\u662f\u4e60\u60ef\u4e8e\u7528\u52a8\u6001\u5f62\u5f0f\u7684\u6811\uff0c\u6240\u4ee5\u8be6\u7ec6\u770b\u4ee3\u7801\u5427\uff0c\u5f88\u5e38\u89c4 AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 #include <iostream> #include <vector> #include <queue> using namespace std ; struct node { int data {}; struct node * left { nullptr }; struct node * right { nullptr }; struct node * parent { nullptr }; // \u53d7\u9093\u516c\u7684\u6559\u8bf2\uff0c\u73b0\u5728\u6211\u662f\u771f\u611f\u89c9\u591a\u7528\u4e00\u4e2a\u7236\u8282\u70b9\u662f\u591a\u4e48\u7684\u660e\u4e86 }; int n ; vector < int > in ; // NOLINT vector < int > layer ; // NOLINT vector < string > str ; node * construct () { node ** p = new node * [ n ]; // \u5b58\u50a8\u6240\u6709\u7684\u6307\u5411\u8282\u70b9\u7684\u6307\u9488 for ( int i = 0 ; i < n ; ++ i ) { // \u6ce8\u610f\u4e8c\u7ef4\u6570\u7ec4\u5efa\u7acb\u7684\u65f6\u5019\uff0c\u6bcf\u4e00\u884c\u90fd\u8981\u5728\u7533\u8bf7\u4e00\u4e0b\u7a7a\u95f4 p [ i ] = new node ; // \u7ed9\u6bcf\u4e00\u884c\u5f00\u8f9f\u4e00\u4e2a\u8282\u70b9 p [ i ] -> data = i ; } for ( int i = 0 ; i < n ; ++ i ) { if ( str [ i ][ 0 ] != '-' ) { // \u7ed9\u51fa\u4e86\u5b69\u5b50\u4fe1\u606f\uff0c\u4e5f\u5c31\u7ed9\u51fa\u4e86\u7236\u4eb2\u4fe1\u606f p [ i ] -> left = p [ str [ i ][ 0 ] - '0' ]; p [ str [ i ][ 0 ] - '0' ] -> parent = p [ i ]; } if ( str [ i ][ 2 ] != '-' ) { p [ i ] -> right = p [ str [ i ][ 2 ] - '0' ]; p [ str [ i ][ 2 ] - '0' ] -> parent = p [ i ]; } } node * root ; for ( int i = 0 ; i < n ; ++ i ) { // \u627e\u51fa\u6839\u8282\u70b9 if ( p [ i ] -> parent == nullptr ) { root = p [ i ]; break ; } } queue < node *> q ; q . push ( root ); while ( ! q . empty ()) { node * temp = q . front (); q . pop (); if ( temp -> left ) q . push ( temp -> left ); if ( temp -> right ) q . push ( temp -> right ); swap ( temp -> left , temp -> right ); // \u7ffb\u8f6c\u6811\uff0c\u5373\u5c06\u6bcf\u4e2a\u8282\u70b9\u7684\u5de6\u53f3\u5b50\u6811\u4ea4\u6362 } return root ; } void in_traverse ( node * & tree ) { // \u5e38\u89c4 if ( ! tree ) return ; in_traverse ( tree -> left ); in . emplace_back ( tree -> data ); in_traverse ( tree -> right ); } void layer_traverse ( node * & tree ) { // \u5e38\u89c4 queue < node *> q ; q . push ( tree ); while ( ! q . empty ()) { node * temp = q . front (); q . pop (); if ( temp -> left ) q . push ( temp -> left ); if ( temp -> right ) q . push ( temp -> right ); layer . emplace_back ( temp -> data ); } } int main () { cin >> n ; cin . get (); str . resize ( n ); for ( int i = 0 ; i < n ; ++ i ) getline ( cin , str [ i ]); node * tree = construct (); in_traverse ( tree ); layer_traverse ( tree ); for ( auto & it : layer ) { cout << it ; if ( & it != & layer . back ()) cout << \" \" ; else cout << \" \\n \" ; } for ( auto & it : in ) { cout << it ; if ( & it != & in . back ()) cout << \" \" ; else cout << \" \\n \" ; } return 0 ; }","title":"A1102"},{"location":"pat/invert-a-binary-tree/#invert-a-binary-tree","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1102 Invert a Binary Tree (25 point(s))","title":"Invert a Binary Tree"},{"location":"pat/invert-a-binary-tree/#_1","text":"\u7ed9\u51fa\u4e8c\u53c9\u6811\u8282\u70b9\u4e2a\u6570\uff0c\u4ee5\u53ca\u5404\u4e2a\u8282\u70b9\u7684\u5b69\u5b50\u4fe1\u606f\uff0c\u8981\u6c42\u8f93\u51fa\u53cd\u8f6c\u540e\u7684\u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u4e0e\u4e2d\u5e8f\u904d\u5386\u7ed3\u679c","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/invert-a-binary-tree/#_2","text":"\u5173\u952e\u5728\u4e8e\u6784\u5efa\u4e8c\u53c9\u6811\uff0c\u6211\u8fd8\u662f\u4e60\u60ef\u4e8e\u7528\u52a8\u6001\u5f62\u5f0f\u7684\u6811\uff0c\u6240\u4ee5\u8be6\u7ec6\u770b\u4ee3\u7801\u5427\uff0c\u5f88\u5e38\u89c4","title":"\u601d\u8def"},{"location":"pat/invert-a-binary-tree/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 #include <iostream> #include <vector> #include <queue> using namespace std ; struct node { int data {}; struct node * left { nullptr }; struct node * right { nullptr }; struct node * parent { nullptr }; // \u53d7\u9093\u516c\u7684\u6559\u8bf2\uff0c\u73b0\u5728\u6211\u662f\u771f\u611f\u89c9\u591a\u7528\u4e00\u4e2a\u7236\u8282\u70b9\u662f\u591a\u4e48\u7684\u660e\u4e86 }; int n ; vector < int > in ; // NOLINT vector < int > layer ; // NOLINT vector < string > str ; node * construct () { node ** p = new node * [ n ]; // \u5b58\u50a8\u6240\u6709\u7684\u6307\u5411\u8282\u70b9\u7684\u6307\u9488 for ( int i = 0 ; i < n ; ++ i ) { // \u6ce8\u610f\u4e8c\u7ef4\u6570\u7ec4\u5efa\u7acb\u7684\u65f6\u5019\uff0c\u6bcf\u4e00\u884c\u90fd\u8981\u5728\u7533\u8bf7\u4e00\u4e0b\u7a7a\u95f4 p [ i ] = new node ; // \u7ed9\u6bcf\u4e00\u884c\u5f00\u8f9f\u4e00\u4e2a\u8282\u70b9 p [ i ] -> data = i ; } for ( int i = 0 ; i < n ; ++ i ) { if ( str [ i ][ 0 ] != '-' ) { // \u7ed9\u51fa\u4e86\u5b69\u5b50\u4fe1\u606f\uff0c\u4e5f\u5c31\u7ed9\u51fa\u4e86\u7236\u4eb2\u4fe1\u606f p [ i ] -> left = p [ str [ i ][ 0 ] - '0' ]; p [ str [ i ][ 0 ] - '0' ] -> parent = p [ i ]; } if ( str [ i ][ 2 ] != '-' ) { p [ i ] -> right = p [ str [ i ][ 2 ] - '0' ]; p [ str [ i ][ 2 ] - '0' ] -> parent = p [ i ]; } } node * root ; for ( int i = 0 ; i < n ; ++ i ) { // \u627e\u51fa\u6839\u8282\u70b9 if ( p [ i ] -> parent == nullptr ) { root = p [ i ]; break ; } } queue < node *> q ; q . push ( root ); while ( ! q . empty ()) { node * temp = q . front (); q . pop (); if ( temp -> left ) q . push ( temp -> left ); if ( temp -> right ) q . push ( temp -> right ); swap ( temp -> left , temp -> right ); // \u7ffb\u8f6c\u6811\uff0c\u5373\u5c06\u6bcf\u4e2a\u8282\u70b9\u7684\u5de6\u53f3\u5b50\u6811\u4ea4\u6362 } return root ; } void in_traverse ( node * & tree ) { // \u5e38\u89c4 if ( ! tree ) return ; in_traverse ( tree -> left ); in . emplace_back ( tree -> data ); in_traverse ( tree -> right ); } void layer_traverse ( node * & tree ) { // \u5e38\u89c4 queue < node *> q ; q . push ( tree ); while ( ! q . empty ()) { node * temp = q . front (); q . pop (); if ( temp -> left ) q . push ( temp -> left ); if ( temp -> right ) q . push ( temp -> right ); layer . emplace_back ( temp -> data ); } } int main () { cin >> n ; cin . get (); str . resize ( n ); for ( int i = 0 ; i < n ; ++ i ) getline ( cin , str [ i ]); node * tree = construct (); in_traverse ( tree ); layer_traverse ( tree ); for ( auto & it : layer ) { cout << it ; if ( & it != & layer . back ()) cout << \" \" ; else cout << \" \\n \" ; } for ( auto & it : in ) { cout << it ; if ( & it != & in . back ()) cout << \" \" ; else cout << \" \\n \" ; } return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/kuchiguse/","text":"Kuchiguse \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1077 Kuchiguse (20 point(s)) \u9898\u5e72\u5927\u610f \u00b6 \u8f93\u51fa\u6700\u957f\u516c\u5171\u540e\u7f00 \u601d\u8def \u00b6 \u5229\u7528 algorithm \u4e2d\u7684 reverse \u51fd\u6570\uff0c\u53d8\u4e3a\u6700\u957f\u516c\u5171\u524d\u7f00\uff0c\u4e2d\u95f4\u5b66\u4e60\u4e86\u4e00\u4e0b lambda \u8868\u8fbe\u5f0f AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include <iostream> #include <vector> #include <algorithm> using namespace std ; bool fit ( vector < string > spoken , int k ) { bool flag = true ; for ( auto it = spoken . begin (); it != spoken . end () - 1 ; ++ it ) { string a = * it , b = * ( it + 1 ); if ( a [ k ] != b [ k ]) { flag = false ; break ; } } return flag ; } int main () { int n ; cin >> n ; cin . get (); vector < string > spoken ( n ); int min = 257 ; for ( auto & s : spoken ) { // \u8bfb\u5165\u3001\u7ffb\u8f6c\u53d8\u4e3a\u6700\u957f\u516c\u5171\u524d\u7f00\uff0c\u8ba1\u7b97\u6700\u77ed\u7684\u957f\u5ea6 getline ( cin , s ); reverse ( s . begin (), s . end ()); if ( min < s . length ()) min = s . length (); } int k ; for ( k = -1 ; k < min ;) { if ( fit ( spoken , k + 1 )) ++ k ; else break ; } // \u5b66\u4e60\u4f7f\u7528lambda\u8868\u8fbe\u5f0f k < 0 ? cout << \"nai\" : cout << [ k ]( const string & str ) -> string { string ans = str . substr ( 0 , k + 1 ); reverse ( ans . begin (), ans . end ()); return ans ; } ( spoken [ 0 ]); return 0 ; }","title":"A1077"},{"location":"pat/kuchiguse/#kuchiguse","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1077 Kuchiguse (20 point(s))","title":"Kuchiguse"},{"location":"pat/kuchiguse/#_1","text":"\u8f93\u51fa\u6700\u957f\u516c\u5171\u540e\u7f00","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/kuchiguse/#_2","text":"\u5229\u7528 algorithm \u4e2d\u7684 reverse \u51fd\u6570\uff0c\u53d8\u4e3a\u6700\u957f\u516c\u5171\u524d\u7f00\uff0c\u4e2d\u95f4\u5b66\u4e60\u4e86\u4e00\u4e0b lambda \u8868\u8fbe\u5f0f","title":"\u601d\u8def"},{"location":"pat/kuchiguse/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include <iostream> #include <vector> #include <algorithm> using namespace std ; bool fit ( vector < string > spoken , int k ) { bool flag = true ; for ( auto it = spoken . begin (); it != spoken . end () - 1 ; ++ it ) { string a = * it , b = * ( it + 1 ); if ( a [ k ] != b [ k ]) { flag = false ; break ; } } return flag ; } int main () { int n ; cin >> n ; cin . get (); vector < string > spoken ( n ); int min = 257 ; for ( auto & s : spoken ) { // \u8bfb\u5165\u3001\u7ffb\u8f6c\u53d8\u4e3a\u6700\u957f\u516c\u5171\u524d\u7f00\uff0c\u8ba1\u7b97\u6700\u77ed\u7684\u957f\u5ea6 getline ( cin , s ); reverse ( s . begin (), s . end ()); if ( min < s . length ()) min = s . length (); } int k ; for ( k = -1 ; k < min ;) { if ( fit ( spoken , k + 1 )) ++ k ; else break ; } // \u5b66\u4e60\u4f7f\u7528lambda\u8868\u8fbe\u5f0f k < 0 ? cout << \"nai\" : cout << [ k ]( const string & str ) -> string { string ans = str . substr ( 0 , k + 1 ); reverse ( ans . begin (), ans . end ()); return ans ; } ( spoken [ 0 ]); return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/linked-list-sorting/","text":"Linked List Sorting \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1052 Linked List Sorting (25 point(s)) \u9898\u5e72\u5927\u610f \u00b6 \u7ed9\u7ed9\u5b9a\u94fe\u8868\u6392\u5e8f \u601d\u8def \u00b6 \u8c03\u7528 sort \u51fd\u6570\uff0c\u6ce8\u610f\uff0c\u9898\u76ee\u4e2d\u7ed9\u7684\u8282\u70b9\u4e0d\u4e00\u5b9a\u90fd\u5728\u94fe\u8868\u4e0a\uff0c\u4e14\u4e0d\u4e00\u5b9a\u7ed9\u5b9a\u7684\u8282\u70b9\u4e00\u5b9a\u4f1a\u7ec4\u6210\u4e00\u4e2a\u94fe\u8868\uff0c\u9700\u8981\u7279\u6b8a\u5224\u65ad AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include <iostream> #include <vector> #include <iomanip> #include <algorithm> using namespace std ; const int MaxN = 1e6 + 10 ; struct node { int data {}; int next {}; } l [ MaxN ]; bool cmp ( int a , int b ) { return l [ a ]. data < l [ b ]. data ; } int main () { int N , first ; vector < int > res ; cin >> N >> first ; int address ; for ( int i = 0 ; i < N ; ++ i ) { cin >> address >> l [ address ]. data >> l [ address ]. next ; } while ( first != -1 ) { res . emplace_back ( first ); first = l [ first ]. next ; } if ( res . empty ()) { // \u6709\u6548\u8282\u70b9\u4e3a0 cout << 0 << \" \" << -1 ; return 0 ; } sort ( res . begin (), res . end (), cmp ); cout << res . size () << \" \" << setw ( 5 ) << setfill ( '0' ) << res [ 0 ] << \" \\n \" ; for ( int i = 0 ; i < res . size () - 1 ; ++ i ) cout << setw ( 5 ) << setfill ( '0' ) << res [ i ] << \" \" << l [ res [ i ]]. data << \" \" << setw ( 5 ) << setfill ( '0' ) << res [ i + 1 ] << \" \\n \" ; cout << setw ( 5 ) << setfill ( '0' ) << res [ res . size () - 1 ] << \" \" << l [ res [ res . size () - 1 ]]. data << \" \" << -1 ; return 0 ; }","title":"A1052"},{"location":"pat/linked-list-sorting/#linked-list-sorting","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1052 Linked List Sorting (25 point(s))","title":"Linked List Sorting"},{"location":"pat/linked-list-sorting/#_1","text":"\u7ed9\u7ed9\u5b9a\u94fe\u8868\u6392\u5e8f","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/linked-list-sorting/#_2","text":"\u8c03\u7528 sort \u51fd\u6570\uff0c\u6ce8\u610f\uff0c\u9898\u76ee\u4e2d\u7ed9\u7684\u8282\u70b9\u4e0d\u4e00\u5b9a\u90fd\u5728\u94fe\u8868\u4e0a\uff0c\u4e14\u4e0d\u4e00\u5b9a\u7ed9\u5b9a\u7684\u8282\u70b9\u4e00\u5b9a\u4f1a\u7ec4\u6210\u4e00\u4e2a\u94fe\u8868\uff0c\u9700\u8981\u7279\u6b8a\u5224\u65ad","title":"\u601d\u8def"},{"location":"pat/linked-list-sorting/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include <iostream> #include <vector> #include <iomanip> #include <algorithm> using namespace std ; const int MaxN = 1e6 + 10 ; struct node { int data {}; int next {}; } l [ MaxN ]; bool cmp ( int a , int b ) { return l [ a ]. data < l [ b ]. data ; } int main () { int N , first ; vector < int > res ; cin >> N >> first ; int address ; for ( int i = 0 ; i < N ; ++ i ) { cin >> address >> l [ address ]. data >> l [ address ]. next ; } while ( first != -1 ) { res . emplace_back ( first ); first = l [ first ]. next ; } if ( res . empty ()) { // \u6709\u6548\u8282\u70b9\u4e3a0 cout << 0 << \" \" << -1 ; return 0 ; } sort ( res . begin (), res . end (), cmp ); cout << res . size () << \" \" << setw ( 5 ) << setfill ( '0' ) << res [ 0 ] << \" \\n \" ; for ( int i = 0 ; i < res . size () - 1 ; ++ i ) cout << setw ( 5 ) << setfill ( '0' ) << res [ i ] << \" \" << l [ res [ i ]]. data << \" \" << setw ( 5 ) << setfill ( '0' ) << res [ i + 1 ] << \" \\n \" ; cout << setw ( 5 ) << setfill ( '0' ) << res [ res . size () - 1 ] << \" \" << l [ res [ res . size () - 1 ]]. data << \" \" << -1 ; return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/mars-numbers/","text":"Mars Numbers \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1100 Mars Numbers (20 point(s)) \u9898\u5e72\u5927\u610f \u00b6 \u7ed9\u5b9a\u89c4\u5219\u7684\u8fdb\u5236\u8f6c\u6362 \u601d\u8def \u00b6 \u8d77\u521d\u6211\u662f\u6253\u7b97\u8f93\u5165\u4e00\u4e2a\u5904\u7406\u4e00\u4e2a\u7684\uff0c\u4f46\u4e0b\u624b\u4e4b\u524d\u770b\u5230\u4e86\u300a\u7b97\u6cd5\u7b14\u8bb0\u300b\u4e2d\u7684\u601d\u8def\uff0c\u76f4\u63a5\u7528 map \u505a\uff08\u56e0\u4e3a\u6570\u636e\u91cf\u4e5f\u4e0d\u5927\uff09\u5b8c\u5168\u53ef\u4ee5\u9884\u5904\u7406\uff0c\u7136\u540e\u540e\u9762\u76f4\u63a5\u67e5\u8be2 AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include <iostream> #include <vector> #include <map> #include <string> using namespace std ; const vector < string > unit = { \"tret\" , \"jan\" , \"feb\" , \"mar\" , \"apr\" , \"may\" , \"jun\" , \"jly\" , \"aug\" , \"sep\" , \"oct\" , \"nov\" , \"dec\" }; //NOLINT const vector < string > ten = { \"tret\" , \"tam\" , \"hel\" , \"maa\" , \"huh\" , \"tou\" , \"kes\" , \"hei\" , \"elo\" , \"syy\" , \"lok\" , \"mer\" , \"jou\" }; //NOLINT int main () { map < string , int > str2num ; map < int , string > num2str ; for ( int i = 0 ; i < 13 ; ++ i ) { num2str [ i ] = unit [ i ]; // \u4e2a\u4f4d\u4e3a[0, 12]\uff0c\u5341\u4f4d\u4e3a0 str2num [ unit [ i ]] = i ; num2str [ i * 13 ] = ten [ i ]; // \u5341\u4f4d\u4e3a[0, 12], \u4e2a\u4f4d\u4e3a9 str2num [ ten [ i ]] = i * 13 ; } for ( int i = 1 ; i < 13 ; ++ i ) { for ( int j = 1 ; j < 13 ; ++ j ) { string str = ten [ i ] + \" \" + unit [ j ]; num2str [ i * 13 + j ] = str ; str2num [ str ] = i * 13 + j ; } } int n ; cin >> n ; cin . get (); while ( n -- ) { string str ; getline ( cin , str ); if ( str [ 0 ] >= '0' && str [ 0 ] <= '9' ) { // \u662f\u6570\u5b57 int num = stoi ( str ); cout << num2str [ num ] << endl ; } else { cout << str2num [ str ] << endl ; } } return 0 ; }","title":"A1100"},{"location":"pat/mars-numbers/#mars-numbers","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1100 Mars Numbers (20 point(s))","title":"Mars Numbers"},{"location":"pat/mars-numbers/#_1","text":"\u7ed9\u5b9a\u89c4\u5219\u7684\u8fdb\u5236\u8f6c\u6362","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/mars-numbers/#_2","text":"\u8d77\u521d\u6211\u662f\u6253\u7b97\u8f93\u5165\u4e00\u4e2a\u5904\u7406\u4e00\u4e2a\u7684\uff0c\u4f46\u4e0b\u624b\u4e4b\u524d\u770b\u5230\u4e86\u300a\u7b97\u6cd5\u7b14\u8bb0\u300b\u4e2d\u7684\u601d\u8def\uff0c\u76f4\u63a5\u7528 map \u505a\uff08\u56e0\u4e3a\u6570\u636e\u91cf\u4e5f\u4e0d\u5927\uff09\u5b8c\u5168\u53ef\u4ee5\u9884\u5904\u7406\uff0c\u7136\u540e\u540e\u9762\u76f4\u63a5\u67e5\u8be2","title":"\u601d\u8def"},{"location":"pat/mars-numbers/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include <iostream> #include <vector> #include <map> #include <string> using namespace std ; const vector < string > unit = { \"tret\" , \"jan\" , \"feb\" , \"mar\" , \"apr\" , \"may\" , \"jun\" , \"jly\" , \"aug\" , \"sep\" , \"oct\" , \"nov\" , \"dec\" }; //NOLINT const vector < string > ten = { \"tret\" , \"tam\" , \"hel\" , \"maa\" , \"huh\" , \"tou\" , \"kes\" , \"hei\" , \"elo\" , \"syy\" , \"lok\" , \"mer\" , \"jou\" }; //NOLINT int main () { map < string , int > str2num ; map < int , string > num2str ; for ( int i = 0 ; i < 13 ; ++ i ) { num2str [ i ] = unit [ i ]; // \u4e2a\u4f4d\u4e3a[0, 12]\uff0c\u5341\u4f4d\u4e3a0 str2num [ unit [ i ]] = i ; num2str [ i * 13 ] = ten [ i ]; // \u5341\u4f4d\u4e3a[0, 12], \u4e2a\u4f4d\u4e3a9 str2num [ ten [ i ]] = i * 13 ; } for ( int i = 1 ; i < 13 ; ++ i ) { for ( int j = 1 ; j < 13 ; ++ j ) { string str = ten [ i ] + \" \" + unit [ j ]; num2str [ i * 13 + j ] = str ; str2num [ str ] = i * 13 + j ; } } int n ; cin >> n ; cin . get (); while ( n -- ) { string str ; getline ( cin , str ); if ( str [ 0 ] >= '0' && str [ 0 ] <= '9' ) { // \u662f\u6570\u5b57 int num = stoi ( str ); cout << num2str [ num ] << endl ; } else { cout << str2num [ str ] << endl ; } } return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/mice-and-rice/","text":"Mice and Rice \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1056 Mice and Rice (25 point(s)) \u9898\u5e72\u5927\u610f \u00b6 \u664b\u7ea7\u5f0f\u6bd4\u8d5b\uff0c\u7ed9\u51fa\u6bcf\u4e2a\u9009\u624b\uff08\u8001\u9f20\uff09\u6700\u7ec8\u7684\u6392\u540d\u3002 \u601d\u8def \u00b6 \u6ce8\u610f\u26a0\ufe0f\uff1a\u9898\u76ee\u4e2d\u7ed9\u7684\u987a\u5e8f\u662f\u53c2\u8d5b\u987a\u5e8f\u7684\u9009\u624b\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9009\u624b\u7684\u53c2\u8d5b\u987a\u5e8f\uff0c\uff0c\uff0c \u53c2\u8003\u300a\u7b97\u6cd5\u7b14\u8bb0\u300b\u505a\u7684\u65f6\u5019\u8111\u5b50\u5f88\u6df7\u4e71\uff0c\u4e0d\u6e05\u6670 \u5173\u952e\u5728\u4e8e\u627e\u5230\uff0c\u7ec4\u6570\u4e0e\u6700\u7ec8\u6392\u540d\u7684\u5173\u7cfb\uff0c\u5982\u9898\u76ee\u4e2d\u7ed9\u768411\u4e2a\u8001\u9f20\uff0c\u7b2c\u4e00\u8f6e\u67094\u7ec4\uff0c\u5219\u5728\u7b2c\u4e00\u8f6e\u4e2d\u6dd8\u6c70\u4e0b\u6765\u7684\u8001\u9f20\u7684\u6392\u540d\u5c31\u662f5\uff084+1\uff09\uff0c\u7b2c\u4e8c\u8f6e\u67094\u4e2a\u8001\u9f20\u53c2\u8d5b\uff0c\u7ec4\u6570\u662f2\uff0c\u5219\u6dd8\u6c70\u4e0b\u6765\u7684\u989d\u6392\u540d\u5c31\u662f3\uff082+1\uff09\uff0c\u7b2c\u4e09\u8f6e\u67092\u4e24\u4e2a\u8001\u9f20\u53c2\u8d5b\uff0c\u5219\u6dd8\u6c70\u4e0b\u6765\u7684\u5c31\u662f\u6392\u540d\u4e3a2\u3002 AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include <queue> #include <iostream> #include <utility> using namespace std ; int main () { int p , g ; cin >> p >> g ; pair < int , int > mice [ p ]; for ( int i = 0 ; i < p ; ++ i ) cin >> mice [ i ]. first ; queue < int > q ; for ( int i = 0 ; i < p ; ++ i ) { int x ; cin >> x ; q . push ( x ); } int temp = p , group ; // \u5f53\u524d\u53c2\u52a0\u7684\u8001\u9f20\u6570\u548c\u7ec4\u6570 while ( q . size () != 1 ) { if ( temp % g == 0 ) group = temp / g ; else group = temp / g + 1 ; for ( int i = 0 ; i < group ; ++ i ) { int max = q . front (); for ( int j = 0 ; j < g ; ++ j ) { if ( i * g + j >= temp ) break ; int front = q . front (); if ( mice [ front ]. first > mice [ max ]. first ) max = front ; mice [ front ]. second = group + 1 ; q . pop (); } q . push ( max ); } temp = group ; } mice [ q . front ()]. second = 1 ; for ( int i = 0 ; i < p ; ++ i ) { cout << mice [ i ]. second ; if ( i < p - 1 ) cout << \" \" ; } return 0 ; }","title":"A1056"},{"location":"pat/mice-and-rice/#mice-and-rice","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1056 Mice and Rice (25 point(s))","title":"Mice and Rice"},{"location":"pat/mice-and-rice/#_1","text":"\u664b\u7ea7\u5f0f\u6bd4\u8d5b\uff0c\u7ed9\u51fa\u6bcf\u4e2a\u9009\u624b\uff08\u8001\u9f20\uff09\u6700\u7ec8\u7684\u6392\u540d\u3002","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/mice-and-rice/#_2","text":"\u6ce8\u610f\u26a0\ufe0f\uff1a\u9898\u76ee\u4e2d\u7ed9\u7684\u987a\u5e8f\u662f\u53c2\u8d5b\u987a\u5e8f\u7684\u9009\u624b\u4e0b\u6807\uff0c\u800c\u4e0d\u662f\u9009\u624b\u7684\u53c2\u8d5b\u987a\u5e8f\uff0c\uff0c\uff0c \u53c2\u8003\u300a\u7b97\u6cd5\u7b14\u8bb0\u300b\u505a\u7684\u65f6\u5019\u8111\u5b50\u5f88\u6df7\u4e71\uff0c\u4e0d\u6e05\u6670 \u5173\u952e\u5728\u4e8e\u627e\u5230\uff0c\u7ec4\u6570\u4e0e\u6700\u7ec8\u6392\u540d\u7684\u5173\u7cfb\uff0c\u5982\u9898\u76ee\u4e2d\u7ed9\u768411\u4e2a\u8001\u9f20\uff0c\u7b2c\u4e00\u8f6e\u67094\u7ec4\uff0c\u5219\u5728\u7b2c\u4e00\u8f6e\u4e2d\u6dd8\u6c70\u4e0b\u6765\u7684\u8001\u9f20\u7684\u6392\u540d\u5c31\u662f5\uff084+1\uff09\uff0c\u7b2c\u4e8c\u8f6e\u67094\u4e2a\u8001\u9f20\u53c2\u8d5b\uff0c\u7ec4\u6570\u662f2\uff0c\u5219\u6dd8\u6c70\u4e0b\u6765\u7684\u989d\u6392\u540d\u5c31\u662f3\uff082+1\uff09\uff0c\u7b2c\u4e09\u8f6e\u67092\u4e24\u4e2a\u8001\u9f20\u53c2\u8d5b\uff0c\u5219\u6dd8\u6c70\u4e0b\u6765\u7684\u5c31\u662f\u6392\u540d\u4e3a2\u3002","title":"\u601d\u8def"},{"location":"pat/mice-and-rice/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include <queue> #include <iostream> #include <utility> using namespace std ; int main () { int p , g ; cin >> p >> g ; pair < int , int > mice [ p ]; for ( int i = 0 ; i < p ; ++ i ) cin >> mice [ i ]. first ; queue < int > q ; for ( int i = 0 ; i < p ; ++ i ) { int x ; cin >> x ; q . push ( x ); } int temp = p , group ; // \u5f53\u524d\u53c2\u52a0\u7684\u8001\u9f20\u6570\u548c\u7ec4\u6570 while ( q . size () != 1 ) { if ( temp % g == 0 ) group = temp / g ; else group = temp / g + 1 ; for ( int i = 0 ; i < group ; ++ i ) { int max = q . front (); for ( int j = 0 ; j < g ; ++ j ) { if ( i * g + j >= temp ) break ; int front = q . front (); if ( mice [ front ]. first > mice [ max ]. first ) max = front ; mice [ front ]. second = group + 1 ; q . pop (); } q . push ( max ); } temp = group ; } mice [ q . front ()]. second = 1 ; for ( int i = 0 ; i < p ; ++ i ) { cout << mice [ i ]. second ; if ( i < p - 1 ) cout << \" \" ; } return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/password/","text":"Password \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1035 Password (20 point(s)) \u9898\u5e72\u5927\u610f \u00b6 \u6309\u7167\u89c4\u5219\uff1a 1->@, 0->%, l->L, O->o \u4fee\u6539\u5bc6\u7801 \u601d\u8def \u00b6 \u8bbe\u7f6e\u6807\u5fd7\uff0c\u8868\u793a\u662f\u5426\u6709\u4fee\u6539\uff0c\u4fee\u6539\u540e\u7684\u5b58\u50a8\u5728\u53e6\u4e00\u4e2a vector \u4e2d AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include <iostream> #include <vector> using namespace std ; struct User { string name ; string passwd ; User ( string s1 , string s2 ) : name ( s1 ), passwd ( s2 ) {} }; bool scan ( User & user ) { bool modified = false ; for ( auto & s : user . passwd ) { switch ( s ) { case 'l' : s = 'L' ; modified = true ; break ; case '0' : s = '%' ; modified = true ; break ; case '1' : s = '@' ; modified = true ; break ; case 'O' : s = 'o' ; modified = true ; break ; default : break ; } } return modified ; } int main () { int n ; cin >> n ; vector < User > users ; while ( n -- ) { string t_name , t_passwd ; cin >> t_name >> t_passwd ; users . emplace_back ( t_name , t_passwd ); } vector < User > ans ; for ( auto & user : users ) { if ( scan ( user )) { ans . emplace_back ( user ); } } if ( ans . size () == 0 ) { cout << \"There \" << ( users . size () > 1 ? \"are \" : \"is \" ) << users . size () << \" account\" << ( users . size () > 1 ? \"s \" : \" \" ) << \"and no account is modified\" ; } else { cout << ans . size () << endl ; for ( auto & u : ans ) { cout << u . name << \" \" << u . passwd ; if ( & u != & ans . back ()) cout << endl ; } } return 0 ; }","title":"A1035"},{"location":"pat/password/#password","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1035 Password (20 point(s))","title":"Password"},{"location":"pat/password/#_1","text":"\u6309\u7167\u89c4\u5219\uff1a 1->@, 0->%, l->L, O->o \u4fee\u6539\u5bc6\u7801","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/password/#_2","text":"\u8bbe\u7f6e\u6807\u5fd7\uff0c\u8868\u793a\u662f\u5426\u6709\u4fee\u6539\uff0c\u4fee\u6539\u540e\u7684\u5b58\u50a8\u5728\u53e6\u4e00\u4e2a vector \u4e2d","title":"\u601d\u8def"},{"location":"pat/password/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include <iostream> #include <vector> using namespace std ; struct User { string name ; string passwd ; User ( string s1 , string s2 ) : name ( s1 ), passwd ( s2 ) {} }; bool scan ( User & user ) { bool modified = false ; for ( auto & s : user . passwd ) { switch ( s ) { case 'l' : s = 'L' ; modified = true ; break ; case '0' : s = '%' ; modified = true ; break ; case '1' : s = '@' ; modified = true ; break ; case 'O' : s = 'o' ; modified = true ; break ; default : break ; } } return modified ; } int main () { int n ; cin >> n ; vector < User > users ; while ( n -- ) { string t_name , t_passwd ; cin >> t_name >> t_passwd ; users . emplace_back ( t_name , t_passwd ); } vector < User > ans ; for ( auto & user : users ) { if ( scan ( user )) { ans . emplace_back ( user ); } } if ( ans . size () == 0 ) { cout << \"There \" << ( users . size () > 1 ? \"are \" : \"is \" ) << users . size () << \" account\" << ( users . size () > 1 ? \"s \" : \" \" ) << \"and no account is modified\" ; } else { cout << ans . size () << endl ; for ( auto & u : ans ) { cout << u . name << \" \" << u . passwd ; if ( & u != & ans . back ()) cout << endl ; } } return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/pop-sequence/","text":"Pop Sequence \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1051 Pop Sequence (25 point(s)) \u9898\u5e72\u5927\u610f \u00b6 \u68c0\u6d4b\u7ed9\u5b9a\u7684\u6808\u8f93\u51fa\u5e8f\u5217\u662f\u5426\u662f\u6b63\u786e\u7684\u6808\u8f93\u51fa\u5e8f\u5217 \u601d\u8def \u00b6 \u6839\u636e\u8f93\u5165\u5e8f\u5217\uff0c\u6a21\u62df\u6808\u6df7\u6d17\uff0c\u6700\u7ec8\u8f85\u52a9\u6808\u7a7a\u5219\u662f\u6b63\u786e\u7684 AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include <stack> #include <iostream> #include <vector> using namespace std ; int main () { int M , N , K ; cin >> M >> N >> K ; while ( K -- ) { vector < int > pop ; for ( int i = 0 ; i < N ; ++ i ) { int x ; cin >> x ; pop . emplace_back ( x ); } stack < int > s ; bool status = true ; // \u5224\u65ad\u5728\u6a21\u62df\u8fc7\u7a0b\u4e2d\u662f\u5426\u8f85\u52a9\u6808\u7684\u5927\u5c0f\u8d85\u8fc7\u4e86M int j = 0 ; for ( int i = 0 ; i < N ;) { if ( s . empty ()) { // \u6808\u7a7a\u65f6\uff0c\u76f4\u63a5\u5165 s . push ( ++ i ); continue ; } if ( s . top () != pop [ j ]) { // \u5f53\u6b64\u65f6\u6808\u9876\u5143\u7d20\u4e0d\u7b49\u4e8e\u8981\u8f93\u51fa\u7684\u5143\u7d20\u65f6\uff0c\u5165\u6808 if ( s . size () == M ) { // \u5982\u679c\u8d85\u8fc7\u4e86\u8bbe\u5b9a\u5927\u5c0fM\uff0c\u76f4\u63a5\u9000\u51fa\uff0c\u8f93\u51faNO status = false ; break ; } s . push ( ++ i ); } else { // \u6b64\u65f6\u76f8\u7b49\uff0c\u5faa\u73af\u51fa\u6808\uff08\u6ee1\u8db3\uff0c\u6808\u9876=pop[j] while ( ! s . empty () && s . top () == pop [ j ]) { s . pop (); ++ j ; } } } while ( ! s . empty () && s . top () == pop [ j ]) { // \u7531\u4e8e\u6700\u540e\u4e00\u4e2a\u503c\u4e3aN\u7684\u5143\u7d20\u5165\u6808\u540e\uff0c\u5728for\u5faa\u73af\u4e2d\u6ca1\u6709\u68c0\u67e5\uff0c\u6240\u4ee5\u5728\u6b64\u68c0\u67e5 s . pop (); ++ j ; } if ( s . empty () && status ) // \u5982\u679c\u6ca1\u6709\u8d85\u8fc7M\u4e14\u6700\u7ec8\u6808\u7a7a\uff0c\u5219\u8f93\u51fayes cout << \"YES\" ; else cout << \"NO\" ; if ( K ) cout << \" \\n \" ; } return 0 ; }","title":"A1051"},{"location":"pat/pop-sequence/#pop-sequence","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1051 Pop Sequence (25 point(s))","title":"Pop Sequence"},{"location":"pat/pop-sequence/#_1","text":"\u68c0\u6d4b\u7ed9\u5b9a\u7684\u6808\u8f93\u51fa\u5e8f\u5217\u662f\u5426\u662f\u6b63\u786e\u7684\u6808\u8f93\u51fa\u5e8f\u5217","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/pop-sequence/#_2","text":"\u6839\u636e\u8f93\u5165\u5e8f\u5217\uff0c\u6a21\u62df\u6808\u6df7\u6d17\uff0c\u6700\u7ec8\u8f85\u52a9\u6808\u7a7a\u5219\u662f\u6b63\u786e\u7684","title":"\u601d\u8def"},{"location":"pat/pop-sequence/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include <stack> #include <iostream> #include <vector> using namespace std ; int main () { int M , N , K ; cin >> M >> N >> K ; while ( K -- ) { vector < int > pop ; for ( int i = 0 ; i < N ; ++ i ) { int x ; cin >> x ; pop . emplace_back ( x ); } stack < int > s ; bool status = true ; // \u5224\u65ad\u5728\u6a21\u62df\u8fc7\u7a0b\u4e2d\u662f\u5426\u8f85\u52a9\u6808\u7684\u5927\u5c0f\u8d85\u8fc7\u4e86M int j = 0 ; for ( int i = 0 ; i < N ;) { if ( s . empty ()) { // \u6808\u7a7a\u65f6\uff0c\u76f4\u63a5\u5165 s . push ( ++ i ); continue ; } if ( s . top () != pop [ j ]) { // \u5f53\u6b64\u65f6\u6808\u9876\u5143\u7d20\u4e0d\u7b49\u4e8e\u8981\u8f93\u51fa\u7684\u5143\u7d20\u65f6\uff0c\u5165\u6808 if ( s . size () == M ) { // \u5982\u679c\u8d85\u8fc7\u4e86\u8bbe\u5b9a\u5927\u5c0fM\uff0c\u76f4\u63a5\u9000\u51fa\uff0c\u8f93\u51faNO status = false ; break ; } s . push ( ++ i ); } else { // \u6b64\u65f6\u76f8\u7b49\uff0c\u5faa\u73af\u51fa\u6808\uff08\u6ee1\u8db3\uff0c\u6808\u9876=pop[j] while ( ! s . empty () && s . top () == pop [ j ]) { s . pop (); ++ j ; } } } while ( ! s . empty () && s . top () == pop [ j ]) { // \u7531\u4e8e\u6700\u540e\u4e00\u4e2a\u503c\u4e3aN\u7684\u5143\u7d20\u5165\u6808\u540e\uff0c\u5728for\u5faa\u73af\u4e2d\u6ca1\u6709\u68c0\u67e5\uff0c\u6240\u4ee5\u5728\u6b64\u68c0\u67e5 s . pop (); ++ j ; } if ( s . empty () && status ) // \u5982\u679c\u6ca1\u6709\u8d85\u8fc7M\u4e14\u6700\u7ec8\u6808\u7a7a\uff0c\u5219\u8f93\u51fayes cout << \"YES\" ; else cout << \"NO\" ; if ( K ) cout << \" \\n \" ; } return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/product-of-polynomials/","text":"Product of Polynomials \u00b6 \u9898\u76ee\u94fe\u63a5 1009 Product of Polynomials (25 \u5206) \u9898\u5e72\u5927\u610f \u00b6 \u591a\u9879\u5f0f\u4e58\u6cd5\u5b9e\u73b0\uff0c\u5e38\u89c4 \u601d\u8def \u00b6 \u4e00\u4e2a\u5411\u91cf\u5b58\u7b2c\u4e00\u4e2a\u591a\u9879\u5f0f\uff0c\u540e\u9762\u4e00\u4e2a\u591a\u9879\u5f0f\u8fb9\u8bfb\u8fb9\u8ba1\u7b97\u5373\u53ef AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include <iostream> #include <vector> #include <iomanip> using namespace std ; void calc ( vector < double > & res , const vector < int > & index , const vector < double > & value , const int a , const double b ) { for ( auto it = index . begin (); it != index . end (); ++ it ) res [ a + * it ] += b * value [ it - index . begin ()]; } int main () { int k , a ; double b ; vector < int > index ; vector < double > value , res ( 2001 ); cin >> k ; for ( auto i = 0 ; i < k ; ++ i ) { cin >> a >> b ; index . push_back ( a ); value . push_back ( b ); } cin >> k ; for ( auto i = 0 ; i < k ; ++ i ) { cin >> a >> b ; calc ( res , index , value , a , b ); } int count = 0 ; for ( auto & p : res ) if ( p != 0.0 ) ++ count ; cout << count ; for ( auto it = res . end () - 1 ; it >= res . begin (); -- it ) if ( * it != 0.0 ) cout << \" \" << it - res . begin () << \" \" << setiosflags ( ios :: fixed ) << setprecision ( 1 ) << * it ; return 0 ; }","title":"A1009"},{"location":"pat/product-of-polynomials/#product-of-polynomials","text":"\u9898\u76ee\u94fe\u63a5 1009 Product of Polynomials (25 \u5206)","title":"Product of Polynomials"},{"location":"pat/product-of-polynomials/#_1","text":"\u591a\u9879\u5f0f\u4e58\u6cd5\u5b9e\u73b0\uff0c\u5e38\u89c4","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/product-of-polynomials/#_2","text":"\u4e00\u4e2a\u5411\u91cf\u5b58\u7b2c\u4e00\u4e2a\u591a\u9879\u5f0f\uff0c\u540e\u9762\u4e00\u4e2a\u591a\u9879\u5f0f\u8fb9\u8bfb\u8fb9\u8ba1\u7b97\u5373\u53ef","title":"\u601d\u8def"},{"location":"pat/product-of-polynomials/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include <iostream> #include <vector> #include <iomanip> using namespace std ; void calc ( vector < double > & res , const vector < int > & index , const vector < double > & value , const int a , const double b ) { for ( auto it = index . begin (); it != index . end (); ++ it ) res [ a + * it ] += b * value [ it - index . begin ()]; } int main () { int k , a ; double b ; vector < int > index ; vector < double > value , res ( 2001 ); cin >> k ; for ( auto i = 0 ; i < k ; ++ i ) { cin >> a >> b ; index . push_back ( a ); value . push_back ( b ); } cin >> k ; for ( auto i = 0 ; i < k ; ++ i ) { cin >> a >> b ; calc ( res , index , value , a , b ); } int count = 0 ; for ( auto & p : res ) if ( p != 0.0 ) ++ count ; cout << count ; for ( auto it = res . end () - 1 ; it >= res . begin (); -- it ) if ( * it != 0.0 ) cout << \" \" << it - res . begin () << \" \" << setiosflags ( ios :: fixed ) << setprecision ( 1 ) << * it ; return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/read-number-in-chinese/","text":"Read Number in Chinese \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1082 Read Number in Chinese (25 point(s)) \u9898\u5e72\u5927\u610f \u00b6 \u4ee5\u4e2d\u6587\u7684\u4e60\u60ef\u8bfb\u51fa\u6570\u5b57\u3002 \u601d\u8def \u00b6 \u53c2\u8003\u4e86\u300a\u7b97\u6cd5\u7b14\u8bb0\u300b\u8fd9\u672c\u4e66\u3002 \u7531\u4e8e\u4e2d\u6587\u4e2d\uff0c\u6709\u4ebf\u3001\u4e07\uff0c\u5728\u4e07\u4e2d\u53c8\u6709\u5343\u3001\u767e\u3001\u5341\uff0c\u6545\u6bcf\u56db\u4e2a\u4e00\u7ec4\u5904\u7406\u3002\u5176\u4e2d\u9700\u8981\u7279\u522b\u6ce8\u610f\u7684\u662f\u7a7a\u683c\u7684\u8f93\u51fa\uff0c\u5148\u8f93\u51fa\u7a7a\u683c\u5728\u8f93\u51fa\u5b57\u7b26\u4e32\u6bd4\u8f83\u597d\u3002 AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include <iostream> #include <vector> using namespace std ; const char nums [ 10 ][ 5 ] = { \"ling\" , \"yi\" , \"er\" , \"san\" , \"si\" , \"wu\" , \"liu\" , \"qi\" , \"ba\" , \"jiu\" }; const char wei [ 5 ][ 5 ] = { \"Shi\" , \"Bai\" , \"Qian\" , \"Wan\" , \"Yi\" }; int main () { int n ; cin >> n ; string ans = to_string ( n ); int left = 0 , right = ans . length (); if ( n < 0 ) { cout << \"Fu\" ; ++ left ; } // \u6211\u7684\u89c4\u8303\uff1a\u4e00\u7ec4\u7684\u4e0b\u6807\u8303\u56f4\u4e3a [left, right) while ( right - left > 4 ) right -= 4 ; while ( left < ans . length ()) { bool flag = false ; // \u8868\u793a\u4e00\u7ec4\u4e2d\u662f\u5426\u542b\u67090 bool group = false ; // \u8868\u793a\u8be5\u7ec4\u662f\u5426\u6709\u6570 while ( left < right ) { // \u5904\u7406\u6bcf\u4e00\u7ec4 if ( left > 0 && ans [ left ] == '0' ) flag = true ; else { if ( flag ) { // \u4e00\u7ec4\u4e2d\u5b58\u57280\uff0c \u8f93\u51fa0\u5373\u5904\u7406\u5b8c\u6bd5 cout << \" ling\" ; flag = false ; } if ( n > 0 && left != 0 '' n < 0 ) cout << \" \" ; cout << nums [ ans [ left ] - '0' ]; group = true ; // \u8868\u793a\u8be5\u7ec4\u6709\u6570 if ( left != right - 1 ) { cout << \" \" << wei [ right - left - 2 ]; } } ++ left ; } if ( group && right != ans . length ()) { cout << \" \" << wei [( ans . length () - right ) / 4 + 2 ]; } right += 4 ; } return 0 ; }","title":"A1082"},{"location":"pat/read-number-in-chinese/#read-number-in-chinese","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1082 Read Number in Chinese (25 point(s))","title":"Read Number in Chinese"},{"location":"pat/read-number-in-chinese/#_1","text":"\u4ee5\u4e2d\u6587\u7684\u4e60\u60ef\u8bfb\u51fa\u6570\u5b57\u3002","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/read-number-in-chinese/#_2","text":"\u53c2\u8003\u4e86\u300a\u7b97\u6cd5\u7b14\u8bb0\u300b\u8fd9\u672c\u4e66\u3002 \u7531\u4e8e\u4e2d\u6587\u4e2d\uff0c\u6709\u4ebf\u3001\u4e07\uff0c\u5728\u4e07\u4e2d\u53c8\u6709\u5343\u3001\u767e\u3001\u5341\uff0c\u6545\u6bcf\u56db\u4e2a\u4e00\u7ec4\u5904\u7406\u3002\u5176\u4e2d\u9700\u8981\u7279\u522b\u6ce8\u610f\u7684\u662f\u7a7a\u683c\u7684\u8f93\u51fa\uff0c\u5148\u8f93\u51fa\u7a7a\u683c\u5728\u8f93\u51fa\u5b57\u7b26\u4e32\u6bd4\u8f83\u597d\u3002","title":"\u601d\u8def"},{"location":"pat/read-number-in-chinese/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include <iostream> #include <vector> using namespace std ; const char nums [ 10 ][ 5 ] = { \"ling\" , \"yi\" , \"er\" , \"san\" , \"si\" , \"wu\" , \"liu\" , \"qi\" , \"ba\" , \"jiu\" }; const char wei [ 5 ][ 5 ] = { \"Shi\" , \"Bai\" , \"Qian\" , \"Wan\" , \"Yi\" }; int main () { int n ; cin >> n ; string ans = to_string ( n ); int left = 0 , right = ans . length (); if ( n < 0 ) { cout << \"Fu\" ; ++ left ; } // \u6211\u7684\u89c4\u8303\uff1a\u4e00\u7ec4\u7684\u4e0b\u6807\u8303\u56f4\u4e3a [left, right) while ( right - left > 4 ) right -= 4 ; while ( left < ans . length ()) { bool flag = false ; // \u8868\u793a\u4e00\u7ec4\u4e2d\u662f\u5426\u542b\u67090 bool group = false ; // \u8868\u793a\u8be5\u7ec4\u662f\u5426\u6709\u6570 while ( left < right ) { // \u5904\u7406\u6bcf\u4e00\u7ec4 if ( left > 0 && ans [ left ] == '0' ) flag = true ; else { if ( flag ) { // \u4e00\u7ec4\u4e2d\u5b58\u57280\uff0c \u8f93\u51fa0\u5373\u5904\u7406\u5b8c\u6bd5 cout << \" ling\" ; flag = false ; } if ( n > 0 && left != 0 '' n < 0 ) cout << \" \" ; cout << nums [ ans [ left ] - '0' ]; group = true ; // \u8868\u793a\u8be5\u7ec4\u6709\u6570 if ( left != right - 1 ) { cout << \" \" << wei [ right - left - 2 ]; } } ++ left ; } if ( group && right != ans . length ()) { cout << \" \" << wei [( ans . length () - right ) / 4 + 2 ]; } right += 4 ; } return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/reversing-linked-list/","text":"Reversing Linked List \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1074 Reversing Linked List (25 point(s)) \u9898\u5e72\u5927\u610f \u00b6 \u7ffb\u8f6c\u94fe\u8868 \u601d\u8def \u00b6 \u5229\u7528 reverse \u51fd\u6570\u5373\u53ef\u3002\u6ce8\u610f\u559c\u6b22\u4f7f\u7528 cout \u7684\uff0c\u5982\u4f55\u63a7\u5236\u8f93\u51fa\u683c\u5f0f\uff0c\u4ee5\u53ca\u7528 \"\\n\" \u8f93\u51fa\u6362\u884c\u4f1a\u51cf\u5c11\u65f6\u95f4\u3002 AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include <iostream> #include <vector> #include <iomanip> #include <algorithm> using namespace std ; const int MaxN = 1e6 + 10 ; struct node { int data {}; int next {}; } l [ MaxN ]; int main () { int first , N , K ; vector < int > res ; cin >> first >> N >> K ; int address ; for ( int i = 0 ; i < N ; ++ i ) { cin >> address >> l [ address ]. data >> l [ address ]. next ; } while ( first != -1 ) { res . emplace_back ( first ); first = l [ first ]. next ; } for ( int i = 0 ; i + K <= res . size (); i += K ) reverse ( res . begin () + i , res . begin () + i + K ); for ( int i = 0 ; i < res . size () - 1 ; ++ i ) cout << setw ( 5 ) << setfill ( '0' ) << res [ i ] << \" \" << l [ res [ i ]]. data << \" \" << setw ( 5 ) << setfill ( '0' ) << res [ i + 1 ] << \" \\n \" ; cout << setw ( 5 ) << setfill ( '0' ) << res [ res . size () - 1 ] << \" \" << l [ res [ res . size () - 1 ]]. data << \" \" << -1 ; return 0 ; }","title":"A1074"},{"location":"pat/reversing-linked-list/#reversing-linked-list","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1074 Reversing Linked List (25 point(s))","title":"Reversing Linked List"},{"location":"pat/reversing-linked-list/#_1","text":"\u7ffb\u8f6c\u94fe\u8868","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/reversing-linked-list/#_2","text":"\u5229\u7528 reverse \u51fd\u6570\u5373\u53ef\u3002\u6ce8\u610f\u559c\u6b22\u4f7f\u7528 cout \u7684\uff0c\u5982\u4f55\u63a7\u5236\u8f93\u51fa\u683c\u5f0f\uff0c\u4ee5\u53ca\u7528 \"\\n\" \u8f93\u51fa\u6362\u884c\u4f1a\u51cf\u5c11\u65f6\u95f4\u3002","title":"\u601d\u8def"},{"location":"pat/reversing-linked-list/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include <iostream> #include <vector> #include <iomanip> #include <algorithm> using namespace std ; const int MaxN = 1e6 + 10 ; struct node { int data {}; int next {}; } l [ MaxN ]; int main () { int first , N , K ; vector < int > res ; cin >> first >> N >> K ; int address ; for ( int i = 0 ; i < N ; ++ i ) { cin >> address >> l [ address ]. data >> l [ address ]. next ; } while ( first != -1 ) { res . emplace_back ( first ); first = l [ first ]. next ; } for ( int i = 0 ; i + K <= res . size (); i += K ) reverse ( res . begin () + i , res . begin () + i + K ); for ( int i = 0 ; i < res . size () - 1 ; ++ i ) cout << setw ( 5 ) << setfill ( '0' ) << res [ i ] << \" \" << l [ res [ i ]]. data << \" \" << setw ( 5 ) << setfill ( '0' ) << res [ i + 1 ] << \" \\n \" ; cout << setw ( 5 ) << setfill ( '0' ) << res [ res . size () - 1 ] << \" \" << l [ res [ res . size () - 1 ]]. data << \" \" << -1 ; return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/scientific-notation/","text":"Scientific Notation \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1073 Scientific Notation (20 point(s)) \u9898\u5e72\u5927\u610f \u00b6 \u5c06\u79d1\u5b66\u8ba1\u6570\u6cd5\u7684\u6570\u5b57\u8868\u793a\u6210\u6b63\u5e38\u7684\u5f62\u5f0f \u601d\u8def \u00b6 \u9650\u5b9a\u4e3a E \u7684\u4f4d\u7f6e\uff0c\u7136\u540e\u6839\u636e\u6307\u6570\u6b63\u8d1f\u5206\u60c5\u51b5\uff0c\u603b\u7ed3\u89c4\u5f8b AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include <iostream> #include <vector> #include <string> using namespace std ; int main () { string str ; cin >> str ; if ( str [ 0 ] == '-' ) cout << '-' ; int pos = 0 ; while ( str [ pos ] != 'E' ) ++ pos ; int exp = 0 ; // \u8ba1\u7b97\u6307\u6570 for ( int i = pos + 2 ; i < str . length (); ++ i ) { exp = exp * 10 + ( str [ i ] - '0' ); } if ( exp == 0 ) { for ( int i = 1 ; i < pos ; ++ i ) cout << str [ i ]; } if ( str [ pos + 1 ] == '-' ) { cout << \"0.\" ; for ( int i = 0 ; i < exp - 1 ; ++ i ) cout << 0 ; cout << str [ 1 ]; for ( int i = 3 ; i < pos ; ++ i ) cout << str [ i ]; } else { for ( int i = 1 ; i < pos ; ++ i ) { if ( str [ i ] == '.' ) continue ; cout << str [ i ]; if ( i == exp + 2 && pos - 3 != exp ) // 3\u4e3a\u539f\u5c0f\u6570\u70b9\u4f4d\u7f6e cout << \".\" ; } for ( int i = 0 ; i < exp - ( pos - 3 ); ++ i ) cout << 0 ; } return 0 ; }","title":"A1073"},{"location":"pat/scientific-notation/#scientific-notation","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1073 Scientific Notation (20 point(s))","title":"Scientific Notation"},{"location":"pat/scientific-notation/#_1","text":"\u5c06\u79d1\u5b66\u8ba1\u6570\u6cd5\u7684\u6570\u5b57\u8868\u793a\u6210\u6b63\u5e38\u7684\u5f62\u5f0f","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/scientific-notation/#_2","text":"\u9650\u5b9a\u4e3a E \u7684\u4f4d\u7f6e\uff0c\u7136\u540e\u6839\u636e\u6307\u6570\u6b63\u8d1f\u5206\u60c5\u51b5\uff0c\u603b\u7ed3\u89c4\u5f8b","title":"\u601d\u8def"},{"location":"pat/scientific-notation/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include <iostream> #include <vector> #include <string> using namespace std ; int main () { string str ; cin >> str ; if ( str [ 0 ] == '-' ) cout << '-' ; int pos = 0 ; while ( str [ pos ] != 'E' ) ++ pos ; int exp = 0 ; // \u8ba1\u7b97\u6307\u6570 for ( int i = pos + 2 ; i < str . length (); ++ i ) { exp = exp * 10 + ( str [ i ] - '0' ); } if ( exp == 0 ) { for ( int i = 1 ; i < pos ; ++ i ) cout << str [ i ]; } if ( str [ pos + 1 ] == '-' ) { cout << \"0.\" ; for ( int i = 0 ; i < exp - 1 ; ++ i ) cout << 0 ; cout << str [ 1 ]; for ( int i = 3 ; i < pos ; ++ i ) cout << str [ i ]; } else { for ( int i = 1 ; i < pos ; ++ i ) { if ( str [ i ] == '.' ) continue ; cout << str [ i ]; if ( i == exp + 2 && pos - 3 != exp ) // 3\u4e3a\u539f\u5c0f\u6570\u70b9\u4f4d\u7f6e cout << \".\" ; } for ( int i = 0 ; i < exp - ( pos - 3 ); ++ i ) cout << 0 ; } return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/set-similarity/","text":"Set Similarity \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1063 Set Similarity (25 point(s)) \u9898\u5e72\u5927\u610f \u00b6 \u8ba1\u7b97\u4e24\u4e2a\u96c6\u5408\u7684\u76f8\u4f3c\u5ea6\uff0c\u5373\u76f8\u540c\u6570\u5b57\u7684\u4e2a\u6570\u5360\u4e24\u4e2a\u96c6\u5408\u7684\u603b\u96c6\u5408\u7684\u6bd4\u4f8b \u601d\u8def \u00b6 \u660e\u663e\u8981\u6c42\u53bb\u91cd\uff0c\u800c\u4e14\u540e\u9762\u8981\u8ba1\u7b97\u4e24\u4e2a\u96c6\u5408\u7684\u76f8\u540c\u6570\u5b57\u7684\u4e2a\u6570\uff0c\u4e5f\u6697\u542b\u8981\u6392\u5e8f\uff08\u4e0d\u7136\u590d\u6742\u5ea6\u592a\u9ad8\uff09\uff0c\u6240\u4ee5\u9009\u7528 set \u8fdb\u884c\u5b58\u50a8\uff0c\u5176\u4ed6\u5c31\u5f88\u5e38\u89c4\u3002 \u518d\u6b21\u56de\u987e\u4e00\u4e0b\uff0c cout \u63a7\u5236\u8f93\u51fa\u7684\u683c\u5f0f\u8bed\u53e5 #include <iomanip> // \u5934\u6587\u4ef6 using namespace std; cout << setiosflags(ios::fixed) << setprecision(n); // n\u4e3a\u8981\u6c42\u7684\u7cbe\u5ea6 AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include <iostream> #include <vector> #include <iomanip> #include <set> using namespace std ; int count ( set < int > a , set < int > b ) { auto it1 = a . begin (), it2 = b . begin (); int cnt = 0 ; while ( it1 != a . end () && it2 != b . end ()) { if ( * it1 == * it2 ) { ++ cnt ; ++ it1 ; ++ it2 ; } else if ( * it1 < * it2 ) ++ it1 ; else ++ it2 ; } return cnt ; } int main () { int N ; cin >> N ; vector < set < int >> set ( N + 1 ); for ( int i = 1 ; i <= N ; ++ i ) { int M ; cin >> M ; while ( M -- ) { int num ; cin >> num ; set [ i ]. insert ( num ); } } int K ; cin >> K ; cout << setiosflags ( ios :: fixed ) << setprecision ( 1 ); while ( K -- ) { int a , b ; cin >> a >> b ; int cnt = count ( set [ a ], set [ b ]); cout << cnt / double ( set [ a ]. size () + set [ b ]. size () - cnt ) * 100 << \"% \\n \" ; } return 0 ; }","title":"A1063"},{"location":"pat/set-similarity/#set-similarity","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1063 Set Similarity (25 point(s))","title":"Set Similarity"},{"location":"pat/set-similarity/#_1","text":"\u8ba1\u7b97\u4e24\u4e2a\u96c6\u5408\u7684\u76f8\u4f3c\u5ea6\uff0c\u5373\u76f8\u540c\u6570\u5b57\u7684\u4e2a\u6570\u5360\u4e24\u4e2a\u96c6\u5408\u7684\u603b\u96c6\u5408\u7684\u6bd4\u4f8b","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/set-similarity/#_2","text":"\u660e\u663e\u8981\u6c42\u53bb\u91cd\uff0c\u800c\u4e14\u540e\u9762\u8981\u8ba1\u7b97\u4e24\u4e2a\u96c6\u5408\u7684\u76f8\u540c\u6570\u5b57\u7684\u4e2a\u6570\uff0c\u4e5f\u6697\u542b\u8981\u6392\u5e8f\uff08\u4e0d\u7136\u590d\u6742\u5ea6\u592a\u9ad8\uff09\uff0c\u6240\u4ee5\u9009\u7528 set \u8fdb\u884c\u5b58\u50a8\uff0c\u5176\u4ed6\u5c31\u5f88\u5e38\u89c4\u3002 \u518d\u6b21\u56de\u987e\u4e00\u4e0b\uff0c cout \u63a7\u5236\u8f93\u51fa\u7684\u683c\u5f0f\u8bed\u53e5 #include <iomanip> // \u5934\u6587\u4ef6 using namespace std; cout << setiosflags(ios::fixed) << setprecision(n); // n\u4e3a\u8981\u6c42\u7684\u7cbe\u5ea6","title":"\u601d\u8def"},{"location":"pat/set-similarity/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include <iostream> #include <vector> #include <iomanip> #include <set> using namespace std ; int count ( set < int > a , set < int > b ) { auto it1 = a . begin (), it2 = b . begin (); int cnt = 0 ; while ( it1 != a . end () && it2 != b . end ()) { if ( * it1 == * it2 ) { ++ cnt ; ++ it1 ; ++ it2 ; } else if ( * it1 < * it2 ) ++ it1 ; else ++ it2 ; } return cnt ; } int main () { int N ; cin >> N ; vector < set < int >> set ( N + 1 ); for ( int i = 1 ; i <= N ; ++ i ) { int M ; cin >> M ; while ( M -- ) { int num ; cin >> num ; set [ i ]. insert ( num ); } } int K ; cin >> K ; cout << setiosflags ( ios :: fixed ) << setprecision ( 1 ); while ( K -- ) { int a , b ; cin >> a >> b ; int cnt = count ( set [ a ], set [ b ]); cout << cnt / double ( set [ a ]. size () + set [ b ]. size () - cnt ) * 100 << \"% \\n \" ; } return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/sharing/","text":"Sharing \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1032 Sharing (25 point(s)) \u9898\u5e72\u5927\u610f \u00b6 \u5355\u8bcd\u4e2d\u7684\u5b57\u6bcd\u7531\u94fe\u8868\u6307\u89c6\uff0c\u516c\u5171\u5b57\u6bcd\u516c\u7528\uff0c\u627e\u51fa\u7b2c\u4e00\u4e2a\u516c\u5171\u5b57\u6bcd\u7684\u5730\u5740 \u601d\u8def \u00b6 \u5148\u904d\u5386\u4e00\u4e2a\u5355\u8bcd\uff0c\u5c06\u5176\u4e2d\u7684\u5b57\u6bcd\u8bbe\u4e3a\u5df2\u88ab\u8bbf\u95ee\u7684\u72b6\u6001\uff0c\u7136\u540e\u904d\u5386\u53e6\u4e00\u4e2a\u5355\u8bcd\uff0c\u5f53\u78b0\u5230\u5df2\u88ab\u8bbf\u95ee\u7684\u5b57\u6bcd\u65f6\u8868\u660e\uff0c\u5f53\u524d\u7684\u5b57\u6bcd\u5373\u4e3a\u6240\u6c42\u5b57\u6bcd AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <iostream> #include <iomanip> using namespace std ; struct node { int next {}; bool status = false ; } l [ 100010 ]; int main () { int s1 , s2 , n ; cin >> s1 >> s2 >> n ; int address , next ; char c ; for ( int i = 0 ; i < n ; ++ i ) { cin >> address >> c >> next ; l [ address ]. next = next ; } int p ; for ( p = s1 ; p != -1 ; p = l [ p ]. next ) l [ p ]. status = true ; for ( p = s2 ; p != -1 ; p = l [ p ]. next ) if ( l [ p ]. status ) break ; if ( p == -1 ) cout << -1 ; else cout << setw ( 5 ) << setfill ( '0' ) << p ; return 0 ; }","title":"A1032"},{"location":"pat/sharing/#sharing","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1032 Sharing (25 point(s))","title":"Sharing"},{"location":"pat/sharing/#_1","text":"\u5355\u8bcd\u4e2d\u7684\u5b57\u6bcd\u7531\u94fe\u8868\u6307\u89c6\uff0c\u516c\u5171\u5b57\u6bcd\u516c\u7528\uff0c\u627e\u51fa\u7b2c\u4e00\u4e2a\u516c\u5171\u5b57\u6bcd\u7684\u5730\u5740","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/sharing/#_2","text":"\u5148\u904d\u5386\u4e00\u4e2a\u5355\u8bcd\uff0c\u5c06\u5176\u4e2d\u7684\u5b57\u6bcd\u8bbe\u4e3a\u5df2\u88ab\u8bbf\u95ee\u7684\u72b6\u6001\uff0c\u7136\u540e\u904d\u5386\u53e6\u4e00\u4e2a\u5355\u8bcd\uff0c\u5f53\u78b0\u5230\u5df2\u88ab\u8bbf\u95ee\u7684\u5b57\u6bcd\u65f6\u8868\u660e\uff0c\u5f53\u524d\u7684\u5b57\u6bcd\u5373\u4e3a\u6240\u6c42\u5b57\u6bcd","title":"\u601d\u8def"},{"location":"pat/sharing/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <iostream> #include <iomanip> using namespace std ; struct node { int next {}; bool status = false ; } l [ 100010 ]; int main () { int s1 , s2 , n ; cin >> s1 >> s2 >> n ; int address , next ; char c ; for ( int i = 0 ; i < n ; ++ i ) { cin >> address >> c >> next ; l [ address ]. next = next ; } int p ; for ( p = s1 ; p != -1 ; p = l [ p ]. next ) l [ p ]. status = true ; for ( p = s2 ; p != -1 ; p = l [ p ]. next ) if ( l [ p ]. status ) break ; if ( p == -1 ) cout << -1 ; else cout << setw ( 5 ) << setfill ( '0' ) << p ; return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/shortest-distance/","text":"Shortest Distance \u00b6 \u9898\u5e72\u5927\u610f \u00b6 \u5728\u4e00\u4e2aloop\u4e2d\uff0c\u627e\u4e24\u70b9\u7684\u6700\u77ed\u8ddd\u79bb \u601d\u8def \u00b6 \u5728\u8f93\u5165\u65f6\uff0c\u5c31\u8ba1\u7b97\u51fa\u6240\u6709\u8ddd\u79bb\u7684\u548c sum \uff0c\u7531\u4e8e\u672c\u9898\u76ee\u70b9\u4e2a\u6570\u6700\u5927\u4e3a \\(10^5\\) \uff0c\u67e5\u8be2\u7684\u7ec4\u6570\u6700\u5927\u4e3a \\(10^4\\) \u91cf\u7ea7\uff0c\u6240\u4ee5\u6309\u7167\u6765\u4e00\u7ec4\u67e5\u4e00\u6b21\u7684\u65b9\u5f0f\u5f88\u5bb9\u6613\u8d85\u65f6\uff0c\u6240\u4ee5\u5728\u8f93\u5165\u65f6\u5c31**\u6309\u987a\u65f6\u9488\u65b9\u5411\u7684\u9488\u5bf9\u4e00\u4e2a\u57fa\u70b9\u7684\u8ddd\u79bb distance **\uff0c\u4ee5\u7a7a\u95f4\u6362\u65f6\u95f4\uff0c\u5c31\u5f88nice \u95ee\u9898 \u00b6 \u592a\u4e45\u6ca1\u7528c\u4e86\uff0c\u4e00\u53ea\u7528c++\uff0c\u90fd\u5fd8\u8bb0 scanf \u4e2d\u662f\u8981\u5199\u53d8\u91cf\u5730\u5740\u7684\ud83d\ude05\uff0c\u771f\u5c34\u5c2c\uff0c \u66f4\u65b0\u7528c++\u5199 AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <iostream> #include <vector> #include <algorithm> using namespace std ; int main () { int N ; cin >> N ; vector < int > D ( N ), distance ; //distance[i]\u8868\u793a\u4ece\u4e0b\u6807\u4e3a0\u5230\u4e0b\u6807\u4e3ai\u7684\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb distance . push_back ( 0 ); int sum = 0 ; for ( auto i = 0 ; i != N ; ++ i ){ cin >> D [ i ]; if ( i ) distance . push_back ( sum ); sum += D [ i ]; } int M , a , b ; cin >> M ; while ( M -- ){ cin >> a >> b ; if ( a > b ) swap ( a , b ); //\u5e8f\u53f7\u53d8\u4e3a\u4e0b\u6807 auto temp = distance [ b - 1 ] - distance [ a - 1 ]; cout << min ( temp , sum - temp ) << endl ; } return 0 ; }","title":"A1046"},{"location":"pat/shortest-distance/#shortest-distance","text":"","title":"Shortest Distance"},{"location":"pat/shortest-distance/#_1","text":"\u5728\u4e00\u4e2aloop\u4e2d\uff0c\u627e\u4e24\u70b9\u7684\u6700\u77ed\u8ddd\u79bb","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/shortest-distance/#_2","text":"\u5728\u8f93\u5165\u65f6\uff0c\u5c31\u8ba1\u7b97\u51fa\u6240\u6709\u8ddd\u79bb\u7684\u548c sum \uff0c\u7531\u4e8e\u672c\u9898\u76ee\u70b9\u4e2a\u6570\u6700\u5927\u4e3a \\(10^5\\) \uff0c\u67e5\u8be2\u7684\u7ec4\u6570\u6700\u5927\u4e3a \\(10^4\\) \u91cf\u7ea7\uff0c\u6240\u4ee5\u6309\u7167\u6765\u4e00\u7ec4\u67e5\u4e00\u6b21\u7684\u65b9\u5f0f\u5f88\u5bb9\u6613\u8d85\u65f6\uff0c\u6240\u4ee5\u5728\u8f93\u5165\u65f6\u5c31**\u6309\u987a\u65f6\u9488\u65b9\u5411\u7684\u9488\u5bf9\u4e00\u4e2a\u57fa\u70b9\u7684\u8ddd\u79bb distance **\uff0c\u4ee5\u7a7a\u95f4\u6362\u65f6\u95f4\uff0c\u5c31\u5f88nice","title":"\u601d\u8def"},{"location":"pat/shortest-distance/#_3","text":"\u592a\u4e45\u6ca1\u7528c\u4e86\uff0c\u4e00\u53ea\u7528c++\uff0c\u90fd\u5fd8\u8bb0 scanf \u4e2d\u662f\u8981\u5199\u53d8\u91cf\u5730\u5740\u7684\ud83d\ude05\uff0c\u771f\u5c34\u5c2c\uff0c \u66f4\u65b0\u7528c++\u5199","title":"\u95ee\u9898"},{"location":"pat/shortest-distance/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <iostream> #include <vector> #include <algorithm> using namespace std ; int main () { int N ; cin >> N ; vector < int > D ( N ), distance ; //distance[i]\u8868\u793a\u4ece\u4e0b\u6807\u4e3a0\u5230\u4e0b\u6807\u4e3ai\u7684\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb distance . push_back ( 0 ); int sum = 0 ; for ( auto i = 0 ; i != N ; ++ i ){ cin >> D [ i ]; if ( i ) distance . push_back ( sum ); sum += D [ i ]; } int M , a , b ; cin >> M ; while ( M -- ){ cin >> a >> b ; if ( a > b ) swap ( a , b ); //\u5e8f\u53f7\u53d8\u4e3a\u4e0b\u6807 auto temp = distance [ b - 1 ] - distance [ a - 1 ]; cout << min ( temp , sum - temp ) << endl ; } return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/shuffling-machine/","text":"Shuffling Machine \u00b6 \u9898\u5e72\u5927\u610f \u00b6 \u5bf954\u5f20\u724c\u8fdb\u884c\u7ed9\u5b9a\u6b21\u6570\u4e14\u7ed9\u5b9a\u5e8f\u5217\u7684\u6d17\u724c\u6a21\u62df\u3002 \u601d\u8def \u00b6 \u8bbe\u4e00\u4e2a res \u6570\u7ec4\u7528\u6765\u8bb0\u5f55\u6700\u7ec8\u7b2ci\u5f20\u724c\u5728\u521d\u59cb\u5e8f\u5217(S1~S13,...,D13,J1,J2)\u4e2d\u7684\u5e8f\u53f7\u3002\u5bf9\u6bcf\u4e2a\u724c\u6839\u636e\u7ed9\u5b9a\u7684 shuffleseq \u8fdb\u884c\u7ed9\u5b9a cnt \u6b21\u5957\u5a03\u67e5\u627e\u3002\u6700\u7ec8\u7ed3\u679c\u6839\u636e\u521d\u59cb\u5e8f\u5217\u7684\u5e8f\u53f7\u8fdb\u884c\u6620\u5c04\uff0c\u4e0d\u9ebb\u70e6. \u95ee\u9898 \u00b6 \u4e0d\u5ba1\u9898... no extra space at the end of the line \u8fd9\u51e0\u884c\u5b57\u88ab\u6211\u5403\u4e86\uff0c\u592a\u4e45\u6ca1\u505a\u9898\u4e86\u3002 AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include <iostream> #include <vector> using namespace std ; int main () { int cnt ; //\u5faa\u73af\u6b21\u6570 //\u6d17\u724c\u5e8f\u5217\u3001\u6700\u7ec8\u7ed3\u679cres--res[i]\u4e2d\u8bb0\u5f55\u7684\u662f\u7b2ci\u4e2a\u724c\u5728\u521d\u59cb\u5e8f\u5217\u7684\u987a\u5e8f vector < int > shuffleSeq , res ( 55 ); shuffleSeq . push_back ( -1 ); const char card [ 5 ] = { 'S' , 'H' , 'C' , 'D' , 'J' }; if ( cin >> cnt , cnt ){ for ( int n ; cin >> n ; shuffleSeq . push_back ( n )); int curP , truP = 1 ; for ( int i = 1 ; i != 55 ; ++ i ){ curP = i ; //\u5faa\u73afcnt\u6b21 for ( int j = 0 ; j != cnt ; ++ j ){ truP = shuffleSeq [ curP ]; curP = truP ; } //\u7b2ci\u4e2a\u724c\u6700\u7ec8\u4f4d\u7f6e\u4e3atruP res [ truP ] = i ; } } //\u5faa\u73af\u6b21\u6570\u4e3a0 else for ( auto it = res . begin () + 1 ; it != res . end (); ++ it ) * it = it - res . begin (); for ( auto it = res . begin () + 1 ; it != res . end (); ++ it ){ //\u683c\u5f0f\u4fee\u6b63\uff0c\u5982\u521d\u59cb\u4e3a\u7b2c25\u4e2a\u724c\u662f(25-1)/13 = 1,H\u7ec4\u7684\u7b2c(25-1)%13+1 = 12\u4e2a\uff0c\u5373H12 cout << card [( * it - 1 ) / 13 ] << (( * it - 1 ) % 13 + 1 ); //\u6700\u540e\u672b\u5c3e\u4e0d\u8f93\u51fa\u7a7a\u683c if ( it - res . begin () != 54 ) cout << ' ' ; } return 0 ; }","title":"Shuffling Machine"},{"location":"pat/shuffling-machine/#shuffling-machine","text":"","title":"Shuffling Machine"},{"location":"pat/shuffling-machine/#_1","text":"\u5bf954\u5f20\u724c\u8fdb\u884c\u7ed9\u5b9a\u6b21\u6570\u4e14\u7ed9\u5b9a\u5e8f\u5217\u7684\u6d17\u724c\u6a21\u62df\u3002","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/shuffling-machine/#_2","text":"\u8bbe\u4e00\u4e2a res \u6570\u7ec4\u7528\u6765\u8bb0\u5f55\u6700\u7ec8\u7b2ci\u5f20\u724c\u5728\u521d\u59cb\u5e8f\u5217(S1~S13,...,D13,J1,J2)\u4e2d\u7684\u5e8f\u53f7\u3002\u5bf9\u6bcf\u4e2a\u724c\u6839\u636e\u7ed9\u5b9a\u7684 shuffleseq \u8fdb\u884c\u7ed9\u5b9a cnt \u6b21\u5957\u5a03\u67e5\u627e\u3002\u6700\u7ec8\u7ed3\u679c\u6839\u636e\u521d\u59cb\u5e8f\u5217\u7684\u5e8f\u53f7\u8fdb\u884c\u6620\u5c04\uff0c\u4e0d\u9ebb\u70e6.","title":"\u601d\u8def"},{"location":"pat/shuffling-machine/#_3","text":"\u4e0d\u5ba1\u9898... no extra space at the end of the line \u8fd9\u51e0\u884c\u5b57\u88ab\u6211\u5403\u4e86\uff0c\u592a\u4e45\u6ca1\u505a\u9898\u4e86\u3002","title":"\u95ee\u9898"},{"location":"pat/shuffling-machine/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include <iostream> #include <vector> using namespace std ; int main () { int cnt ; //\u5faa\u73af\u6b21\u6570 //\u6d17\u724c\u5e8f\u5217\u3001\u6700\u7ec8\u7ed3\u679cres--res[i]\u4e2d\u8bb0\u5f55\u7684\u662f\u7b2ci\u4e2a\u724c\u5728\u521d\u59cb\u5e8f\u5217\u7684\u987a\u5e8f vector < int > shuffleSeq , res ( 55 ); shuffleSeq . push_back ( -1 ); const char card [ 5 ] = { 'S' , 'H' , 'C' , 'D' , 'J' }; if ( cin >> cnt , cnt ){ for ( int n ; cin >> n ; shuffleSeq . push_back ( n )); int curP , truP = 1 ; for ( int i = 1 ; i != 55 ; ++ i ){ curP = i ; //\u5faa\u73afcnt\u6b21 for ( int j = 0 ; j != cnt ; ++ j ){ truP = shuffleSeq [ curP ]; curP = truP ; } //\u7b2ci\u4e2a\u724c\u6700\u7ec8\u4f4d\u7f6e\u4e3atruP res [ truP ] = i ; } } //\u5faa\u73af\u6b21\u6570\u4e3a0 else for ( auto it = res . begin () + 1 ; it != res . end (); ++ it ) * it = it - res . begin (); for ( auto it = res . begin () + 1 ; it != res . end (); ++ it ){ //\u683c\u5f0f\u4fee\u6b63\uff0c\u5982\u521d\u59cb\u4e3a\u7b2c25\u4e2a\u724c\u662f(25-1)/13 = 1,H\u7ec4\u7684\u7b2c(25-1)%13+1 = 12\u4e2a\uff0c\u5373H12 cout << card [( * it - 1 ) / 13 ] << (( * it - 1 ) % 13 + 1 ); //\u6700\u540e\u672b\u5c3e\u4e0d\u8f93\u51fa\u7a7a\u683c if ( it - res . begin () != 54 ) cout << ' ' ; } return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/sign-in-and-sign-out/","text":"Sign in and Sign out \u00b6 \u9898\u76ee\u94fe\u63a5 1006 Sign In and Sign Out (25 \u5206) \u9898\u5e72\u5927\u610f \u00b6 \u6839\u636e\u65f6\u95f4\uff0c\u8f93\u51fa\u6700\u65e9\u6765\u548c\u6700\u665a\u8d70\u7684\u4eba\u7684 id \u601d\u8def \u00b6 \u8f93\u5165\u65f6\u5373\u7528 earliest \u548c latest \u5904\u7406\u4fdd\u5b58\u5f53\u524d\u5df2\u7ecf\u8f93\u5165\u7684\u4eba\u4e2d\u7684\u6700\u65e9\u548c\u6700\u665a AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include <iostream> using namespace std ; struct employee { string id ; int hour {}, minute {}, second {}; } temp , earliest , latest ; bool great ( employee & a , employee & b ) { if ( a . hour != b . hour ) return a . hour > b . hour ; else if ( a . minute != b . minute ) return a . minute > b . minute ; else return a . second > b . second ; } int main () { int n ; cin >> n ; earliest . hour = 24 , earliest . minute = 60 , earliest . second = 60 ; latest . hour = latest . minute = latest . second = 0 ; while ( n -- ) { char c ; cin >> temp . id >> temp . hour >> c >> temp . minute >> c >> temp . second ; if ( ! great ( temp , earliest )) earliest = temp ; cin >> temp . hour >> c >> temp . minute >> c >> temp . second ; if ( great ( temp , latest )) swap ( temp , latest ); // \u6ce8\u610f\u7528swap\u7684\u8bdd\uff0c\u53ea\u80fd\u4ea4\u6362\u4e00\u6b21\uff0c\u56e0\u4e3a\u6709\u4e24\u4e2a\u503c\u9700\u8981\u66f4\u65b0 } cout << earliest . id << \" \" << latest . id ; return 0 ; }","title":"A1006"},{"location":"pat/sign-in-and-sign-out/#sign-in-and-sign-out","text":"\u9898\u76ee\u94fe\u63a5 1006 Sign In and Sign Out (25 \u5206)","title":"Sign in and Sign out"},{"location":"pat/sign-in-and-sign-out/#_1","text":"\u6839\u636e\u65f6\u95f4\uff0c\u8f93\u51fa\u6700\u65e9\u6765\u548c\u6700\u665a\u8d70\u7684\u4eba\u7684 id","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/sign-in-and-sign-out/#_2","text":"\u8f93\u5165\u65f6\u5373\u7528 earliest \u548c latest \u5904\u7406\u4fdd\u5b58\u5f53\u524d\u5df2\u7ecf\u8f93\u5165\u7684\u4eba\u4e2d\u7684\u6700\u65e9\u548c\u6700\u665a","title":"\u601d\u8def"},{"location":"pat/sign-in-and-sign-out/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include <iostream> using namespace std ; struct employee { string id ; int hour {}, minute {}, second {}; } temp , earliest , latest ; bool great ( employee & a , employee & b ) { if ( a . hour != b . hour ) return a . hour > b . hour ; else if ( a . minute != b . minute ) return a . minute > b . minute ; else return a . second > b . second ; } int main () { int n ; cin >> n ; earliest . hour = 24 , earliest . minute = 60 , earliest . second = 60 ; latest . hour = latest . minute = latest . second = 0 ; while ( n -- ) { char c ; cin >> temp . id >> temp . hour >> c >> temp . minute >> c >> temp . second ; if ( ! great ( temp , earliest )) earliest = temp ; cin >> temp . hour >> c >> temp . minute >> c >> temp . second ; if ( great ( temp , latest )) swap ( temp , latest ); // \u6ce8\u610f\u7528swap\u7684\u8bdd\uff0c\u53ea\u80fd\u4ea4\u6362\u4e00\u6b21\uff0c\u56e0\u4e3a\u6709\u4e24\u4e2a\u503c\u9700\u8981\u66f4\u65b0 } cout << earliest . id << \" \" << latest . id ; return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/speech-patterns/","text":"Speech Patterns \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1071 Speech Patterns (25 point(s)) \u9898\u5e72\u5927\u610f \u00b6 \u7edf\u8ba1\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u5355\u8bcd \u601d\u8def \u00b6 \u7edf\u8ba1\u5355\u8bcd\u6570\uff0c\u4e5f\u5c31\u662f\u8981\u5206\u5272\u5355\u8bcd\uff0c\u8fd9\u91cc\u6ce8\u610f\u5355\u8bcd\u6709\u5927\u5c0f\u5199\u5b57\u6bcd\u548c\u6570\u5b57\u7ec4\u6210\uff0c\u4ee5\u53ca\u5bf9\u975e\u6709\u6548\u5b57\u7b26\u7684\u5224\u65ad AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include <iostream> #include <map> using namespace std ; int main () { map < string , int > count ; string str ; getline ( cin , str ); int i = 0 ; while ( i < str . length ()) { string word ; while ( i < str . length () && isalnum ( str [ i ])) { if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) // \u6539\u4e3a\u5c0f\u5199 str [ i ] += 32 ; word += str [ i ++ ]; } if ( ! word . empty ()) { // \u7edf\u8ba1\u51fa\u662f\u4e2a\u5355\u8bcd if ( count . find ( word ) == count . end ()) count [ word ] = 1 ; else ++ count [ word ]; } while ( i < str . length () && ! isalnum ( str [ i ])) ++ i ; // \u8df3\u8fc7\u975e\u5355\u8bcd\u5b57\u7b26 } string ans ; int max = 0 ; for ( auto & it : count ) { if ( it . second > max ) { max = it . second ; ans = it . first ; } } cout << ans << \" \" << max ; return 0 ; }","title":"A1071"},{"location":"pat/speech-patterns/#speech-patterns","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1071 Speech Patterns (25 point(s))","title":"Speech Patterns"},{"location":"pat/speech-patterns/#_1","text":"\u7edf\u8ba1\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u5355\u8bcd","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/speech-patterns/#_2","text":"\u7edf\u8ba1\u5355\u8bcd\u6570\uff0c\u4e5f\u5c31\u662f\u8981\u5206\u5272\u5355\u8bcd\uff0c\u8fd9\u91cc\u6ce8\u610f\u5355\u8bcd\u6709\u5927\u5c0f\u5199\u5b57\u6bcd\u548c\u6570\u5b57\u7ec4\u6210\uff0c\u4ee5\u53ca\u5bf9\u975e\u6709\u6548\u5b57\u7b26\u7684\u5224\u65ad","title":"\u601d\u8def"},{"location":"pat/speech-patterns/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include <iostream> #include <map> using namespace std ; int main () { map < string , int > count ; string str ; getline ( cin , str ); int i = 0 ; while ( i < str . length ()) { string word ; while ( i < str . length () && isalnum ( str [ i ])) { if ( str [ i ] >= 'A' && str [ i ] <= 'Z' ) // \u6539\u4e3a\u5c0f\u5199 str [ i ] += 32 ; word += str [ i ++ ]; } if ( ! word . empty ()) { // \u7edf\u8ba1\u51fa\u662f\u4e2a\u5355\u8bcd if ( count . find ( word ) == count . end ()) count [ word ] = 1 ; else ++ count [ word ]; } while ( i < str . length () && ! isalnum ( str [ i ])) ++ i ; // \u8df3\u8fc7\u975e\u5355\u8bcd\u5b57\u7b26 } string ans ; int max = 0 ; for ( auto & it : count ) { if ( it . second > max ) { max = it . second ; ans = it . first ; } } cout << ans << \" \" << max ; return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/spell-it-right/","text":"Spell it Right \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1005 Spell It Right (20 point(s)) \u9898\u5e72\u5927\u610f \u00b6 \u5c06\u7ed9\u5b9a\u7684\u6570\u6bcf\u4e00\u4f4d\u52a0\u8d77\u6765\uff0c\u8f93\u51fa\u548c\u7684\u6bcf\u4e00\u4f4d\u7684\u82f1\u6587 \u601d\u8def \u00b6 \u5b57\u7b26\u4e32\u5904\u7406\uff0c\u7528\u597d to_string \u3002\u53e6\u5916\uff0c\u5b66\u4e60\u4e86\u5982\u4f55\u5728 auto \u904d\u5386\u4e2d\u5224\u65ad\u662f\u6700\u540e\u4e00\u4e2a\u5143\u7d20 AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <iostream> using namespace std ; char number [ 11 ][ 6 ] = { \"zero\" , \"one\" , \"two\" , \"three\" , \"four\" , \"five\" , \"six\" , \"seven\" , \"eight\" , \"nine\" , \"ten\" }; int main () { string str ; cin >> str ; int sum = 0 ; for ( auto & s : str ) { sum += s - '0' ; } string ans = to_string ( sum ); for ( auto & s : ans ) { cout << number [ s - '0' ]; if ( & s != & ans . back ()) // \u5224\u65ad\u662f\u5426\u662f\u6700\u540e\u4e00\u4e2a\u5143\u7d20\uff0c\u6bd4\u8f83\u5730\u5740 cout << \" \" ; } return 0 ; }","title":"A1005"},{"location":"pat/spell-it-right/#spell-it-right","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1005 Spell It Right (20 point(s))","title":"Spell it Right"},{"location":"pat/spell-it-right/#_1","text":"\u5c06\u7ed9\u5b9a\u7684\u6570\u6bcf\u4e00\u4f4d\u52a0\u8d77\u6765\uff0c\u8f93\u51fa\u548c\u7684\u6bcf\u4e00\u4f4d\u7684\u82f1\u6587","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/spell-it-right/#_2","text":"\u5b57\u7b26\u4e32\u5904\u7406\uff0c\u7528\u597d to_string \u3002\u53e6\u5916\uff0c\u5b66\u4e60\u4e86\u5982\u4f55\u5728 auto \u904d\u5386\u4e2d\u5224\u65ad\u662f\u6700\u540e\u4e00\u4e2a\u5143\u7d20","title":"\u601d\u8def"},{"location":"pat/spell-it-right/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <iostream> using namespace std ; char number [ 11 ][ 6 ] = { \"zero\" , \"one\" , \"two\" , \"three\" , \"four\" , \"five\" , \"six\" , \"seven\" , \"eight\" , \"nine\" , \"ten\" }; int main () { string str ; cin >> str ; int sum = 0 ; for ( auto & s : str ) { sum += s - '0' ; } string ans = to_string ( sum ); for ( auto & s : ans ) { cout << number [ s - '0' ]; if ( & s != & ans . back ()) // \u5224\u65ad\u662f\u5426\u662f\u6700\u540e\u4e00\u4e2a\u5143\u7d20\uff0c\u6bd4\u8f83\u5730\u5740 cout << \" \" ; } return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/student-list-for-course/","text":"Student List for Course \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1047 Student List for Course (25 point(s)) \u9898\u5e72\u5927\u610f \u00b6 \u8ddf A1039 \u53cd\u8fc7\u6765\u4e86\uff0c\u7ed9\u4f60\u5b66\u751f\u4fe1\u606f\uff0c\u8f93\u51fa\u6bcf\u4e2a\u8bfe\u7a0b\u9009\u7684\u5b66\u751f\u4fe1\u606f\u3002 \u601d\u8def \u00b6 \u521a\u5f00\u59cb\uff0c\u76f4\u63a5\u5c06\u5b66\u751f\u540d\u5b57\u5b58\u5165 course \u5411\u91cf\uff0c\u4f46\u6700\u540e\u4e00\u4e2a\u603b\u8d85\u65f6\uff0c\u540e\u6765\u662f\u7528 unordered_map \u5b58\u50a8\u5b66\u751f\u4e0b\u6807\u4e0e\u540d\u5b57\u7684\u6620\u5c04\uff0c\u4ee5\u4e3a\u662f emplace_back string \u7684\u65f6\u5019\u8017\u65f6\uff0c\u4f46\u6700\u540e\u4e00\u4e2a\u8fd8\u662f\u8d85\u65f6\uff0c\u6700\u540e\u7ecf\u8fc7\u641c\u5bfb\uff0c\u624d\u77e5\u9053\u662f cout \u5bfc\u81f4\u7684\u95ee\u9898\uff0c\u6240\u4ee5\u8fd9\u4e2a\u9898\u7528\u4e0d\u7740 unordered_map \u3002 \u53e6\u5916\u4e0d\u5f97\u4e0d\u5410\u69fd\u4e00\u4e0b\uff0c\u9898\u76ee\u4e2d\u672c\u6765\u5c31\u8bf4\u672b\u5c3e\u6ca1\u6709\u989d\u5916\u7684\u7a7a\u884c\uff0c\u4e0b\u9762\u4ee3\u7801\u4e5f\u6ca1\u6709\u5bf9\u6700\u540e\u4e00\u884c\u8f93\u51fa\u6709\u5224\u65ad\u5c31\u80fd AC \uff0c\u5c31\u5f88\u65e0\u8bed\uff0c\uff0c\uff0c cout \u8d85\u65f6\u95ee\u9898\u5206\u6790 \u00b6 \u4e0a\u8ff0\u601d\u8def\u4e2d\uff0c\u5df2\u7ecf\u8868\u8ff0\uff0c\u521d\u6b65\u5199\u7684\u4ee3\u7801\u4e2d\uff0c\u8fc7\u4e0d\u4e86\u7b2c\u4e09\u4e2a\u6d4b\u8bd5\u70b9\uff0c\u4e00\u76f4\u8d85\u65f6\uff0c\u4e0b\u9762\u662f\u6211\u7684\u5904\u7406\u5206\u6790\u8fc7\u7a0b\uff1a \u7ecf\u8fc7\u641c\u5bfb\u8d44\u6599\uff0c\u5f97\u77e5\uff1a cout \u6bd4 printf \u591a\u4e2a\u7f13\u51b2\u533a\uff0c\u53ea\u6709\u5f53\u7f13\u51b2\u533a\u5199\u6ee1\u7684\u65f6\u5019\u624d\u4f1a\u771f\u6b63\u8f93\u51fa\uff0c\u800c\u5f53\u4f7f\u7528 std::endl \u8f93\u51fa\u6362\u884c\u65f6\uff0c\u672b\u5c3e\u4f1a\u518d\u8fd0\u884c\u4e00\u4e2a flush \u5f3a\u884c\u6e05\u9664\u7f13\u51b2\u533a\uff0c\u8fd9\u6837\u5c31\u6ca1\u80fd\u53d1\u6325 cout \u4e2d\u7f13\u51b2\u533a\u7684\u4f18\u5316\uff0c\u6240\u4ee5\u663e\u5f97\u8fd0\u884c\u65f6\u95f4\u8981\u957f\u3002\u4f46\u5f53\u4f7f\u7528 \"\\n\" \u8f93\u51fa\u6362\u884c\u65f6\uff0c\u5c31\u8ddf printf \u5dee\u4e0d\u591a\u4e86\uff08\u5c31\u672c\u9898\u800c\u8a00\uff09\u3002 \u53e6\u5916\uff0c printf \u4e0e cout \u4e0d\u8981\u6df7\u7528\uff0c\u56e0\u4e3a\u5728\u591a\u7ebf\u7a0b\u73af\u5883\u4e0b\uff0c\u4ed6\u4eec\u7684\u6267\u884c\u987a\u5e8f\u4e0d\u4e00\u5b9a\u4f1a\u662f\u6267\u884c\u5b8c\u4e00\u4e2a\u518d\u6267\u884c\u53e6\u4e00\u4e2a\uff0c\u800c\u4e00\u4e2a\u4e0d\u4f7f\u7528\u7f13\u51b2\u533a\u7684\u7a81\u7136\u8df3\u5230\u4f7f\u7528\u7f13\u51b2\u533a\u7684\u8f93\u51fa\u65b9\u5f0f\uff0c\u6216\u8005\u53cd\u8fc7\u6765\uff0c\u4f1a\u9020\u6210\u975e\u671f\u671b\u7684\u7ed3\u679c\u3002 \u6240\u4ee5\uff0c\u6700\u7ec8\u7ed3\u8bba\u662f\uff0c\u8fd9\u9053\u9898\uff0c cout \u4f7f\u7528 \\n \u8f93\u51fa\u6362\u884c\u4e00\u6837\u4e5f\u80fd\u8fc7\uff01\uff01\uff01 AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include <iostream> #include <vector> #include <algorithm> // #include <cstdio> using namespace std ; int main () { int N , K ; istream :: sync_with_stdio ( false ); // \u5173\u95ed\u540c\u6b65\uff0c\u65f6\u95f4\u4e0a\u4f1a\u5feb\u4e2a\u7ea6200\u591ams cin >> N >> K ; vector < vector < string >> course ( K + 1 ); for ( int i = 0 ; i < N ; ++ i ) { string name ; int num , id ; cin >> name >> num ; for ( int j = 0 ; j < num ; ++ j ) { cin >> id ; course [ id ]. emplace_back ( name ); } } for ( int i = 1 ; i <= K ; ++ i ) { // printf(\"%d %d\\n\", i, course[i].size()); cout << i << \" \" << course [ i ]. size () << \" \\n \" ; // \u540c\u6837\u4f7f\u7528 lambda \u8868\u8fbe\u5f0f\uff0c\u771f\u7684\u5f88\u7b80\u6d01 sort ( course [ i ]. begin (), course [ i ]. end (), []( string a , string b ){ return a < b ; }); for ( auto & it : course [ i ]) { // printf(\"%s\\n\", it.c_str()); // c_str() \u8f6c\u6362\u6210c\u8bed\u8a00\u98ce\u683c\u65f6\u5b57\u7b26\u4e32 cout << it << \" \\n \" ; } } return 0 ; }","title":"A1047"},{"location":"pat/student-list-for-course/#student-list-for-course","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1047 Student List for Course (25 point(s))","title":"Student List for Course"},{"location":"pat/student-list-for-course/#_1","text":"\u8ddf A1039 \u53cd\u8fc7\u6765\u4e86\uff0c\u7ed9\u4f60\u5b66\u751f\u4fe1\u606f\uff0c\u8f93\u51fa\u6bcf\u4e2a\u8bfe\u7a0b\u9009\u7684\u5b66\u751f\u4fe1\u606f\u3002","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/student-list-for-course/#_2","text":"\u521a\u5f00\u59cb\uff0c\u76f4\u63a5\u5c06\u5b66\u751f\u540d\u5b57\u5b58\u5165 course \u5411\u91cf\uff0c\u4f46\u6700\u540e\u4e00\u4e2a\u603b\u8d85\u65f6\uff0c\u540e\u6765\u662f\u7528 unordered_map \u5b58\u50a8\u5b66\u751f\u4e0b\u6807\u4e0e\u540d\u5b57\u7684\u6620\u5c04\uff0c\u4ee5\u4e3a\u662f emplace_back string \u7684\u65f6\u5019\u8017\u65f6\uff0c\u4f46\u6700\u540e\u4e00\u4e2a\u8fd8\u662f\u8d85\u65f6\uff0c\u6700\u540e\u7ecf\u8fc7\u641c\u5bfb\uff0c\u624d\u77e5\u9053\u662f cout \u5bfc\u81f4\u7684\u95ee\u9898\uff0c\u6240\u4ee5\u8fd9\u4e2a\u9898\u7528\u4e0d\u7740 unordered_map \u3002 \u53e6\u5916\u4e0d\u5f97\u4e0d\u5410\u69fd\u4e00\u4e0b\uff0c\u9898\u76ee\u4e2d\u672c\u6765\u5c31\u8bf4\u672b\u5c3e\u6ca1\u6709\u989d\u5916\u7684\u7a7a\u884c\uff0c\u4e0b\u9762\u4ee3\u7801\u4e5f\u6ca1\u6709\u5bf9\u6700\u540e\u4e00\u884c\u8f93\u51fa\u6709\u5224\u65ad\u5c31\u80fd AC \uff0c\u5c31\u5f88\u65e0\u8bed\uff0c\uff0c\uff0c","title":"\u601d\u8def"},{"location":"pat/student-list-for-course/#cout","text":"\u4e0a\u8ff0\u601d\u8def\u4e2d\uff0c\u5df2\u7ecf\u8868\u8ff0\uff0c\u521d\u6b65\u5199\u7684\u4ee3\u7801\u4e2d\uff0c\u8fc7\u4e0d\u4e86\u7b2c\u4e09\u4e2a\u6d4b\u8bd5\u70b9\uff0c\u4e00\u76f4\u8d85\u65f6\uff0c\u4e0b\u9762\u662f\u6211\u7684\u5904\u7406\u5206\u6790\u8fc7\u7a0b\uff1a \u7ecf\u8fc7\u641c\u5bfb\u8d44\u6599\uff0c\u5f97\u77e5\uff1a cout \u6bd4 printf \u591a\u4e2a\u7f13\u51b2\u533a\uff0c\u53ea\u6709\u5f53\u7f13\u51b2\u533a\u5199\u6ee1\u7684\u65f6\u5019\u624d\u4f1a\u771f\u6b63\u8f93\u51fa\uff0c\u800c\u5f53\u4f7f\u7528 std::endl \u8f93\u51fa\u6362\u884c\u65f6\uff0c\u672b\u5c3e\u4f1a\u518d\u8fd0\u884c\u4e00\u4e2a flush \u5f3a\u884c\u6e05\u9664\u7f13\u51b2\u533a\uff0c\u8fd9\u6837\u5c31\u6ca1\u80fd\u53d1\u6325 cout \u4e2d\u7f13\u51b2\u533a\u7684\u4f18\u5316\uff0c\u6240\u4ee5\u663e\u5f97\u8fd0\u884c\u65f6\u95f4\u8981\u957f\u3002\u4f46\u5f53\u4f7f\u7528 \"\\n\" \u8f93\u51fa\u6362\u884c\u65f6\uff0c\u5c31\u8ddf printf \u5dee\u4e0d\u591a\u4e86\uff08\u5c31\u672c\u9898\u800c\u8a00\uff09\u3002 \u53e6\u5916\uff0c printf \u4e0e cout \u4e0d\u8981\u6df7\u7528\uff0c\u56e0\u4e3a\u5728\u591a\u7ebf\u7a0b\u73af\u5883\u4e0b\uff0c\u4ed6\u4eec\u7684\u6267\u884c\u987a\u5e8f\u4e0d\u4e00\u5b9a\u4f1a\u662f\u6267\u884c\u5b8c\u4e00\u4e2a\u518d\u6267\u884c\u53e6\u4e00\u4e2a\uff0c\u800c\u4e00\u4e2a\u4e0d\u4f7f\u7528\u7f13\u51b2\u533a\u7684\u7a81\u7136\u8df3\u5230\u4f7f\u7528\u7f13\u51b2\u533a\u7684\u8f93\u51fa\u65b9\u5f0f\uff0c\u6216\u8005\u53cd\u8fc7\u6765\uff0c\u4f1a\u9020\u6210\u975e\u671f\u671b\u7684\u7ed3\u679c\u3002 \u6240\u4ee5\uff0c\u6700\u7ec8\u7ed3\u8bba\u662f\uff0c\u8fd9\u9053\u9898\uff0c cout \u4f7f\u7528 \\n \u8f93\u51fa\u6362\u884c\u4e00\u6837\u4e5f\u80fd\u8fc7\uff01\uff01\uff01","title":"cout\u8d85\u65f6\u95ee\u9898\u5206\u6790"},{"location":"pat/student-list-for-course/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include <iostream> #include <vector> #include <algorithm> // #include <cstdio> using namespace std ; int main () { int N , K ; istream :: sync_with_stdio ( false ); // \u5173\u95ed\u540c\u6b65\uff0c\u65f6\u95f4\u4e0a\u4f1a\u5feb\u4e2a\u7ea6200\u591ams cin >> N >> K ; vector < vector < string >> course ( K + 1 ); for ( int i = 0 ; i < N ; ++ i ) { string name ; int num , id ; cin >> name >> num ; for ( int j = 0 ; j < num ; ++ j ) { cin >> id ; course [ id ]. emplace_back ( name ); } } for ( int i = 1 ; i <= K ; ++ i ) { // printf(\"%d %d\\n\", i, course[i].size()); cout << i << \" \" << course [ i ]. size () << \" \\n \" ; // \u540c\u6837\u4f7f\u7528 lambda \u8868\u8fbe\u5f0f\uff0c\u771f\u7684\u5f88\u7b80\u6d01 sort ( course [ i ]. begin (), course [ i ]. end (), []( string a , string b ){ return a < b ; }); for ( auto & it : course [ i ]) { // printf(\"%s\\n\", it.c_str()); // c_str() \u8f6c\u6362\u6210c\u8bed\u8a00\u98ce\u683c\u65f6\u5b57\u7b26\u4e32 cout << it << \" \\n \" ; } } return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/the-dominant-color/","text":"The Dominant Color \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1054 The Dominant Color (20 point(s)) \u9898\u5e72\u5927\u610f \u00b6 \u7edf\u8ba1\u4e00\u4e2a\u77e9\u9635\u4e2d\u8d85\u8fc7\u534a\u6570\uff08\u672c\u9898\u4fdd\u8bc1\u4e86\uff09\uff0c\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u503c \u601d\u8def \u00b6 \u672c\u6765\u53ef\u4ee5\u5f00\u8f9f\u4e00\u4e2a\u5f88\u5927\u7684\u6570\u7ec4\uff0cm * n\u6765\u4fdd\u5b58\u6bcf\u4e2a\u53ef\u80fd\u7684\u503c\uff0c\u4f46\u662f\u9898\u76ee\u4e2d\u7684\u503c\u8303\u56f4\u4e3a[0, 2^24]\uff0c\u8fc7\u4e8e\u5927\u4e86\uff0c\u6240\u4ee5\u91c7\u7528 map \u6620\u5c04\u7684\u529e\u6cd5\u3002 AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <iostream> #include <map> using namespace std ; int main () { int m , n ; ios :: sync_with_stdio ( false ); cin >> m >> n ; int color ; map < int , int > count ; // color\u4e0ecount\u6b21\u6570\u7684\u6620\u5c04 for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { cin >> color ; if ( count . find ( color ) == count . end ()) // \u8fd8\u672a\u88ab\u7edf\u8ba1 count [ color ] = 1 ; // \u8ba1\u6570\u4e3a1 else ++ count [ color ]; } } // \u904d\u5386map\uff0c\u6c42\u51fa\u6700\u5927\u7684\u90a3\u4e2acolor int maxColor = 0 , maxCount = 0 ; for ( auto it = count . begin (); it != count . end (); ++ it ) { if ( it -> second > maxCount ) { maxCount = it -> second ; maxColor = it -> first ; } } cout << maxColor << endl ; return 0 ; }","title":"A1054"},{"location":"pat/the-dominant-color/#the-dominant-color","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1054 The Dominant Color (20 point(s))","title":"The Dominant Color"},{"location":"pat/the-dominant-color/#_1","text":"\u7edf\u8ba1\u4e00\u4e2a\u77e9\u9635\u4e2d\u8d85\u8fc7\u534a\u6570\uff08\u672c\u9898\u4fdd\u8bc1\u4e86\uff09\uff0c\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u503c","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/the-dominant-color/#_2","text":"\u672c\u6765\u53ef\u4ee5\u5f00\u8f9f\u4e00\u4e2a\u5f88\u5927\u7684\u6570\u7ec4\uff0cm * n\u6765\u4fdd\u5b58\u6bcf\u4e2a\u53ef\u80fd\u7684\u503c\uff0c\u4f46\u662f\u9898\u76ee\u4e2d\u7684\u503c\u8303\u56f4\u4e3a[0, 2^24]\uff0c\u8fc7\u4e8e\u5927\u4e86\uff0c\u6240\u4ee5\u91c7\u7528 map \u6620\u5c04\u7684\u529e\u6cd5\u3002","title":"\u601d\u8def"},{"location":"pat/the-dominant-color/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <iostream> #include <map> using namespace std ; int main () { int m , n ; ios :: sync_with_stdio ( false ); cin >> m >> n ; int color ; map < int , int > count ; // color\u4e0ecount\u6b21\u6570\u7684\u6620\u5c04 for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { cin >> color ; if ( count . find ( color ) == count . end ()) // \u8fd8\u672a\u88ab\u7edf\u8ba1 count [ color ] = 1 ; // \u8ba1\u6570\u4e3a1 else ++ count [ color ]; } } // \u904d\u5386map\uff0c\u6c42\u51fa\u6700\u5927\u7684\u90a3\u4e2acolor int maxColor = 0 , maxCount = 0 ; for ( auto it = count . begin (); it != count . end (); ++ it ) { if ( it -> second > maxCount ) { maxCount = it -> second ; maxColor = it -> first ; } } cout << maxColor << endl ; return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/tree-traversals-again/","text":"Tree Traversals Again \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1086 Tree Traversals Again (25 point(s)) \u9898\u5e72\u5927\u610f \u00b6 \u7ed9\u5b9a\u4e8c\u53c9\u6811\u7684\u8282\u70b9\u6570\uff0c\u4ee5\u53ca\u7528\u6808\u5b9e\u73b0\u7684\u4e2d\u5e8f\u904d\u5386\u7684\u64cd\u4f5c\u5e8f\u5217\uff0c\u8981\u6c42\u7ed9\u51fa\u540e\u5e8f\u904d\u5386\u5e8f\u5217 \u601d\u8def \u00b6 \u6839\u636e\u6808\u7684\u64cd\u4f5c\u5e8f\u5217\u6211\u4eec\u5f88\u5bb9\u6613\u5f97\u51fa\u8fd9\u68f5\u6811\u7684\u524d\u5e8f\u904d\u5386\u5e8f\u5217\uff08\u5373\uff0c push \u7684\u987a\u5e8f\uff09\u548c\u4e2d\u5e8f\u904d\u5386\u5e8f\u5217\uff08\u5373\uff0c pop \u7684\u987a\u5e8f\uff09\uff0c\u7136\u540e\u6839\u636e\u524d\u5e8f\u548c\u4e2d\u5e8f\u5f97\u51fa\u4e8c\u53c9\u6811\u7136\u540e\u518d\u540e\u5e8f\u904d\u5386\u5373\u53ef\u3002 \u4f46\uff0c\u6211\u7b2c\u4e00\u53cd\u5e94\u6ca1\u6709\u60f3\u7740\u8fd9\u6837\u5b50\u5f04\uff0c\u53ef\u80fd\u662f\u9093\u516c\u7684\u6570\u636e\u7ed3\u6784\u8ba9\u6211\u5bf9\u4e2d\u5e8f\u904d\u5386\u7684\u8fed\u4ee3\u5b9e\u73b0\u7684\u5f62\u5f0f\u6709\u4e86\u66f4\u591a\u7684\u4e86\u89e3\uff0c\u6211\u7b2c\u4e00\u53cd\u5e94\u662f\u76f4\u63a5\u6839\u636e\u6808\u7684\u64cd\u4f5c\u5e8f\u5217\u6784\u9020\u4e00\u68f5\u6811\uff0c\u5373\u7b2c\u4e00\u4e2a\u4e00\u5b9a\u662f push \u7136\u540e\u8fd9\u4e2a push \u7684\u4e00\u5b9a\u7684\u6839\u8282\u70b9\uff0c\u7136\u540e\u7b2c\u4e00\u4e2a push \u540e\u7d27\u8ddf\u7684 push \u4e00\u5b9a\u90fd\u662f\u4e00\u4e2a\u5de6\u4fa7\u94fe\uff0c\u5373\u5747\u662f\u4e0a\u4e00\u4e2a\u7684\u5de6\u5b69\u5b50\uff1b\u5f53\u4e0a\u4e00\u4e2a\u64cd\u4f5c\u662f push \u800c\u5f53\u524d\u64cd\u4f5c\u662f pop \u65f6\uff0c\u8868\u660e\uff0c\u6b64\u65f6\u5df2\u8fbe\u5f53\u524d\u5de6\u4fa7\u94fe\u7684\u6700\u5e95\u7aef\uff0c\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b69\u5b50\u4e3a\u7a7a\uff0c\u4e14\u5f53\u524d\u8282\u70b9\u5df2\u7ecf\u88ab pop \uff0c\u6b64\u65f6\u5e94\u5f53\u8f6c\u5411\u5176\u53f3\u5b69\u5b50\u8fdb\u884c\u8003\u5bdf\uff0c\u5f53\u53f3\u5b69\u5b50\u8003\u5bdf\u5b8c\u6bd5\u540e\u5e94\u8be5\u987a\u7740\u7236\u8282\u70b9\uff0c\u4e00\u76f4\u627e\u5230\u672a\u88ab pop \u7684\u7236\u8282\u70b9\uff0c pop \u5b83\u7136\u540e\u8f6c\u5411\u5b83\u7684\u53f3\u5b69\u5b50\u3002 \u8be6\u89c1\u4ee3\u7801 AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 #include <iostream> #include <vector> #include <queue> using namespace std ; struct node { int data ; struct node * left ; struct node * right ; struct node * parent ; // \u65b9\u4fbf\u56de\u6eaf bool status { false }; // \u4e3atrue\u65f6\u8868\u793a\u5f53\u524d\u8282\u70b9\u5df2\u88ab\u6808\u64cd\u4f5cpop\u6389\uff0c\u5373\u5e94\u5f53\u8003\u5bdf\u5176\u53f3\u5b69\u5b50\uff08\u5982\u679c\u5b58\u5728\uff09 }; int n ; vector < int > post ; // NOLINT vector < string > op ; node * construct () { node * root = new node ; root -> data = op [ 0 ][ 5 ] - '0' ; if ( op [ 0 ]. size () == 7 ) // \u4e00\u4e2a\u5751\uff0cn\u53d6\u503c\u53ef\u4ee5\u662f\u4e24\u4f4d\u6570\uff0c\u6211\u91c7\u7528\u7684\u662f\u5b57\u7b26\u4e32\u7684\u5904\u7406\u65b9\u6cd5\uff0c\u6240\u4ee5\u8981\u8003\u8651\u5230\u8fd9\u79cd\u60c5\u51b5\u3002 root -> data = root -> data * 10 + op [ 0 ][ 6 ] - '0' ; node * temp = root ; bool flag = true ; for ( auto it = op . begin () + 1 ; it != op . end (); ++ it ) { if ( flag && ( * it )[ 1 ] == 'u' ) { // \u6b64\u65f6\u8868\u793atemp\u8981\u63a5\u5165\u5de6\u5b69\u5b50 node * left = new node ; int num = ( * it )[ 5 ] - '0' ; if ( it -> size () == 7 ) num = num * 10 + ( * it )[ 6 ] - '0' ; left -> data = num ; temp -> left = left ; left -> parent = temp ; temp = temp -> left ; } else if ( flag && ( * it )[ 1 ] == 'o' ) { // \u8868\u793atemp\u5de6\u5b69\u5b50\u4e3a\u7a7a\uff0c\u4e14temp\u88abpop\u6389\u4e86 flag = ! flag ; temp -> status = true ; temp -> left = nullptr ; } else if ( ! flag && ( * it )[ 1 ] == 'o' ) { // \u8868\u793atemp\u53f3\u5b69\u5b50\u4e3a\u7a7a\uff0c\u4e14temp\u7684\u6700\u8fd1\u4e00\u4e2a\u672a\u88abpop\u7684\u7956\u7236\u8be5\u88abpop temp -> right = nullptr ; temp = temp -> parent ; while ( temp -> status ) // \u627e\u5230\u8fd8\u672a\u88abpop\u7684\u7956\u7236 temp = temp -> parent ; temp -> status = true ; // \u5c06\u5176pop } else if ( ! flag && ( * it )[ 1 ] == 'u' ) { // \u8868\u793atemp\u5b58\u5728\u53f3\u5b50\u6811\uff0c\u63a5\u5165 flag = ! flag ; node * right = new node ; int num = ( * it )[ 5 ] - '0' ; if ( it -> size () == 7 ) num = num * 10 + ( * it )[ 6 ] - '0' ; right -> data = num ; temp -> right = right ; right -> parent = temp ; temp = temp -> right ; } } return root ; } void traverse ( node * & tree ) { if ( ! tree ) return ; traverse ( tree -> left ); traverse ( tree -> right ); post . emplace_back ( tree -> data ); } int main () { cin >> n ; cin . get (); op . resize ( 2 * n ); for ( int i = 0 ; i < 2 * n ; ++ i ) getline ( cin , op [ i ]); node * tree = construct (); traverse ( tree ); for ( auto & it : post ) { cout << it ; if ( & it != & post . back ()) cout << \" \" ; } return 0 ; }","title":"A1086"},{"location":"pat/tree-traversals-again/#tree-traversals-again","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1086 Tree Traversals Again (25 point(s))","title":"Tree Traversals Again"},{"location":"pat/tree-traversals-again/#_1","text":"\u7ed9\u5b9a\u4e8c\u53c9\u6811\u7684\u8282\u70b9\u6570\uff0c\u4ee5\u53ca\u7528\u6808\u5b9e\u73b0\u7684\u4e2d\u5e8f\u904d\u5386\u7684\u64cd\u4f5c\u5e8f\u5217\uff0c\u8981\u6c42\u7ed9\u51fa\u540e\u5e8f\u904d\u5386\u5e8f\u5217","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/tree-traversals-again/#_2","text":"\u6839\u636e\u6808\u7684\u64cd\u4f5c\u5e8f\u5217\u6211\u4eec\u5f88\u5bb9\u6613\u5f97\u51fa\u8fd9\u68f5\u6811\u7684\u524d\u5e8f\u904d\u5386\u5e8f\u5217\uff08\u5373\uff0c push \u7684\u987a\u5e8f\uff09\u548c\u4e2d\u5e8f\u904d\u5386\u5e8f\u5217\uff08\u5373\uff0c pop \u7684\u987a\u5e8f\uff09\uff0c\u7136\u540e\u6839\u636e\u524d\u5e8f\u548c\u4e2d\u5e8f\u5f97\u51fa\u4e8c\u53c9\u6811\u7136\u540e\u518d\u540e\u5e8f\u904d\u5386\u5373\u53ef\u3002 \u4f46\uff0c\u6211\u7b2c\u4e00\u53cd\u5e94\u6ca1\u6709\u60f3\u7740\u8fd9\u6837\u5b50\u5f04\uff0c\u53ef\u80fd\u662f\u9093\u516c\u7684\u6570\u636e\u7ed3\u6784\u8ba9\u6211\u5bf9\u4e2d\u5e8f\u904d\u5386\u7684\u8fed\u4ee3\u5b9e\u73b0\u7684\u5f62\u5f0f\u6709\u4e86\u66f4\u591a\u7684\u4e86\u89e3\uff0c\u6211\u7b2c\u4e00\u53cd\u5e94\u662f\u76f4\u63a5\u6839\u636e\u6808\u7684\u64cd\u4f5c\u5e8f\u5217\u6784\u9020\u4e00\u68f5\u6811\uff0c\u5373\u7b2c\u4e00\u4e2a\u4e00\u5b9a\u662f push \u7136\u540e\u8fd9\u4e2a push \u7684\u4e00\u5b9a\u7684\u6839\u8282\u70b9\uff0c\u7136\u540e\u7b2c\u4e00\u4e2a push \u540e\u7d27\u8ddf\u7684 push \u4e00\u5b9a\u90fd\u662f\u4e00\u4e2a\u5de6\u4fa7\u94fe\uff0c\u5373\u5747\u662f\u4e0a\u4e00\u4e2a\u7684\u5de6\u5b69\u5b50\uff1b\u5f53\u4e0a\u4e00\u4e2a\u64cd\u4f5c\u662f push \u800c\u5f53\u524d\u64cd\u4f5c\u662f pop \u65f6\uff0c\u8868\u660e\uff0c\u6b64\u65f6\u5df2\u8fbe\u5f53\u524d\u5de6\u4fa7\u94fe\u7684\u6700\u5e95\u7aef\uff0c\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b69\u5b50\u4e3a\u7a7a\uff0c\u4e14\u5f53\u524d\u8282\u70b9\u5df2\u7ecf\u88ab pop \uff0c\u6b64\u65f6\u5e94\u5f53\u8f6c\u5411\u5176\u53f3\u5b69\u5b50\u8fdb\u884c\u8003\u5bdf\uff0c\u5f53\u53f3\u5b69\u5b50\u8003\u5bdf\u5b8c\u6bd5\u540e\u5e94\u8be5\u987a\u7740\u7236\u8282\u70b9\uff0c\u4e00\u76f4\u627e\u5230\u672a\u88ab pop \u7684\u7236\u8282\u70b9\uff0c pop \u5b83\u7136\u540e\u8f6c\u5411\u5b83\u7684\u53f3\u5b69\u5b50\u3002 \u8be6\u89c1\u4ee3\u7801","title":"\u601d\u8def"},{"location":"pat/tree-traversals-again/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 #include <iostream> #include <vector> #include <queue> using namespace std ; struct node { int data ; struct node * left ; struct node * right ; struct node * parent ; // \u65b9\u4fbf\u56de\u6eaf bool status { false }; // \u4e3atrue\u65f6\u8868\u793a\u5f53\u524d\u8282\u70b9\u5df2\u88ab\u6808\u64cd\u4f5cpop\u6389\uff0c\u5373\u5e94\u5f53\u8003\u5bdf\u5176\u53f3\u5b69\u5b50\uff08\u5982\u679c\u5b58\u5728\uff09 }; int n ; vector < int > post ; // NOLINT vector < string > op ; node * construct () { node * root = new node ; root -> data = op [ 0 ][ 5 ] - '0' ; if ( op [ 0 ]. size () == 7 ) // \u4e00\u4e2a\u5751\uff0cn\u53d6\u503c\u53ef\u4ee5\u662f\u4e24\u4f4d\u6570\uff0c\u6211\u91c7\u7528\u7684\u662f\u5b57\u7b26\u4e32\u7684\u5904\u7406\u65b9\u6cd5\uff0c\u6240\u4ee5\u8981\u8003\u8651\u5230\u8fd9\u79cd\u60c5\u51b5\u3002 root -> data = root -> data * 10 + op [ 0 ][ 6 ] - '0' ; node * temp = root ; bool flag = true ; for ( auto it = op . begin () + 1 ; it != op . end (); ++ it ) { if ( flag && ( * it )[ 1 ] == 'u' ) { // \u6b64\u65f6\u8868\u793atemp\u8981\u63a5\u5165\u5de6\u5b69\u5b50 node * left = new node ; int num = ( * it )[ 5 ] - '0' ; if ( it -> size () == 7 ) num = num * 10 + ( * it )[ 6 ] - '0' ; left -> data = num ; temp -> left = left ; left -> parent = temp ; temp = temp -> left ; } else if ( flag && ( * it )[ 1 ] == 'o' ) { // \u8868\u793atemp\u5de6\u5b69\u5b50\u4e3a\u7a7a\uff0c\u4e14temp\u88abpop\u6389\u4e86 flag = ! flag ; temp -> status = true ; temp -> left = nullptr ; } else if ( ! flag && ( * it )[ 1 ] == 'o' ) { // \u8868\u793atemp\u53f3\u5b69\u5b50\u4e3a\u7a7a\uff0c\u4e14temp\u7684\u6700\u8fd1\u4e00\u4e2a\u672a\u88abpop\u7684\u7956\u7236\u8be5\u88abpop temp -> right = nullptr ; temp = temp -> parent ; while ( temp -> status ) // \u627e\u5230\u8fd8\u672a\u88abpop\u7684\u7956\u7236 temp = temp -> parent ; temp -> status = true ; // \u5c06\u5176pop } else if ( ! flag && ( * it )[ 1 ] == 'u' ) { // \u8868\u793atemp\u5b58\u5728\u53f3\u5b50\u6811\uff0c\u63a5\u5165 flag = ! flag ; node * right = new node ; int num = ( * it )[ 5 ] - '0' ; if ( it -> size () == 7 ) num = num * 10 + ( * it )[ 6 ] - '0' ; right -> data = num ; temp -> right = right ; right -> parent = temp ; temp = temp -> right ; } } return root ; } void traverse ( node * & tree ) { if ( ! tree ) return ; traverse ( tree -> left ); traverse ( tree -> right ); post . emplace_back ( tree -> data ); } int main () { cin >> n ; cin . get (); op . resize ( 2 * n ); for ( int i = 0 ; i < 2 * n ; ++ i ) getline ( cin , op [ i ]); node * tree = construct (); traverse ( tree ); for ( auto & it : post ) { cout << it ; if ( & it != & post . back ()) cout << \" \" ; } return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/tree-traversals/","text":"Tree Traversals \u00b6 \u9898\u76ee\u94fe\u63a5\uff1a 1020 Tree Traversals (25 point(s)) \u9898\u5e72\u5927\u610f \u00b6 \u7ed9\u5b9a\u4e00\u68f5\u4e8c\u53c9\u6811\u7684\u8282\u70b9\u6570\u3001\u540e\u7eed\u904d\u5386\u5e8f\u5217\u3001\u4e2d\u5e8f\u904d\u5386\u5e8f\u5217\uff0c\u8981\u6c42\u8f93\u51fa\u5176\u5c42\u5e8f\u904d\u5386\u5e8f\u5217 \u601d\u8def \u00b6 \u4e2d\u5e8f\u904d\u5386\u53ef\u4ee5\u786e\u5b9a\u5de6\u53f3\u5b50\u6811\uff0c\u540e\u7eed\u904d\u5386\u53ef\u4ee5\u786e\u5b9a\u5b50\u6811\u7684\u6839\uff0c\u5148\u6784\u9020\u51fa\u4e8c\u53c9\u6811\uff0c\u7136\u540e\u505a\u5c42\u5e8f\u904d\u5386\u5373\u53ef AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include <iostream> #include <vector> #include <queue> using namespace std ; struct node { int data ; struct node * left ; struct node * right ; }; int n ; vector < int > post ; // NOLINT vector < int > in ; // NOLINT vector < int > layer ; node * construct ( int in_l , int in_r , int post_l , int post_r ) { if ( in_r - in_l < 1 ) { return nullptr ; } int key = post_r - 1 ; node * root = new node ; root -> data = post [ key ]; int i = in_l ; for (; i != in_r ; ++ i ) { if ( in [ i ] == post [ key ]) break ; } root -> left = construct ( in_l , i , post_l , post_r - in_r + i ); root -> right = construct ( i + 1 , in_r , post_r - in_r + i , post_r - 1 ); return root ; } void traverse ( node * & tree ) { if ( ! tree ) return ; queue < node *> q ; q . push ( tree ); while ( ! q . empty ()) { node * front = q . front (); q . pop (); layer . emplace_back ( front -> data ); if ( front -> left ) q . push ( front -> left ); if ( front -> right ) q . push ( front -> right ); } } int main () { cin >> n ; post . resize ( n ); in . resize ( n ); for ( auto & it : post ) cin >> it ; for ( auto & it : in ) cin >> it ; node * tree = construct ( 0 , n , 0 , n ); traverse ( tree ); for ( auto & it : layer ) { cout << it ; if ( & it != & layer . back ()) { cout << \" \" ; } } return 0 ; }","title":"A1020"},{"location":"pat/tree-traversals/#tree-traversals","text":"\u9898\u76ee\u94fe\u63a5\uff1a 1020 Tree Traversals (25 point(s))","title":"Tree Traversals"},{"location":"pat/tree-traversals/#_1","text":"\u7ed9\u5b9a\u4e00\u68f5\u4e8c\u53c9\u6811\u7684\u8282\u70b9\u6570\u3001\u540e\u7eed\u904d\u5386\u5e8f\u5217\u3001\u4e2d\u5e8f\u904d\u5386\u5e8f\u5217\uff0c\u8981\u6c42\u8f93\u51fa\u5176\u5c42\u5e8f\u904d\u5386\u5e8f\u5217","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/tree-traversals/#_2","text":"\u4e2d\u5e8f\u904d\u5386\u53ef\u4ee5\u786e\u5b9a\u5de6\u53f3\u5b50\u6811\uff0c\u540e\u7eed\u904d\u5386\u53ef\u4ee5\u786e\u5b9a\u5b50\u6811\u7684\u6839\uff0c\u5148\u6784\u9020\u51fa\u4e8c\u53c9\u6811\uff0c\u7136\u540e\u505a\u5c42\u5e8f\u904d\u5386\u5373\u53ef","title":"\u601d\u8def"},{"location":"pat/tree-traversals/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include <iostream> #include <vector> #include <queue> using namespace std ; struct node { int data ; struct node * left ; struct node * right ; }; int n ; vector < int > post ; // NOLINT vector < int > in ; // NOLINT vector < int > layer ; node * construct ( int in_l , int in_r , int post_l , int post_r ) { if ( in_r - in_l < 1 ) { return nullptr ; } int key = post_r - 1 ; node * root = new node ; root -> data = post [ key ]; int i = in_l ; for (; i != in_r ; ++ i ) { if ( in [ i ] == post [ key ]) break ; } root -> left = construct ( in_l , i , post_l , post_r - in_r + i ); root -> right = construct ( i + 1 , in_r , post_r - in_r + i , post_r - 1 ); return root ; } void traverse ( node * & tree ) { if ( ! tree ) return ; queue < node *> q ; q . push ( tree ); while ( ! q . empty ()) { node * front = q . front (); q . pop (); layer . emplace_back ( front -> data ); if ( front -> left ) q . push ( front -> left ); if ( front -> right ) q . push ( front -> right ); } } int main () { cin >> n ; post . resize ( n ); in . resize ( n ); for ( auto & it : post ) cin >> it ; for ( auto & it : in ) cin >> it ; node * tree = construct ( 0 , n , 0 , n ); traverse ( tree ); for ( auto & it : layer ) { cout << it ; if ( & it != & layer . back ()) { cout << \" \" ; } } return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"pat/waiting-in-line/","text":"Waiting in Line \u00b6 \u9898\u76ee\u94fe\u63a5 1014 Waiting in Line (30 \u5206) \u9898\u5e72\u5927\u610f \u00b6 \u6392\u5e8f\u8c03\u5ea6 \u601d\u8def \u00b6 \u6309\u65f6\u95f4\u4e00\u6b65\u6b65\u6a21\u62df\u987e\u5ba2\u88ab\u670d\u52a1\u7684\u8fc7\u7a0b \u95ee\u9898 \u00b6 \u53ea\u4f7f\u7528 vector \u8fc7\u4e86\u6d4b\u8bd5\u70b94\u30015\u6ca1\u8fc7\uff0c\u4e0d\u77e5\u9053\u600e\u4e48\u89e3\u51b3\uff0c\u540e\u7eed\u5c1d\u8bd5\u4f7f\u7528 queue \u89e3\u51b3\u3002 vector \u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 #include <iostream> #include <vector> using namespace std ; class customer { public : int time ; // \u9700\u8981\u670d\u52a1\u7684\u65f6\u95f4 int done ; // \u670d\u52a1\u7ed3\u675f\u65f6\u95f4 int serve ; // \u670d\u52a1\u5f00\u59cb\u65f6\u95f4 }; bool empty ( vector < vector < int >> & windows ) { bool flag = true ; for ( auto & window : windows ) { if ( ! window . empty ()) { flag = false ; break ; } } return flag ; } bool quick ( vector < vector < int >> & windows , vector < customer > & customers ) { bool flag = true ; for ( auto & window : windows ) { if ( window . empty ()) continue ; auto ip = window . begin (); if ( customers [ * ip ]. done == 0 ) { flag = false ; break ; } } return flag ; } int find_min ( vector < vector < int >> & windows , vector < customer > & customers ) { int min = 99999 ; // \u521d\u503c\u95ee\u9898 for ( auto & window : windows ) { if ( ! window . empty () && min > customers [ * window . begin ()]. time ) min = customers [ * window . begin ()]. time ; } return min ; } void serve ( vector < vector < int >> & windows , vector < customer > & customers , int M ) { int now = 0 ; int id = 0 ; for ( int i = 0 ; i < M ; ++ i ) { for ( auto it = windows . begin (); it != windows . end () && id < customers . size (); ++ it ) { if ( i == 0 ) customers [ id ]. serve = 0 ; it -> push_back ( id ++ ); } } while ( now <= 540 && ! empty ( windows )) { int min = find_min ( windows , customers ); now += min ; for ( auto & window : windows ) { if ( ! window . empty ()) { auto ip = window . begin (); if ( customers [ * ip ]. done == 0 ) customers [ * ip ]. time -= min ; if ( customers [ * ip ]. time == 0 ) { if ( customers [ * ip ]. done == 0 ) customers [ * ip ]. done = now ; window . erase ( ip ); if ( ! window . empty ()) // \u82e5\u4e0d\u7a7a\uff0c\u5219\u4e0b\u4e00\u4e2a\u5c31\u662f\u670d\u52a1\u5bf9\u8c61 customers [ * window . begin ()]. serve = now ; } } } // \u5982\u679c\u8fd8\u6709\u987e\u5ba2\u7b49\u5f85\u5219\u68c0\u67e5\u7a7a\u4f59\u5730\u65b9\u63d2\u5165\u987e\u5ba2 if ( id < customers . size ()) { for ( int i = 1 ; i <= M ; ++ i ) { for ( auto & window : windows ) { while ( window . size () < i && id < customers . size ()) { // \u961f\u5217\u662f\u5426\u6709\u4f4d\u7f6e if ( window . empty ()) { // \u961f\u5217\u4e3a\u7a7a, \u5219\u80af\u5b9a\u4f1a\u88ab\u670d\u52a1 if ( customers [ id ]. time + now >= 540 ) { customers [ id ]. done = customers [ id ]. time + now ; } customers [ * window . begin ()]. serve = now ; } else { if ( customers [ id ]. time + now + customers [ window . front ()]. time >= 540 ) { customers [ id ]. done = customers [ id ]. time + now + customers [ window . front ()]. time ; } } window . push_back ( id ++ ); } } } } if ( quick ( windows , customers )) break ; } } int main () { int N , M , K , Q ; cin >> N >> M >> K >> Q ; vector < vector < int >> windows ( N ); vector < customer > customers ( K ); for ( auto & customer : customers ) { cin >> customer . time ; customer . done = 0 ; customer . serve = 541 ; } vector < int > queries ( Q ); for ( int & query : queries ) { cin >> query ; } serve ( windows , customers , M ); auto it = customers . begin (); for ( auto i = 0 ; i < Q ; ++ i ) { if (( it + queries [ i ] - 1 ) -> done > 540 ) { if (( it + queries [ i ] - 1 ) -> serve < 540 ) { int hour = ( it + queries [ i ] -1 ) -> done / 60 + 8 ; int minute = ( it + queries [ i ] - 1 ) -> done % 60 ; if ( hour > 17 ) { cout << \"Sorry\" << endl ; continue ; } hour >= 10 ? ( cout << hour << \":\" ) : ( cout << 0 << hour << \":\" ); minute >= 10 ? ( cout << minute << endl ) : ( cout << 0 << minute << endl ); } else cout << \"Sorry\" << endl ; } else { int hour = ( it + queries [ i ] -1 ) -> done / 60 + 8 ; int minute = ( it + queries [ i ] - 1 ) -> done % 60 ; hour >= 10 ? ( cout << hour << \":\" ) : ( cout << 0 << hour << \":\" ); minute >= 10 ? ( cout << minute << endl ) : ( cout << 0 << minute << endl ); } } return 0 ; }","title":"A1014"},{"location":"pat/waiting-in-line/#waiting-in-line","text":"\u9898\u76ee\u94fe\u63a5 1014 Waiting in Line (30 \u5206)","title":"Waiting in Line"},{"location":"pat/waiting-in-line/#_1","text":"\u6392\u5e8f\u8c03\u5ea6","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/waiting-in-line/#_2","text":"\u6309\u65f6\u95f4\u4e00\u6b65\u6b65\u6a21\u62df\u987e\u5ba2\u88ab\u670d\u52a1\u7684\u8fc7\u7a0b","title":"\u601d\u8def"},{"location":"pat/waiting-in-line/#_3","text":"\u53ea\u4f7f\u7528 vector \u8fc7\u4e86\u6d4b\u8bd5\u70b94\u30015\u6ca1\u8fc7\uff0c\u4e0d\u77e5\u9053\u600e\u4e48\u89e3\u51b3\uff0c\u540e\u7eed\u5c1d\u8bd5\u4f7f\u7528 queue \u89e3\u51b3\u3002","title":"\u95ee\u9898"},{"location":"pat/waiting-in-line/#vector","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 #include <iostream> #include <vector> using namespace std ; class customer { public : int time ; // \u9700\u8981\u670d\u52a1\u7684\u65f6\u95f4 int done ; // \u670d\u52a1\u7ed3\u675f\u65f6\u95f4 int serve ; // \u670d\u52a1\u5f00\u59cb\u65f6\u95f4 }; bool empty ( vector < vector < int >> & windows ) { bool flag = true ; for ( auto & window : windows ) { if ( ! window . empty ()) { flag = false ; break ; } } return flag ; } bool quick ( vector < vector < int >> & windows , vector < customer > & customers ) { bool flag = true ; for ( auto & window : windows ) { if ( window . empty ()) continue ; auto ip = window . begin (); if ( customers [ * ip ]. done == 0 ) { flag = false ; break ; } } return flag ; } int find_min ( vector < vector < int >> & windows , vector < customer > & customers ) { int min = 99999 ; // \u521d\u503c\u95ee\u9898 for ( auto & window : windows ) { if ( ! window . empty () && min > customers [ * window . begin ()]. time ) min = customers [ * window . begin ()]. time ; } return min ; } void serve ( vector < vector < int >> & windows , vector < customer > & customers , int M ) { int now = 0 ; int id = 0 ; for ( int i = 0 ; i < M ; ++ i ) { for ( auto it = windows . begin (); it != windows . end () && id < customers . size (); ++ it ) { if ( i == 0 ) customers [ id ]. serve = 0 ; it -> push_back ( id ++ ); } } while ( now <= 540 && ! empty ( windows )) { int min = find_min ( windows , customers ); now += min ; for ( auto & window : windows ) { if ( ! window . empty ()) { auto ip = window . begin (); if ( customers [ * ip ]. done == 0 ) customers [ * ip ]. time -= min ; if ( customers [ * ip ]. time == 0 ) { if ( customers [ * ip ]. done == 0 ) customers [ * ip ]. done = now ; window . erase ( ip ); if ( ! window . empty ()) // \u82e5\u4e0d\u7a7a\uff0c\u5219\u4e0b\u4e00\u4e2a\u5c31\u662f\u670d\u52a1\u5bf9\u8c61 customers [ * window . begin ()]. serve = now ; } } } // \u5982\u679c\u8fd8\u6709\u987e\u5ba2\u7b49\u5f85\u5219\u68c0\u67e5\u7a7a\u4f59\u5730\u65b9\u63d2\u5165\u987e\u5ba2 if ( id < customers . size ()) { for ( int i = 1 ; i <= M ; ++ i ) { for ( auto & window : windows ) { while ( window . size () < i && id < customers . size ()) { // \u961f\u5217\u662f\u5426\u6709\u4f4d\u7f6e if ( window . empty ()) { // \u961f\u5217\u4e3a\u7a7a, \u5219\u80af\u5b9a\u4f1a\u88ab\u670d\u52a1 if ( customers [ id ]. time + now >= 540 ) { customers [ id ]. done = customers [ id ]. time + now ; } customers [ * window . begin ()]. serve = now ; } else { if ( customers [ id ]. time + now + customers [ window . front ()]. time >= 540 ) { customers [ id ]. done = customers [ id ]. time + now + customers [ window . front ()]. time ; } } window . push_back ( id ++ ); } } } } if ( quick ( windows , customers )) break ; } } int main () { int N , M , K , Q ; cin >> N >> M >> K >> Q ; vector < vector < int >> windows ( N ); vector < customer > customers ( K ); for ( auto & customer : customers ) { cin >> customer . time ; customer . done = 0 ; customer . serve = 541 ; } vector < int > queries ( Q ); for ( int & query : queries ) { cin >> query ; } serve ( windows , customers , M ); auto it = customers . begin (); for ( auto i = 0 ; i < Q ; ++ i ) { if (( it + queries [ i ] - 1 ) -> done > 540 ) { if (( it + queries [ i ] - 1 ) -> serve < 540 ) { int hour = ( it + queries [ i ] -1 ) -> done / 60 + 8 ; int minute = ( it + queries [ i ] - 1 ) -> done % 60 ; if ( hour > 17 ) { cout << \"Sorry\" << endl ; continue ; } hour >= 10 ? ( cout << hour << \":\" ) : ( cout << 0 << hour << \":\" ); minute >= 10 ? ( cout << minute << endl ) : ( cout << 0 << minute << endl ); } else cout << \"Sorry\" << endl ; } else { int hour = ( it + queries [ i ] -1 ) -> done / 60 + 8 ; int minute = ( it + queries [ i ] - 1 ) -> done % 60 ; hour >= 10 ? ( cout << hour << \":\" ) : ( cout << 0 << hour << \":\" ); minute >= 10 ? ( cout << minute << endl ) : ( cout << 0 << minute << endl ); } } return 0 ; }","title":"vector\u4ee3\u7801"},{"location":"pat/world-cup-betting/","text":"World Cup Betting \u00b6 \u9898\u76ee\u94fe\u63a5 1011 World Cup Betting (20 \u5206) \u9898\u5e72\u5927\u610f \u00b6 \u8fd9\u4e2a\u9898\uff0c\u9898\u76ee\u5199\u7684\u4e0d\u660e\u4e0d\u767d\uff0c\u6211\u6ca1\u592a\u8bfb\u61c2\uff0c\u770b\u4e86\u7b97\u6cd5\u7b14\u8bb0\uff0c\u624d\u77e5\u9053\uff0c\uff0c\uff0c\u53cd\u6b63\u5c31\u662f\uff0c\u9009\u51fa\u6bcf\u884c\u6700\u5927\u7684\uff0c\u6309\u7167\u516c\u5f0f\u8f93\u51fa\u5c31\u597d\u3002\u3002\u3002 \u601d\u8def \u00b6 \u7528\u4e00\u4e2a char \u5b58\u653e\u7ed3\u679c\u7684\u5b57\u7b26\uff0c\u91cd\u65b0\u56de\u987e\u4e00\u4e0b cout \u7684\u7cbe\u5ea6\u63a7\u5236 AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <iostream> #include <vector> #include <iomanip> // \u7cbe\u5ea6\u63a7\u5236\u5934\u6587\u4ef6 using namespace std ; char S [ 3 ] = { 'W' , 'T' , 'L' }; int main () { double ans = 1.0 , max ; int index ; for ( int i = 0 ; i < 3 ; ++ i ) { max = 0.0 ; for ( int j = 0 ; j < 3 ; ++ j ) { // \u6bcf\u884c\u5206\u522b\u5904\u7406 double temp ; cin >> temp ; if ( temp > max ) { max = temp ; index = j ; } } ans *= max ; cout << S [ index ] << \" \" ; } cout << setiosflags ( ios :: fixed ) << setprecision ( 2 ) << ( ans * 0.65 - 1 ) * 2 ; // \u7cbe\u5ea6\u5904\u7406\u683c\u5f0f return 0 ; }","title":"A1011"},{"location":"pat/world-cup-betting/#world-cup-betting","text":"\u9898\u76ee\u94fe\u63a5 1011 World Cup Betting (20 \u5206)","title":"World Cup Betting"},{"location":"pat/world-cup-betting/#_1","text":"\u8fd9\u4e2a\u9898\uff0c\u9898\u76ee\u5199\u7684\u4e0d\u660e\u4e0d\u767d\uff0c\u6211\u6ca1\u592a\u8bfb\u61c2\uff0c\u770b\u4e86\u7b97\u6cd5\u7b14\u8bb0\uff0c\u624d\u77e5\u9053\uff0c\uff0c\uff0c\u53cd\u6b63\u5c31\u662f\uff0c\u9009\u51fa\u6bcf\u884c\u6700\u5927\u7684\uff0c\u6309\u7167\u516c\u5f0f\u8f93\u51fa\u5c31\u597d\u3002\u3002\u3002","title":"\u9898\u5e72\u5927\u610f"},{"location":"pat/world-cup-betting/#_2","text":"\u7528\u4e00\u4e2a char \u5b58\u653e\u7ed3\u679c\u7684\u5b57\u7b26\uff0c\u91cd\u65b0\u56de\u987e\u4e00\u4e0b cout \u7684\u7cbe\u5ea6\u63a7\u5236","title":"\u601d\u8def"},{"location":"pat/world-cup-betting/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <iostream> #include <vector> #include <iomanip> // \u7cbe\u5ea6\u63a7\u5236\u5934\u6587\u4ef6 using namespace std ; char S [ 3 ] = { 'W' , 'T' , 'L' }; int main () { double ans = 1.0 , max ; int index ; for ( int i = 0 ; i < 3 ; ++ i ) { max = 0.0 ; for ( int j = 0 ; j < 3 ; ++ j ) { // \u6bcf\u884c\u5206\u522b\u5904\u7406 double temp ; cin >> temp ; if ( temp > max ) { max = temp ; index = j ; } } ans *= max ; cout << S [ index ] << \" \" ; } cout << setiosflags ( ios :: fixed ) << setprecision ( 2 ) << ( ans * 0.65 - 1 ) * 2 ; // \u7cbe\u5ea6\u5904\u7406\u683c\u5f0f return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"thu/light-house/","text":"LightHouse \u00b6 \u9898\u76ee\u5927\u610f \u00b6 \u6bcf\u4e2a\u706f\u5854\u53ef\u4ee5\u7167\u4eae\u4f4d\u4e8e\u5176\u5de6\u4e0b\u548c\u53f3\u4e0a\u7684\u706f\u5854\uff0c\u7ed9\u5b9a\u5750\u6807\uff0c\u627e\u51fa\u80fd\u4e92\u76f8\u7167\u4eae\u7684\u706f\u5854\u7684\u5bf9\u6570\uff0c\u53d8\u76f8\u7684\u9006\u5e8f\u5bf9\u3002 \u601d\u8def \u00b6 \u5148\u6839\u636e\u5176\u4e2d\u4e00\u4e2a\u5750\u6807\u6392\u5e8f\uff0c\u7136\u540e\u6839\u636e\u53e6\u4e00\u4e2a\u5750\u6807\u627e\u987a\u5e8f\u5bf9 \u95ee\u9898 \u00b6 \u6211\u662f\u8ddf\u7740\u9093\u8001\u5e08\u7684\u6570\u636e\u7ed3\u6784\u8bfe\u7a0b\u8fdb\u5ea6\u505a\u7684\u9898\uff0c\u672c\u60f3\u7740\u7528\u4e24\u6b21\u5f52\u5e76\u6392\u5e8f\uff08\u56e0\u4e3a\u5feb\u6392\u8fd8\u6ca1\u5b66\u5230\uff09\uff0c\u53ef\u5206\u6570\u4e00\u76f4\u5361\u572815\u5206--\uff08RunTime Error-signal 11-SIGSEGV\uff09\uff0c\u56e0\u4e3a\u8fd9\u4e2a\u4fe1\u53f7\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u662f\u7531\u4e8e\u6307\u9488\u8d8a\u754c\u7684\u95ee\u9898\uff0c\u8ba9\u6211\u4e00\u5ea6\u4ee5\u4e3a\u662f\u6211\u5f52\u5e76\u6392\u5e8f\u5199\u9519\u4e86\u3002 \u7ecf\u8fc7\u51e0\u4e2a\u5c0f\u65f6\u7684\u65e0\u80fd\u6323\u624e\uff0c\u7a81\u7136\u8bd5\u4e86\u4e0b\u7f51\u4e0a\u5927\u90e8\u5206\u4eba\u5957\u7528\u7684\u5feb\u6392\u51fd\u6570\uff0c\u4e00\u4e0b\u5c31AC\u4e86\ud83d\ude33 \u7136\u540e\u6211\u518d\u6b21\u9605\u8bfbSIGSEGV\u4fe1\u53f7\u7684\u5e38\u89c1\u7c7b\u578b\uff0c\u53d1\u73b0\u4e86\u7b2c4\u6761\u548c\u7b2c5\u6761\u3002\u3002\u3002 \u6211\u81ea\u5df1\u7684\u778e\u731c\u60f3\uff08\u6709\u5f85\u8fdb\u4e00\u6b65\u5b66\u4e60\u7136\u540e\u8003\u8bc1\uff09 \u82e5\u901a\u8fc7\u5f52\u5e76\u6392\u5e8f\u4ee5x\u5750\u6807\u4e3a\u57fa\u51c6\u8fdb\u884c\u6392\u5e8f\u65f6\uff0c\u6700\u5927\u9700\u8981\u5f00\u8f9f\u4e00\u4e2a\u5355\u5143\u4e2a\u6570\u4e3an\uff0c\u5355\u5143\u5927\u5c0f\u4e3a8B\uff08\u4e24\u4e2aint\uff09\u7684\u6570\u7ec4\uff0c\u7531\u9898\u5bf990%\u7684\u6d4b\u8bd5\u6837\u4f8b\uff0cn\u6700\u5927\u53d63*10^5\uff0c\u8fd9\u4e48\u7b97\u4e0b\u6765\u6700\u5c0f\u60c5\u51b5\u7684\u8fd9\u4e2a\u6700\u5927\u7684\u6570\u7ec4\u8981\u5360\u75282MB\u4ee5\u4e0a\uff0c\u518d\u52a0\u4e0a\u5f52\u5e76\u6392\u5e8f\u7684\u9012\u5f52\u6df1\u5ea6\u76f8\u5bf9\u4e8e\u5feb\u901f\u6392\u5e8f\u4e5f\u4e0d\u5c0f\uff0c\u6240\u4ee5\u53ef\u80fd\u5c31\u8d85\u51fa\u4e86\u51fd\u6570\u5185\u6808\u5185\u5b588MB\u7684\u9650\u5236hhh \u800c\u5feb\u901f\u6392\u5e8f\u7684\u7a7a\u95f4\u590d\u6742\u5ea6\u662fO(logn)\uff0c\u6bd4\u5f52\u5e76\u6392\u5e8f\u7684O(n)\u5c0f\u4e0d\u5c11 \u6216\u8bb8\u5c31\u662f\u8fd9\u4e2a\u539f\u56e0\u5427\uff0c\u6211\u76ee\u524d\u7684\u77e5\u8bc6\u50a8\u91cf\u4e5f\u5c31\u8fd9\u4e86\ud83d\ude43 AC\u4ee3\u7801 \u00b6 \u5148\u9644\u4e0aAC\u622a\u5c4f\uff0c\u827e\u739b\uff0c\u592a\u4e0d\u5bb9\u6613\u4e86\uff0c\u4e3b\u8981\u662f\u4e0d\u7ed9\u6d4b\u8bd5\u6570\u636e\uff0c\u5c31\u8ddf\u65e0\u5934\u82cd\u8747\u4e71\u649e\u4e00\u6837\uff0c\u7eaa\u5ff5\u4e00\u4e0b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 #include <iostream> #include <cstdlib> #include <cstdio> using namespace std ; struct LightHouse { int x , y ; } * lhs ; void invBetween ( int * y , int l , int mid , int r , long long & cnt ) { int la = mid - l ; int lb = r - mid ; int * A = new int [ la ]; for ( int i = 0 , j = l ; i < la ; A [ i ++ ] = y [ j ++ ]); int * B = y + mid ; for ( int i = 0 , j = 0 , k = l ; i < la ;) { if ( j >= lb '' A [ i ] < B [ j ]) { y [ k ++ ] = A [ i ++ ]; // \u987a\u5e8f\u5bf9 if ( j < lb ) cnt += ( long long )( lb - j ); } if ( j < lb && A [ i ] > B [ j ]) y [ k ++ ] = B [ j ++ ]; } //\u5f52\u5e76\u6392\u5e8f\u6838\u5fc3\u90e8\u5206\u7684\u53e6\u79cd\u5199\u6cd5\uff0c\u6211\u8fd8\u6000\u7591\u8fc7\u5199\u6cd5\u7684\u95ee\u9898\ud83e\udd23 // int i = 0, j = 0, k = l; // while(i < la) // { // if(j < lb && B[j] < A[i]) // { // y[k++] = B[j++]; // // \u9006\u5e8f\u5bf9 // cnt += (long long)(la - i); // } // else // y[k++] = A[i++]; // } delete [] A ; } void invInside ( int * y , int l , int r , long long & cnt ) { if ( r - l < 2 ) return ; int mid = ( l + r ) / 2 ; invInside ( y , l , mid , cnt ); invInside ( y , mid , r , cnt ); invBetween ( y , l , mid , r , cnt ); } //\u4e0b\u9762\u4e24\u4e2a\u51fd\u6570\u7528\u4e86qsort()\u540e\u5c31\u6ca1\u7528\u4e86 void merge ( int l , int mid , int r ) { int la = mid - l ; int lb = r - mid ; LightHouse * A = new LightHouse [ la ]; for ( int i = 0 , j = l ; i < lb ; A [ i ++ ] = lhs [ j ++ ]); LightHouse * B = lhs + mid ; int i = 0 , j = 0 , k = l ; while ( i < la ) { if ( j < lb && B [ j ]. x < A [ i ]. x ) lhs [ k ++ ] = B [ j ++ ]; else lhs [ k ++ ] = A [ i ++ ]; } delete [] A ; } void mergeSort ( int l , int r ) { if ( r - l < 2 ) return ; int mid = ( 1 + r ) / 2 ; mergeSort ( l , mid ); mergeSort ( mid , r ); merge ( l , mid , r ); } //void*\u578b\u6307\u9488\u7684\u4e00\u79cd\u7528\u6cd5 int cmp ( const void * v1 , const void * v2 ) { return (( LightHouse * ) v1 ) -> x - (( LightHouse * ) v2 ) -> x ; } int main () { int n ; // the number of lighthouse scanf ( \"%d\" , & n ); lhs = new LightHouse [ n ]; for ( int i = 0 ; i < n ; ++ i ) scanf ( \"%d %d\" , & lhs [ i ]. x , & lhs [ i ]. y ); // \u9898\u76ee\u63d0\u793a\u53ef\u80fd\u8d85\u51faint\u8868\u793a\u8303\u56f4\uff0c\u6240\u4ee5\u7528long long long long cnt = 0 ; // the number of sequence qsort ( lhs , n , sizeof ( LightHouse ), cmp ); // mergeSort(0, n); // sort based on x int * y = new int [ n ]; for ( int i = 0 ; i < n ; ++ i ) y [ i ] = lhs [ i ]. y ; invInside ( y , 0 , n , cnt ); // compute cnt based on y // \u4e24\u79cd\u8ba1\u7b97\u65b9\u5f0f\uff0c\u7b2c\u4e00\u4e2a\u662f\u7b97\u51fa\u9006\u5e8f\u5bf9\u7136\u540eC(n,2)\u51cf\u4e00\u4e0b\uff0c\u7b2c\u4e8c\u4e2a\u662f\u76f4\u63a5\u7b97\u51fa\u987a\u5e8f\u5bf9 // printf(\"%lld\", (long long)(n)*(long long)(n-1)/(long long)(2) - cnt); printf ( \"%lld\" , cnt ); delete [] lhs ; delete [] y ; return 0 ; }","title":"PA1"},{"location":"thu/light-house/#lighthouse","text":"","title":"LightHouse"},{"location":"thu/light-house/#_1","text":"\u6bcf\u4e2a\u706f\u5854\u53ef\u4ee5\u7167\u4eae\u4f4d\u4e8e\u5176\u5de6\u4e0b\u548c\u53f3\u4e0a\u7684\u706f\u5854\uff0c\u7ed9\u5b9a\u5750\u6807\uff0c\u627e\u51fa\u80fd\u4e92\u76f8\u7167\u4eae\u7684\u706f\u5854\u7684\u5bf9\u6570\uff0c\u53d8\u76f8\u7684\u9006\u5e8f\u5bf9\u3002","title":"\u9898\u76ee\u5927\u610f"},{"location":"thu/light-house/#_2","text":"\u5148\u6839\u636e\u5176\u4e2d\u4e00\u4e2a\u5750\u6807\u6392\u5e8f\uff0c\u7136\u540e\u6839\u636e\u53e6\u4e00\u4e2a\u5750\u6807\u627e\u987a\u5e8f\u5bf9","title":"\u601d\u8def"},{"location":"thu/light-house/#_3","text":"\u6211\u662f\u8ddf\u7740\u9093\u8001\u5e08\u7684\u6570\u636e\u7ed3\u6784\u8bfe\u7a0b\u8fdb\u5ea6\u505a\u7684\u9898\uff0c\u672c\u60f3\u7740\u7528\u4e24\u6b21\u5f52\u5e76\u6392\u5e8f\uff08\u56e0\u4e3a\u5feb\u6392\u8fd8\u6ca1\u5b66\u5230\uff09\uff0c\u53ef\u5206\u6570\u4e00\u76f4\u5361\u572815\u5206--\uff08RunTime Error-signal 11-SIGSEGV\uff09\uff0c\u56e0\u4e3a\u8fd9\u4e2a\u4fe1\u53f7\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u662f\u7531\u4e8e\u6307\u9488\u8d8a\u754c\u7684\u95ee\u9898\uff0c\u8ba9\u6211\u4e00\u5ea6\u4ee5\u4e3a\u662f\u6211\u5f52\u5e76\u6392\u5e8f\u5199\u9519\u4e86\u3002 \u7ecf\u8fc7\u51e0\u4e2a\u5c0f\u65f6\u7684\u65e0\u80fd\u6323\u624e\uff0c\u7a81\u7136\u8bd5\u4e86\u4e0b\u7f51\u4e0a\u5927\u90e8\u5206\u4eba\u5957\u7528\u7684\u5feb\u6392\u51fd\u6570\uff0c\u4e00\u4e0b\u5c31AC\u4e86\ud83d\ude33 \u7136\u540e\u6211\u518d\u6b21\u9605\u8bfbSIGSEGV\u4fe1\u53f7\u7684\u5e38\u89c1\u7c7b\u578b\uff0c\u53d1\u73b0\u4e86\u7b2c4\u6761\u548c\u7b2c5\u6761\u3002\u3002\u3002 \u6211\u81ea\u5df1\u7684\u778e\u731c\u60f3\uff08\u6709\u5f85\u8fdb\u4e00\u6b65\u5b66\u4e60\u7136\u540e\u8003\u8bc1\uff09 \u82e5\u901a\u8fc7\u5f52\u5e76\u6392\u5e8f\u4ee5x\u5750\u6807\u4e3a\u57fa\u51c6\u8fdb\u884c\u6392\u5e8f\u65f6\uff0c\u6700\u5927\u9700\u8981\u5f00\u8f9f\u4e00\u4e2a\u5355\u5143\u4e2a\u6570\u4e3an\uff0c\u5355\u5143\u5927\u5c0f\u4e3a8B\uff08\u4e24\u4e2aint\uff09\u7684\u6570\u7ec4\uff0c\u7531\u9898\u5bf990%\u7684\u6d4b\u8bd5\u6837\u4f8b\uff0cn\u6700\u5927\u53d63*10^5\uff0c\u8fd9\u4e48\u7b97\u4e0b\u6765\u6700\u5c0f\u60c5\u51b5\u7684\u8fd9\u4e2a\u6700\u5927\u7684\u6570\u7ec4\u8981\u5360\u75282MB\u4ee5\u4e0a\uff0c\u518d\u52a0\u4e0a\u5f52\u5e76\u6392\u5e8f\u7684\u9012\u5f52\u6df1\u5ea6\u76f8\u5bf9\u4e8e\u5feb\u901f\u6392\u5e8f\u4e5f\u4e0d\u5c0f\uff0c\u6240\u4ee5\u53ef\u80fd\u5c31\u8d85\u51fa\u4e86\u51fd\u6570\u5185\u6808\u5185\u5b588MB\u7684\u9650\u5236hhh \u800c\u5feb\u901f\u6392\u5e8f\u7684\u7a7a\u95f4\u590d\u6742\u5ea6\u662fO(logn)\uff0c\u6bd4\u5f52\u5e76\u6392\u5e8f\u7684O(n)\u5c0f\u4e0d\u5c11 \u6216\u8bb8\u5c31\u662f\u8fd9\u4e2a\u539f\u56e0\u5427\uff0c\u6211\u76ee\u524d\u7684\u77e5\u8bc6\u50a8\u91cf\u4e5f\u5c31\u8fd9\u4e86\ud83d\ude43","title":"\u95ee\u9898"},{"location":"thu/light-house/#ac","text":"\u5148\u9644\u4e0aAC\u622a\u5c4f\uff0c\u827e\u739b\uff0c\u592a\u4e0d\u5bb9\u6613\u4e86\uff0c\u4e3b\u8981\u662f\u4e0d\u7ed9\u6d4b\u8bd5\u6570\u636e\uff0c\u5c31\u8ddf\u65e0\u5934\u82cd\u8747\u4e71\u649e\u4e00\u6837\uff0c\u7eaa\u5ff5\u4e00\u4e0b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 #include <iostream> #include <cstdlib> #include <cstdio> using namespace std ; struct LightHouse { int x , y ; } * lhs ; void invBetween ( int * y , int l , int mid , int r , long long & cnt ) { int la = mid - l ; int lb = r - mid ; int * A = new int [ la ]; for ( int i = 0 , j = l ; i < la ; A [ i ++ ] = y [ j ++ ]); int * B = y + mid ; for ( int i = 0 , j = 0 , k = l ; i < la ;) { if ( j >= lb '' A [ i ] < B [ j ]) { y [ k ++ ] = A [ i ++ ]; // \u987a\u5e8f\u5bf9 if ( j < lb ) cnt += ( long long )( lb - j ); } if ( j < lb && A [ i ] > B [ j ]) y [ k ++ ] = B [ j ++ ]; } //\u5f52\u5e76\u6392\u5e8f\u6838\u5fc3\u90e8\u5206\u7684\u53e6\u79cd\u5199\u6cd5\uff0c\u6211\u8fd8\u6000\u7591\u8fc7\u5199\u6cd5\u7684\u95ee\u9898\ud83e\udd23 // int i = 0, j = 0, k = l; // while(i < la) // { // if(j < lb && B[j] < A[i]) // { // y[k++] = B[j++]; // // \u9006\u5e8f\u5bf9 // cnt += (long long)(la - i); // } // else // y[k++] = A[i++]; // } delete [] A ; } void invInside ( int * y , int l , int r , long long & cnt ) { if ( r - l < 2 ) return ; int mid = ( l + r ) / 2 ; invInside ( y , l , mid , cnt ); invInside ( y , mid , r , cnt ); invBetween ( y , l , mid , r , cnt ); } //\u4e0b\u9762\u4e24\u4e2a\u51fd\u6570\u7528\u4e86qsort()\u540e\u5c31\u6ca1\u7528\u4e86 void merge ( int l , int mid , int r ) { int la = mid - l ; int lb = r - mid ; LightHouse * A = new LightHouse [ la ]; for ( int i = 0 , j = l ; i < lb ; A [ i ++ ] = lhs [ j ++ ]); LightHouse * B = lhs + mid ; int i = 0 , j = 0 , k = l ; while ( i < la ) { if ( j < lb && B [ j ]. x < A [ i ]. x ) lhs [ k ++ ] = B [ j ++ ]; else lhs [ k ++ ] = A [ i ++ ]; } delete [] A ; } void mergeSort ( int l , int r ) { if ( r - l < 2 ) return ; int mid = ( 1 + r ) / 2 ; mergeSort ( l , mid ); mergeSort ( mid , r ); merge ( l , mid , r ); } //void*\u578b\u6307\u9488\u7684\u4e00\u79cd\u7528\u6cd5 int cmp ( const void * v1 , const void * v2 ) { return (( LightHouse * ) v1 ) -> x - (( LightHouse * ) v2 ) -> x ; } int main () { int n ; // the number of lighthouse scanf ( \"%d\" , & n ); lhs = new LightHouse [ n ]; for ( int i = 0 ; i < n ; ++ i ) scanf ( \"%d %d\" , & lhs [ i ]. x , & lhs [ i ]. y ); // \u9898\u76ee\u63d0\u793a\u53ef\u80fd\u8d85\u51faint\u8868\u793a\u8303\u56f4\uff0c\u6240\u4ee5\u7528long long long long cnt = 0 ; // the number of sequence qsort ( lhs , n , sizeof ( LightHouse ), cmp ); // mergeSort(0, n); // sort based on x int * y = new int [ n ]; for ( int i = 0 ; i < n ; ++ i ) y [ i ] = lhs [ i ]. y ; invInside ( y , 0 , n , cnt ); // compute cnt based on y // \u4e24\u79cd\u8ba1\u7b97\u65b9\u5f0f\uff0c\u7b2c\u4e00\u4e2a\u662f\u7b97\u51fa\u9006\u5e8f\u5bf9\u7136\u540eC(n,2)\u51cf\u4e00\u4e0b\uff0c\u7b2c\u4e8c\u4e2a\u662f\u76f4\u63a5\u7b97\u51fa\u987a\u5e8f\u5bf9 // printf(\"%lld\", (long long)(n)*(long long)(n-1)/(long long)(2) - cnt); printf ( \"%lld\" , cnt ); delete [] lhs ; delete [] y ; return 0 ; }","title":"AC\u4ee3\u7801"},{"location":"thu/proper-rebuild/","text":"Proper Rebuild \u00b6 \u9898\u76ee\u5927\u610f \u00b6 \u7531\u7ed9\u5b9a\u7684\u5148\u5e8f\u904d\u5386\u3001\u540e\u5e8f\u904d\u5386\u5e8f\u5217\uff0c\u786e\u5b9a\u552f\u4e00\u7684\u771f\u4e8c\u53c9\u6811\u7684\u4e2d\u5e8f\u904d\u5386\u5e8f\u5217 \u601d\u8def \u00b6 \u771f\u4e8c\u53c9\u6811\u5373\u6bcf\u4e2a\u5185\u90e8\u8282\u70b9\u90fd\u6709\u4e24\u4e2a\u5b69\u5b50\u7684\u4e8c\u53c9\u6811\u3002\u5229\u7528\u9012\u5f52\u7684\u601d\u8def\u521b\u5efa\u6811\uff0c\u7136\u540e\u4e2d\u5e8f\u904d\u5386\u4e00\u4e0b\u3002 \u5148\u5e8f\u904d\u5386\u7684\u5934\u4e00\u4e2a\u8282\u70b9\u4e00\u5b9a\u662f\u6839\u7ed3\u70b9\uff0c\u4e0b\u4e00\u4e2a\u4e00\u5b9a\u662f\u5de6\u5b69\u5b50 \u95ee\u9898 \u00b6 \u6211\u8fc7\u4e8e\u60f3\u7528c++\u5199\u4e86\uff0c\u4f46\u662f\u5bf9c++\u53c8\u4ec5\u4ec5\u662f\u5165\u95e8\u9636\u6bb5\uff0c\u4ee5\u4e3a struct \u4e0d\u5e94\u8be5\u51fa\u73b0\u5728\u4e00\u4e2a\u6210\u719f\u7684c++\u4ee3\u7801\u4e2d\uff0c\u540e\u6765\u624d\u53d1\u73b0\u6211\u9519\u4e86\uff0c\uff0c AC\u4ee3\u7801 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 // main.cpp // ProperRebuild // // Created by lip0041 on 2021/1/21. // #include <iostream> #include <cstdio> using namespace std ; const int MAX = 4e6 + 10 ; int pre [ MAX ]; int post [ MAX ]; struct Node { int data ; struct Node * left ; struct Node * right ; }; //\u521b\u5efa\u6811 struct Node * buildtree ( int l1 , int r1 , int l2 , int r2 ) { //\u5f53\u524d\u6839\u7ed3\u70b9 struct Node * root = new struct Node ; root -> data = pre [ l1 ]; root -> left = root -> right = nullptr ; //p\u4e3a\u5f53\u524d\u6839\u7684\u5de6\u5b69\u5b50\u5728\u540e\u5e8f\u904d\u5386\u4e2d\u7684\u4f4d\u7f6e int p = 0 ; if ( r2 == l2 ) return root ; // \u627e\u4e0b\u4e00\u4e2a\u5de6\u6839\u5728post\u4e2d\u7684\u4f4d\u7f6e for ( int i = l2 ; i <= r2 ; ++ i ) if ( post [ i ] == pre [ l1 + 1 ]) { p = i ; break ; } //\u7531p\u5c06post\u5e8f\u5217\u5206\u5f00\uff0ct\u4e3a\u5de6\u8fb9\u5b50\u6811\u7684\u4e2a\u6570 int t = p - l2 + 1 ; root -> left = buildtree ( l1 + 1 , l1 + t , l2 , p ); root -> right = buildtree ( l1 + t + 1 , r1 , p + 1 , r2 -1 ); return root ; } //\u4e2d\u5e8f\u904d\u5386 void traversal ( struct Node * root ) { if ( root == nullptr ) return ; traversal ( root -> left ); cout << root -> data << \" \" ; traversal ( root -> right ); } int main () { int n ; cin >> n ; for ( int i = 0 ; i < n ; ++ i ) cin >> pre [ i ]; for ( int i = 0 ; i < n ; ++ i ) cin >> post [ i ]; struct Node * root = buildtree ( 0 , n -1 , 0 , n -1 ); traversal ( root ); return 0 ; }","title":"PA2"},{"location":"thu/proper-rebuild/#proper-rebuild","text":"","title":"Proper Rebuild"},{"location":"thu/proper-rebuild/#_1","text":"\u7531\u7ed9\u5b9a\u7684\u5148\u5e8f\u904d\u5386\u3001\u540e\u5e8f\u904d\u5386\u5e8f\u5217\uff0c\u786e\u5b9a\u552f\u4e00\u7684\u771f\u4e8c\u53c9\u6811\u7684\u4e2d\u5e8f\u904d\u5386\u5e8f\u5217","title":"\u9898\u76ee\u5927\u610f"},{"location":"thu/proper-rebuild/#_2","text":"\u771f\u4e8c\u53c9\u6811\u5373\u6bcf\u4e2a\u5185\u90e8\u8282\u70b9\u90fd\u6709\u4e24\u4e2a\u5b69\u5b50\u7684\u4e8c\u53c9\u6811\u3002\u5229\u7528\u9012\u5f52\u7684\u601d\u8def\u521b\u5efa\u6811\uff0c\u7136\u540e\u4e2d\u5e8f\u904d\u5386\u4e00\u4e0b\u3002 \u5148\u5e8f\u904d\u5386\u7684\u5934\u4e00\u4e2a\u8282\u70b9\u4e00\u5b9a\u662f\u6839\u7ed3\u70b9\uff0c\u4e0b\u4e00\u4e2a\u4e00\u5b9a\u662f\u5de6\u5b69\u5b50","title":"\u601d\u8def"},{"location":"thu/proper-rebuild/#_3","text":"\u6211\u8fc7\u4e8e\u60f3\u7528c++\u5199\u4e86\uff0c\u4f46\u662f\u5bf9c++\u53c8\u4ec5\u4ec5\u662f\u5165\u95e8\u9636\u6bb5\uff0c\u4ee5\u4e3a struct \u4e0d\u5e94\u8be5\u51fa\u73b0\u5728\u4e00\u4e2a\u6210\u719f\u7684c++\u4ee3\u7801\u4e2d\uff0c\u540e\u6765\u624d\u53d1\u73b0\u6211\u9519\u4e86\uff0c\uff0c","title":"\u95ee\u9898"},{"location":"thu/proper-rebuild/#ac","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 // main.cpp // ProperRebuild // // Created by lip0041 on 2021/1/21. // #include <iostream> #include <cstdio> using namespace std ; const int MAX = 4e6 + 10 ; int pre [ MAX ]; int post [ MAX ]; struct Node { int data ; struct Node * left ; struct Node * right ; }; //\u521b\u5efa\u6811 struct Node * buildtree ( int l1 , int r1 , int l2 , int r2 ) { //\u5f53\u524d\u6839\u7ed3\u70b9 struct Node * root = new struct Node ; root -> data = pre [ l1 ]; root -> left = root -> right = nullptr ; //p\u4e3a\u5f53\u524d\u6839\u7684\u5de6\u5b69\u5b50\u5728\u540e\u5e8f\u904d\u5386\u4e2d\u7684\u4f4d\u7f6e int p = 0 ; if ( r2 == l2 ) return root ; // \u627e\u4e0b\u4e00\u4e2a\u5de6\u6839\u5728post\u4e2d\u7684\u4f4d\u7f6e for ( int i = l2 ; i <= r2 ; ++ i ) if ( post [ i ] == pre [ l1 + 1 ]) { p = i ; break ; } //\u7531p\u5c06post\u5e8f\u5217\u5206\u5f00\uff0ct\u4e3a\u5de6\u8fb9\u5b50\u6811\u7684\u4e2a\u6570 int t = p - l2 + 1 ; root -> left = buildtree ( l1 + 1 , l1 + t , l2 , p ); root -> right = buildtree ( l1 + t + 1 , r1 , p + 1 , r2 -1 ); return root ; } //\u4e2d\u5e8f\u904d\u5386 void traversal ( struct Node * root ) { if ( root == nullptr ) return ; traversal ( root -> left ); cout << root -> data << \" \" ; traversal ( root -> right ); } int main () { int n ; cin >> n ; for ( int i = 0 ; i < n ; ++ i ) cin >> pre [ i ]; for ( int i = 0 ; i < n ; ++ i ) cin >> post [ i ]; struct Node * root = buildtree ( 0 , n -1 , 0 , n -1 ); traversal ( root ); return 0 ; }","title":"AC\u4ee3\u7801"}]}